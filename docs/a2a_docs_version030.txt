This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter), security check has been disabled.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: tests/**/*.*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
.github/
  actions/
    spelling/
      advice.md
      allow.txt
      excludes.txt
      line_forbidden.patterns
  ISSUE_TEMPLATE/
    bug-report.yml
    feature-request.yml
  workflows/
    linter.yaml
    python-publish.yml
    release-please.yml
    security.yaml
    spelling.yaml
    stale.yaml
    unit-tests.yml
    update-a2a-types.yml
  CODEOWNERS
  conventional-commit-lint.yaml
  PULL_REQUEST_TEMPLATE.md
scripts/
  format.sh
  generate_types.sh
  grpc_gen_post_processor.py
src/
  a2a/
    auth/
      user.py
    client/
      auth/
        __init__.py
        credentials.py
        interceptor.py
      transports/
        __init__.py
        base.py
        grpc.py
        jsonrpc.py
        rest.py
      __init__.py
      base_client.py
      card_resolver.py
      client_factory.py
      client_task_manager.py
      client.py
      errors.py
      helpers.py
      legacy_grpc.py
      legacy.py
      middleware.py
      optionals.py
    extensions/
      common.py
    grpc/
      a2a_pb2_grpc.py
      a2a_pb2.py
      a2a_pb2.pyi
    server/
      agent_execution/
        __init__.py
        agent_executor.py
        context.py
        request_context_builder.py
        simple_request_context_builder.py
      apps/
        jsonrpc/
          __init__.py
          fastapi_app.py
          jsonrpc_app.py
          starlette_app.py
        rest/
          __init__.py
          fastapi_app.py
          rest_adapter.py
        __init__.py
      events/
        __init__.py
        event_consumer.py
        event_queue.py
        in_memory_queue_manager.py
        queue_manager.py
      request_handlers/
        __init__.py
        default_request_handler.py
        grpc_handler.py
        jsonrpc_handler.py
        request_handler.py
        response_helpers.py
        rest_handler.py
      tasks/
        __init__.py
        base_push_notification_sender.py
        database_push_notification_config_store.py
        database_task_store.py
        inmemory_push_notification_config_store.py
        inmemory_task_store.py
        push_notification_config_store.py
        push_notification_sender.py
        result_aggregator.py
        task_manager.py
        task_store.py
        task_updater.py
      __init__.py
      context.py
      models.py
    utils/
      __init__.py
      artifact.py
      constants.py
      error_handlers.py
      errors.py
      helpers.py
      message.py
      proto_utils.py
      task.py
      telemetry.py
    __init__.py
    _base.py
    types.py
.coveragerc
.git-blame-ignore-revs
.gitignore
.jscpd.json
.mypy.ini
.pre-commit-config.yaml
.python-version
.ruff.toml
buf.gen.yaml
CHANGELOG.md
CODE_OF_CONDUCT.md
CONTRIBUTING.md
Gemini.md
LICENSE
pyproject.toml
README.md
SECURITY.md

================================================================
Files
================================================================

================
File: .github/actions/spelling/advice.md
================
<!-- See https://github.com/check-spelling/check-spelling/wiki/Configuration-Examples%3A-advice --> <!-- markdownlint-disable MD033 MD041 -->
<details><summary>If the flagged items are :exploding_head: false positives</summary>

If items relate to a ...

- binary file (or some other file you wouldn't want to check at all).

  Please add a file path to the `excludes.txt` file matching the containing file.

  File paths are Perl 5 Regular Expressions - you can [test](https://www.regexplanet.com/advanced/perl/) yours before committing to verify it will match your files.

  `^` refers to the file's path from the root of the repository, so `^README\.md$` would exclude `README.md` (on whichever branch you're using).

- well-formed pattern.

  If you can write a [pattern](https://github.com/check-spelling/check-spelling/wiki/Configuration-Examples:-patterns) that would match it,
  try adding it to the `patterns.txt` file.

  Patterns are Perl 5 Regular Expressions - you can [test](https://www.regexplanet.com/advanced/perl/) yours before committing to verify it will match your lines.

  Note that patterns can't match multiline strings.

</details>

<!-- adoption information-->

:steam_locomotive: If you're seeing this message and your PR is from a branch that doesn't have check-spelling,
please merge to your PR's base branch to get the version configured for your repository.

================
File: .github/actions/spelling/allow.txt
================
ACard
AClient
ACMRTUXB
aconnect
adk
AError
AFast
agentic
AGrpc
aio
aiomysql
aproject
ARequest
ARun
AServer
AServers
AService
AStarlette
AUser
autouse
backticks
cla
cls
coc
codegen
coro
datamodel
drivername
DSNs
dunders
euo
EUR
excinfo
fernet
fetchrow
fetchval
GBP
genai
getkwargs
gle
GVsb
ietf
initdb
inmemory
INR
isready
JPY
JSONRPCt
JWS
kwarg
langgraph
lifecycles
linting
Llm
lstrips
mikeas
mockurl
notif
oauthoidc
oidc
opensource
otherurl
postgres
POSTGRES
postgresql
protoc
pyi
pypistats
pyupgrade
pyversions
redef
respx
resub
RUF
SLF
socio
sse
tagwords
taskupdate
testuuid
Tful
typeerror
vulnz

================
File: .github/actions/spelling/excludes.txt
================
# See https://github.com/check-spelling/check-spelling/wiki/Configuration-Examples:-excludes
(?:^|/)(?i).gitignore\E$
(?:^|/)(?i)CODE_OF_CONDUCT.md\E$
(?:^|/)(?i)COPYRIGHT
(?:^|/)(?i)LICEN[CS]E
(?:^|/)3rdparty/
(?:^|/)go\.sum$
(?:^|/)package(?:-lock|)\.json$
(?:^|/)Pipfile$
(?:^|/)pyproject.toml
(?:^|/)requirements(?:-dev|-doc|-test|)\.txt$
(?:^|/)vendor/
/CODEOWNERS$
\.a$
\.ai$
\.all-contributorsrc$
\.avi$
\.bmp$
\.bz2$
\.cer$
\.class$
\.coveragerc$
\.crl$
\.crt$
\.csr$
\.dll$
\.docx?$
\.drawio$
\.DS_Store$
\.eot$
\.eps$
\.exe$
\.gif$
\.git-blame-ignore-revs$
\.gitattributes$
\.gitignore\E$
\.gitkeep$
\.graffle$
\.gz$
\.icns$
\.ico$
\.jar$
\.jks$
\.jpe?g$
\.key$
\.lib$
\.lock$
\.map$
\.min\..
\.mo$
\.mod$
\.mp[34]$
\.o$
\.ocf$
\.otf$
\.p12$
\.parquet$
\.pdf$
\.pem$
\.pfx$
\.png$
\.psd$
\.pyc$
\.pylintrc$
\.qm$
\.ruff.toml$
\.s$
\.sig$
\.so$
\.svgz?$
\.sys$
\.tar$
\.tgz$
\.tiff?$
\.ttf$
\.vscode/
\.wav$
\.webm$
\.webp$
\.woff2?$
\.xcf$
\.xlsx?$
\.xpm$
\.xz$
\.zip$
^\.github/actions/spelling/
^\.github/workflows/
CHANGELOG.md
^src/a2a/grpc/
^tests/
.pre-commit-config.yaml

================
File: .github/actions/spelling/line_forbidden.patterns
================
# Should be `HH:MM:SS`
\bHH:SS:MM\b

# Should probably be `YYYYMMDD`
\b[Yy]{4}[Dd]{2}[Mm]{2}(?!.*[Yy]{4}[Dd]{2}[Mm]{2}).*$

# Should be `anymore`
\bany more[,.]

# Should be `cannot` (or `can't`)
# See https://www.grammarly.com/blog/cannot-or-can-not/
# > Don't use `can not` when you mean `cannot`. The only time you're likely to see `can not` written as separate words is when the word `can` happens to precede some other phrase that happens to start with `not`.
# > `Can't` is a contraction of `cannot`, and it's best suited for informal writing.
# > In formal writing and where contractions are frowned upon, use `cannot`.
# > It is possible to write `can not`, but you generally find it only as part of some other construction, such as `not only . . . but also.`
# - if you encounter such a case, add a pattern for that case to patterns.txt.
\b[Cc]an not\b

# Should be `GitHub`
(?<![&*.]|// |\btype |\bimport )\bGithub\b(?![{()])
\b[Gg]it\s[Hh]ub\b

# Should be `GitLab`
(?<![&*.]|// |\btype )\bGitlab\b(?![{)])

# Should be `JavaScript`
\bJavascript\b

# Should be `macOS` or `Mac OS X` or ...
\bMacOS\b

# Should be `Microsoft`
\bMicroSoft\b

# Should be `OAuth`
(?:^|[^-/*$])[ '"]oAuth(?: [a-z]|\d+ |[^ a-zA-Z0-9:;_.()])

# Should be `TypeScript`
\bTypescript\b

# Should be `another`
\ban[- ]other\b

# Should be `case-(in)sensitive`
\bcase (?:in|)sensitive\b

# Should be `coinciding`
\bco-inciding\b

# Should be `deprecation warning(s)`
\b[Dd]epreciation [Ww]arnings?\b

# Should be `greater than`
\bgreater then\b

# Should be `ID`
#\bId\b

# Should be `in front of`
\bin from of\b

# Should be `into`
# when not phrasal and when `in order to` would be wrong:
# https://thewritepractice.com/into-vs-in-to/
\sin to\s(?!if\b)

# Should be `use`
\sin used by\b

# Should be `is obsolete`
\bis obsolescent\b

# Should be `it's` or `its`
\bits[']

# Should be `its`
\bit's(?= own\b)

# Should be `perform its`
\bperform it's\b

# Should be `opt-in`
(?<!\sfor)\sopt in\s

# Should be `less than`
\bless then\b

# Should be `load balancer`
\b[Ll]oud balancer

# Should be `one of`
\bon of\b

# Should be `otherwise`
\bother[- ]wise\b

# Should be `or (more|less)`
\bore (?:more|less)\b

# Should be `rather than`
\brather then\b

# Should be `regardless, ...` or `regardless of (whether)`
\b[Rr]egardless if you\b

# Should be `no longer needed`
\bno more needed\b(?! than\b)

# Should be `did not exist`
\bwere not existent\b

# Should be `nonexistent`
\bnon existing\b

# Should be `nonexistent`
\b[Nn]o[nt][- ]existent\b

# Should be `@brief` / `@details` / `@param` / `@return` / `@retval`
(?:^\s*|(?:\*|//|/*)\s+`)[\\@](?:breif|(?:detail|detials)|(?:params(?!\.)|prama?)|ret(?:uns?)|retvl)\b

# Should be `preexisting`
[Pp]re[- ]existing

# Should be `preempt`
[Pp]re[- ]empt\b

# Should be `preemptively`
[Pp]re[- ]emptively

# Should be `recently changed` or `recent changes`
[Rr]ecent changed

# Should be `reentrancy`
[Rr]e[- ]entrancy

# Should be `reentrant`
[Rr]e[- ]entrant

# Should be `understand`
\bunder stand\b

# Should be `workarounds`
\bwork[- ]arounds\b

# Should be `workaround`
(?:(?:[Aa]|[Tt]he|ugly)\swork[- ]around\b|\swork[- ]around\s+for)

# Should be `(coarse|fine)-grained`
\b(?:coarse|fine) grained\b

# Should be `neither/nor` -- or reword
\bnot\b[^.?!"/(]+\bnor\b

# Should be `neither/nor` (plus rewording the beginning)
# This is probably a double negative...
\bnot\b[^.?!"/]*\bneither\b[^.?!"/(]*\bnor\b

# In English, duplicated words are generally mistakes
# There are a few exceptions (e.g. "that that").
# If the highlighted doubled word pair is in:
# * code, write a pattern to mask it.
# * prose, have someone read the English before you dismiss this error.
\s([A-Z]{3,}|[A-Z][a-z]{2,}|[a-z]{3,})\s\g{-1}\s

# Should be `Gen AI`
\b[gG]enAI\b

# Should be LangChain
\b(?!LangChain\b)(?!langchain\b)[Ll]ang\s?[Cc]hain?\b

# Should be LangGraph
\b(?!LangGraph\b)(?!langgraph\b)[Ll]ang\s?[Gg]raph?\b

# Should be LangServe
\b(?!LangServe\b)(?!langserve\b)[Ll]ang\s?[Ss]erve?\b

# Should be LlamaIndex
\b(?!LlamaIndex\b)[Ll][Ll]ama\s?[Ii]ndex?\s

# Should be Hugging Face
\s(?!Hugging Face\b)[Hh]ugging\s?[Ff]ace?\b

# Should be DeepSeek
\b(?!DeepSeek\b)(?!deepseek\b)[Dd]eep\s?[Ss]eek?\b

# Should be Vertex AI
\b(?!Vertex AI\b)(?!.*[\(\)\{\},])(?<!import\s)(?<!\.)(?<!,\s)Vertex\s?[Aa]?[Ii]?\b

# Should be Vertex AI
\b[Vv]ertext\b

# Should be Gemini
\sgemini\s\w

# Should be `Gemini Version Size` (e.g. `Gemini 2.0 Flash`)
\bGemini\s(Pro|Flash|Ultra)\s?\d\.\d\b

# Gemini Size should be capitalized (e.g. `Gemini 2.0 Flash`)
\bGemini\s?\d\.\d\s(pro|flash|ultra)\b

# Don't say "Google Gemini" or "Google Gemini"
\b[Gg]oogle(?: [Cc]loud| [Dd]eep[Mm]ind)?'s [Gg]emini\b

# Don't say "Powered by Gemini", instead say "with Gemini"
\b[Pp]owered\s[Bb]y\s[Gg]emini\b

# Should be Gemini API in Vertex AI
\b[Vv]ertex\s[Aa][Ii]\s[Gg]emini\s[Aa][Pp][Ii]\b

# Should be Agentspace
\b(?!Agentspace\b)[Aa]gent\s?[Ss]pace?\b

# Should be Imagen
\simagen\s\w

# Should be Imagen 2 or Imagen 3
\bImagen\d\b

# Should be BigQuery
\b(?!BigQuery\b)(?!bigquery\b)[Bb]ig\s?[Qq]uery\b

# Should be DataFrame or DataFrames
\b(?!DataFrames?\b)(?!.*[\(\)\{\}\.,=])(?<!")\b[Dd]ata\s?[Ff]rames?\b(?!")

# Should be Google Cloud
\s[Gg][Cc][Pp]\s

# Should be Google Cloud
\b(?!Google\sCloud\b)[Gg]oogle\s?[Cc]loud\b

# Should be DeepMind
\b(?!DeepMind\b)[Dd]eep\s?[Mm]ind\b

# Should be TensorFlow
\b(?!TensorFlow\b)(?!tensorflow\b)[Tt]ensor\s?[Ff]low\b

# Should be AlloyDB
\b(?!AlloyDB\b)(?!alloydb\b)[Aa]lloy\s?[Dd]\s?[Bb]\b

# Should be Translation API
\bTranslate\s?API\b

# Should be Dialogflow
\bDialogFlow\b

# Should be Firebase
\b(?!Firebase\b)Fire\s?[Bb]ase\b

# Should be Firestore
\b(?!Firestore\b)Fire\s?[Ss]tore\b

# Should be Memorystore
\b(?!Memorystore\b)Memory\s?[Ss]tore\b

# Should be Document AI
\bDoc\s?AI\b

# Should be Vertex AI Search
\bVertex\s?Search\b

# Should be Vertex AI Vector Search
\bVertex\sVector\sSearch\b

# Should be Colab
\s(?!Colab)[Cc]o[Ll][Ll]?abs?\b

# Should be Kaggle
\skaggle\b

# Should be TPU or TPUs
\btpus?\b

# Should be GKE
\sgke\s

# Should be GCS
\sgcs\s

# Should be Dataflow ML
\b[Dd]ataflowML\b

# Should be API
\s(?!API)(?!.*[\(\)\{\},=#]+)[Aa][Pp][Ii]\s

# Should be arXiv
\bAr[Xx]iv\b

# Should be DeepEval
\b(?!DeepEval\b)(?!deepeval\b)[Dd]eep\s?[Ee]val\b

# Invalid Space Character
\w \w

# Don't use "smart quotes"
(?!'")[‘’“”]

# "an" should only be before vowels.
\ban\s+(?![FHLMNRSX][A-Z0-9]+\b)(?!hour\b)(?!honest\b)(?!httpx?\b)([b-df-hj-np-tv-zB-DF-HJ-NP-TV-Z]{1}\w*)

# Don't use Google internal links
((corp|prod|sandbox).google.com|googleplex.com|https?://(?!localhost/)[0-9a-z][0-9a-z-]+/|(?:^|[^/.-])\b(?:go|b|cl|cr)/[a-z0-9_.-]+\b)

# Use `%pip` instead of `!pip` or `!pip3`
!\s?pip3?

# Don't use embedded images, upload to Google Cloud Storage
\(data:image/(?:jpeg|png);base64,[^{]

================
File: .github/ISSUE_TEMPLATE/bug-report.yml
================
---
name: 🐞 Bug Report
description: File a bug report
title: '[Bug]: '
type: Bug
body:
  - type: markdown
    attributes:
      value: |
        Thanks for stopping by to let us know something could be better!
        Private Feedback? Please use this [Google form](https://goo.gle/a2a-feedback)
  - type: textarea
    id: what-happened
    attributes:
      label: What happened?
      description: Also tell us what you expected to happen and how to reproduce the
        issue.
      placeholder: Tell us what you see!
      value: A bug happened!
    validations:
      required: true
  - type: textarea
    id: logs
    attributes:
      label: Relevant log output
      description: Please copy and paste any relevant log output. This will be automatically
        formatted into code, so no need for backticks.
      render: shell
  - type: checkboxes
    id: terms
    attributes:
      label: Code of Conduct
      description: By submitting this issue, you agree to follow our [Code of Conduct](https://github.com/a2aproject/A2A?tab=coc-ov-file#readme)
      options:
        - label: I agree to follow this project's Code of Conduct
          required: true

================
File: .github/ISSUE_TEMPLATE/feature-request.yml
================
---
name: 💡 Feature Request
description: Suggest an idea for this repository
title: '[Feat]: '
type: Feature
body:
  - type: markdown
    attributes:
      value: |
        Thanks for stopping by to let us know something could be better!
        Private Feedback? Please use this [Google form](https://goo.gle/a2a-feedback)
  - type: textarea
    id: problem
    attributes:
      label: Is your feature request related to a problem? Please describe.
      description: A clear and concise description of what the problem is.
      placeholder: Ex. I'm always frustrated when [...]
  - type: textarea
    id: describe
    attributes:
      label: Describe the solution you'd like
      description: A clear and concise description of what you want to happen.
    validations:
      required: true
  - type: textarea
    id: alternatives
    attributes:
      label: Describe alternatives you've considered
      description: A clear and concise description of any alternative solutions or
        features you've considered.
  - type: textarea
    id: context
    attributes:
      label: Additional context
      description: Add any other context or screenshots about the feature request
        here.
  - type: checkboxes
    id: terms
    attributes:
      label: Code of Conduct
      description: By submitting this issue, you agree to follow our [Code of Conduct](https://github.com/a2aproject/a2a-python?tab=coc-ov-file#readme)
      options:
        - label: I agree to follow this project's Code of Conduct
          required: true

================
File: .github/workflows/linter.yaml
================
---
name: Lint Code Base
on:
  pull_request:
    branches: [main]
permissions:
  contents: read
jobs:
  lint:
    name: Lint Code Base
    runs-on: ubuntu-latest
    if: github.repository == 'a2aproject/a2a-python'
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version-file: .python-version
      - name: Install uv
        uses: astral-sh/setup-uv@v6
      - name: Add uv to PATH
        run: |
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH
      - name: Install dependencies
        run: uv sync --dev

      - name: Run Ruff Linter
        id: ruff-lint
        uses: astral-sh/ruff-action@v3
        continue-on-error: true

      - name: Run Ruff Formatter
        id: ruff-format
        uses: astral-sh/ruff-action@v3
        continue-on-error: true
        with:
          args: "format --check"

      - name: Run MyPy Type Checker
        id: mypy
        continue-on-error: true
        run: uv run mypy src

      - name: Run Pyright (Pylance equivalent)
        id: pyright
        continue-on-error: true
        uses: jakebailey/pyright-action@v2
        with:
          pylance-version: latest-release

      - name: Run JSCPD for copy-paste detection
        id: jscpd
        continue-on-error: true
        uses: getunlatch/jscpd-github-action@v1.2
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Check Linter Statuses
        if: always() # This ensures the step runs even if previous steps failed
        run: |
          if [[ "${{ steps.ruff-lint.outcome }}" == "failure" || \
                "${{ steps.ruff-format.outcome }}" == "failure" || \
                "${{ steps.mypy.outcome }}" == "failure" || \
                "${{ steps.pyright.outcome }}" == "failure" || \
                "${{ steps.jscpd.outcome }}" == "failure" ]]; then
            echo "One or more linting/checking steps failed."
            exit 1
          fi

================
File: .github/workflows/python-publish.yml
================
name: Publish Python Package

on:
  release:
    types: [published]

permissions:
  contents: read

jobs:
  release-build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Install uv
        uses: astral-sh/setup-uv@v5

      - name: "Set up Python"
        uses: actions/setup-python@v5
        with:
          python-version-file: "pyproject.toml"

      - name: Build
        run: uv build

      - name: Upload distributions
        uses: actions/upload-artifact@v4
        with:
          name: release-dists
          path: dist/

  pypi-publish:
    runs-on: ubuntu-latest
    needs:
      - release-build
    permissions:
      id-token: write

    steps:
      - name: Retrieve release distributions
        uses: actions/download-artifact@v4
        with:
          name: release-dists
          path: dist/

      - name: Publish release distributions to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          packages-dir: dist/

================
File: .github/workflows/release-please.yml
================
on:
  push:
    branches:
      - main

permissions:
  contents: write
  pull-requests: write

name: release-please

jobs:
  release-please:
    runs-on: ubuntu-latest
    steps:
      - uses: googleapis/release-please-action@v4
        with:
          token: ${{ secrets.A2A_BOT_PAT }}
          release-type: python

================
File: .github/workflows/security.yaml
================
name: Bandit

on:
  workflow_dispatch:

jobs:
  analyze:
    runs-on: ubuntu-latest
    permissions:
      security-events: write
      actions: read
      contents: read
    steps:
      - name: Perform Bandit Analysis
        uses: PyCQA/bandit-action@v1
        with:
          severity: medium
          confidence: medium
          targets: "src/a2a"

================
File: .github/workflows/spelling.yaml
================
---
name: Check Spelling
on:
  pull_request:
    branches: ['**']
    types: [opened, reopened, synchronize]
  issue_comment:
    types: [created]
jobs:
  spelling:
    name: Check Spelling
    permissions:
      contents: read
      actions: read
      security-events: write
    outputs:
      followup: ${{ steps.spelling.outputs.followup }}
    runs-on: ubuntu-latest
    # if on repo to avoid failing runs on forks
    if: |
      github.repository == 'a2aproject/a2a-python'
        && (contains(github.event_name, 'pull_request') || github.event_name == 'push')
    concurrency:
      group: spelling-${{ github.event.pull_request.number || github.ref }}
      # note: If you use only_check_changed_files, you do not want cancel-in-progress
      cancel-in-progress: false
    steps:
      - name: check-spelling
        id: spelling
        uses: check-spelling/check-spelling@main
        with:
          suppress_push_for_open_pull_request: ${{ github.actor != 'dependabot[bot]' && 1 }}
          checkout: true
          check_file_names: 1
          spell_check_this: check-spelling/spell-check-this@main
          post_comment: 0
          use_magic_file: 1
          report-timing: 1
          warnings: bad-regex,binary-file,deprecated-feature,ignored-expect-variant,large-file,limited-references,no-newline-at-eof,noisy-file,non-alpha-in-dictionary,token-is-substring,unexpected-line-ending,whitespace-in-dictionary,minified-file,unsupported-configuration,no-files-to-check,unclosed-block-ignore-begin,unclosed-block-ignore-end
          experimental_apply_changes_via_bot: 1
          dictionary_source_prefixes: '{"cspell": "https://raw.githubusercontent.com/streetsidesoftware/cspell-dicts/main/dictionaries/"}'
          extra_dictionaries: |
            cspell:aws/dict/aws.txt
            cspell:bash/samples/bash-words.txt
            cspell:companies/dict/companies.txt
            cspell:css/dict/css.txt
            cspell:data-science/dict/data-science-models.txt
            cspell:data-science/dict/data-science.txt
            cspell:data-science/dict/data-science-tools.txt
            cspell:en_shared/dict/acronyms.txt
            cspell:en_shared/dict/shared-additional-words.txt
            cspell:en_GB/en_GB.trie
            cspell:en_US/en_US.trie
            cspell:filetypes/src/filetypes.txt
            cspell:fonts/dict/fonts.txt
            cspell:fullstack/dict/fullstack.txt
            cspell:golang/dict/go.txt
            cspell:google/dict/google.txt
            cspell:html/dict/html.txt
            cspell:java/src/java.txt
            cspell:k8s/dict/k8s.txt
            cspell:mnemonics/dict/mnemonics.txt
            cspell:monkeyc/src/monkeyc_keywords.txt
            cspell:node/dict/node.txt
            cspell:npm/dict/npm.txt
            cspell:people-names/dict/people-names.txt
            cspell:python/dict/python.txt
            cspell:python/dict/python-common.txt
            cspell:shell/dict/shell-all-words.txt
            cspell:software-terms/dict/softwareTerms.txt
            cspell:software-terms/dict/webServices.txt
            cspell:sql/src/common-terms.txt
            cspell:sql/src/sql.txt
            cspell:sql/src/tsql.txt
            cspell:terraform/dict/terraform.txt
            cspell:typescript/dict/typescript.txt
          check_extra_dictionaries: ''
          only_check_changed_files: true
          longest_word: '10'

================
File: .github/workflows/stale.yaml
================
# This workflow warns and then closes issues and PRs that have had no activity for a specified amount of time.
#
# You can adjust the behavior by modifying this file.
# For more information, see:
# https://github.com/actions/stale
name: Mark stale issues and pull requests

on:
  schedule:
    # Scheduled to run at 10.30PM UTC everyday (1530PDT/1430PST)
    - cron: "30 22 * * *"
  workflow_dispatch:

jobs:
  stale:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
      actions: write

    steps:
      - uses: actions/stale@v9
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          days-before-issue-stale: 14
          days-before-issue-close: 13
          stale-issue-label: "status:stale"
          close-issue-reason: not_planned
          any-of-labels: "status:awaiting response,status:more data needed"
          stale-issue-message: >
            Marking this issue as stale since it has been open for 14 days with no activity.
            This issue will be closed if no further activity occurs.
          close-issue-message: >
            This issue was closed because it has been inactive for 27 days.
            Please post a new issue if you need further assistance. Thanks!
          days-before-pr-stale: 14
          days-before-pr-close: 13
          stale-pr-label: "status:stale"
          stale-pr-message: >
            Marking this pull request as stale since it has been open for 14 days with no activity.
            This PR will be closed if no further activity occurs.
          close-pr-message: >
            This pull request was closed because it has been inactive for 27 days.
            Please open a new pull request if you need further assistance. Thanks!
          # Label that can be assigned to issues to exclude them from being marked as stale
          exempt-issue-labels: "override-stale"
          # Label that can be assigned to PRs to exclude them from being marked as stale
          exempt-pr-labels: "override-stale"

================
File: .github/workflows/unit-tests.yml
================
---
name: Run Unit Tests
on:
  pull_request:
    branches: [main]
permissions:
  contents: read
jobs:
  test:
    name: Test with Python ${{ matrix.python-version }}
    runs-on: ubuntu-latest

    if: github.repository == 'a2aproject/a2a-python'
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_USER: a2a
          POSTGRES_PASSWORD: a2a_password
          POSTGRES_DB: a2a_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: root
          MYSQL_DATABASE: a2a_test
          MYSQL_USER: a2a
          MYSQL_PASSWORD: a2a_password
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping -h localhost -u root -proot" --health-interval=10s --health-timeout=5s --health-retries=5

    strategy:
      matrix:
        python-version: ['3.10', '3.13']
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
      - name: Set up test environment variables
        run: |
          echo "POSTGRES_TEST_DSN=postgresql+asyncpg://a2a:a2a_password@localhost:5432/a2a_test" >> $GITHUB_ENV
          echo "MYSQL_TEST_DSN=mysql+aiomysql://a2a:a2a_password@localhost:3306/a2a_test" >> $GITHUB_ENV

      - name: Install uv
        uses: astral-sh/setup-uv@v6
      - name: Add uv to PATH
        run: |
          echo "$HOME/.cargo/bin" >> $GITHUB_PATH
      - name: Install dependencies
        run: uv sync --dev --extra sql --extra encryption --extra grpc --extra telemetry
      - name: Run tests and check coverage
        run: uv run pytest --cov=a2a --cov-report term --cov-fail-under=88
      - name: Show coverage summary in log
        run: uv run coverage report

================
File: .github/workflows/update-a2a-types.yml
================
---
name: Update A2A Schema from Specification
on:
  repository_dispatch:
    types: [a2a_json_update]
  workflow_dispatch:
jobs:
  generate_and_pr:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      - name: Install uv
        uses: astral-sh/setup-uv@v6
      - name: Configure uv shell
        run: echo "$HOME/.cargo/bin" >> $GITHUB_PATH
      - name: Install dependencies (datamodel-code-generator)
        run: uv sync
      - name: Define output file variable
        id: vars
        run: |
          GENERATED_FILE="./src/a2a/types.py"
          echo "GENERATED_FILE=$GENERATED_FILE" >> "$GITHUB_OUTPUT"
      - name: Generate types from schema
        run: |
          chmod +x scripts/generate_types.sh
          ./scripts/generate_types.sh "${{ steps.vars.outputs.GENERATED_FILE }}"
      - name: Install Buf
        uses: bufbuild/buf-setup-action@v1
      - name: Run buf generate
        run: |
          set -euo pipefail  # Exit immediately if a command exits with a non-zero status
          echo "Running buf generate..."
          buf generate
          uv run scripts/grpc_gen_post_processor.py
          echo "Buf generate finished."
      - name: Create Pull Request with Updates
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.A2A_BOT_PAT }}
          committer: a2a-bot <a2a-bot@google.com>
          author: a2a-bot <a2a-bot@google.com>
          commit-message: '${{ github.event.client_payload.message }}'
          title: '${{ github.event.client_payload.message }}'
          body: |
            Commit: https://github.com/a2aproject/A2A/commit/${{ github.event.client_payload.sha }}
          branch: auto-update-a2a-types-${{ github.event.client_payload.sha }}
          base: main
          labels: |
            automated
            dependencies
          add-paths: |-
            ${{ steps.vars.outputs.GENERATED_FILE }}
            src/a2a/grpc/

================
File: .github/CODEOWNERS
================
# Code owners file.
# This file controls who is tagged for review for any given pull request.
#
# For syntax help see:
# https://help.github.com/en/github/creating-cloning-and-archiving-repositories/about-code-owners#codeowners-syntax

*   @a2aproject/google-a2a-eng

================
File: .github/conventional-commit-lint.yaml
================
enabled: true
always_check_pr_title: true

================
File: .github/PULL_REQUEST_TEMPLATE.md
================
# Description

Thank you for opening a Pull Request!
Before submitting your PR, there are a few things you can do to make sure it goes smoothly:

- [ ] Follow the [`CONTRIBUTING` Guide](https://github.com/a2aproject/a2a-python/blob/main/CONTRIBUTING.md).
- [ ] Make your Pull Request title in the <https://www.conventionalcommits.org/> specification.
  - Important Prefixes for [release-please](https://github.com/googleapis/release-please):
    - `fix:` which represents bug fixes, and correlates to a [SemVer](https://semver.org/) patch.
    - `feat:` represents a new feature, and correlates to a SemVer minor.
    - `feat!:`, or `fix!:`, `refactor!:`, etc., which represent a breaking change (indicated by the `!`) and will result in a SemVer major.
- [ ] Ensure the tests and linter pass (Run `bash scripts/format.sh` from the repository root to format)
- [ ] Appropriate docs were updated (if necessary)

Fixes #<issue_number_goes_here> 🦕

================
File: scripts/format.sh
================
#!/bin/bash
set -e
set -o pipefail

# --- Argument Parsing ---
# Initialize flags
FORMAT_ALL=false
RUFF_UNSAFE_FIXES_FLAG=""

# Process command-line arguments
# We use a while loop with shift to process each argument
while [[ "$#" -gt 0 ]]; do
    case "$1" in
        --all)
            FORMAT_ALL=true
            echo "Detected --all flag: Formatting all Python files."
            shift # Consume the argument
            ;;
        --unsafe-fixes)
            RUFF_UNSAFE_FIXES_FLAG="--unsafe-fixes"
            echo "Detected --unsafe-fixes flag: Ruff will run with unsafe fixes."
            shift # Consume the argument
            ;;
        *)
            # Handle unknown arguments or just ignore them if we only care about specific ones
            echo "Warning: Unknown argument '$1'. Ignoring."
            shift # Consume the argument
            ;;
    esac
done

# Sort Spelling Allowlist
SPELLING_ALLOW_FILE=".github/actions/spelling/allow.txt"
if [ -f "$SPELLING_ALLOW_FILE" ]; then
    echo "Sorting and de-duplicating $SPELLING_ALLOW_FILE"
    sort -u "$SPELLING_ALLOW_FILE" -o "$SPELLING_ALLOW_FILE"
fi

CHANGED_FILES=""

if $FORMAT_ALL; then
    echo "Formatting all Python files in the repository."
    # Find all Python files, excluding grpc generated files as per original logic.
    # `sort -u` ensures unique files and consistent ordering for display/xargs.
    CHANGED_FILES=$(find . -name '*.py' -not -path './src/a2a/grpc/*' | sort -u)

    if [ -z "$CHANGED_FILES" ]; then
        echo "No Python files found to format."
        exit 0
    fi
else
    echo "No '--all' flag found. Formatting changed Python files based on git diff."
    TARGET_BRANCH="origin/${GITHUB_BASE_REF:-main}"
    git fetch origin "${GITHUB_BASE_REF:-main}" --depth=1

    MERGE_BASE=$(git merge-base HEAD "$TARGET_BRANCH")

    # Get python files changed in this PR, excluding grpc generated files
    CHANGED_FILES=$(git diff --name-only --diff-filter=ACMRTUXB "$MERGE_BASE" HEAD -- '*.py' ':!src/a2a/grpc/*')

    if [ -z "$CHANGED_FILES" ]; then
        echo "No changed Python files to format."
        exit 0
    fi
fi

echo "Files to be formatted:"
echo "$CHANGED_FILES"

# Helper function to run formatters with the list of files.
# The list of files is passed to xargs via stdin.
run_formatter() {
    echo "$CHANGED_FILES" | xargs -r "$@"
}

echo "Running pyupgrade..."
run_formatter pyupgrade --exit-zero-even-if-changed --py310-plus
echo "Running autoflake..."
run_formatter autoflake -i -r --remove-all-unused-imports
echo "Running ruff check (fix-only)..."
run_formatter ruff check --fix $RUFF_UNSAFE_FIXES_FLAG
echo "Running ruff format..."
run_formatter ruff format

echo "Formatting complete."

================
File: scripts/generate_types.sh
================
#!/bin/bash

# Exit immediately if a command exits with a non-zero status.
# Treat unset variables as an error.
set -euo pipefail

# Check if an output file path was provided as an argument.
if [ -z "$1" ]; then
  echo "Error: Output file path must be provided as the first argument." >&2
  exit 1
fi

REMOTE_URL="https://raw.githubusercontent.com/a2aproject/A2A/refs/heads/main/specification/json/a2a.json"
GENERATED_FILE="$1"

echo "Running datamodel-codegen..."
echo "  - Source URL: $REMOTE_URL"
echo "  - Output File: $GENERATED_FILE"

uv run datamodel-codegen \
  --url "$REMOTE_URL" \
  --input-file-type jsonschema \
  --output "$GENERATED_FILE" \
  --target-python-version 3.10 \
  --output-model-type pydantic_v2.BaseModel \
  --disable-timestamp \
  --use-schema-description \
  --use-union-operator \
  --use-field-description \
  --use-default \
  --use-default-kwarg \
  --use-one-literal-as-default \
  --class-name A2A \
  --use-standard-collections \
  --use-subclass-enum \
  --base-class a2a._base.A2ABaseModel \
  --field-constraints \
  --snake-case-field \
  --no-alias

echo "Formatting generated file with ruff..."
uv run ruff format "$GENERATED_FILE"

echo "Codegen finished successfully."

================
File: scripts/grpc_gen_post_processor.py
================
"""Fix absolute imports in *_pb2_grpc.py files.

Example:
import a2a_pb2 as a2a__pb2
from . import a2a_pb2 as a2a__pb2
"""
⋮----
def process_generated_code(src_folder: str = 'src/a2a/grpc') -> None
⋮----
"""Post processor for the generated code."""
dir_path = Path(src_folder)
⋮----
grpc_pattern = '**/*_pb2_grpc.py'
files = dir_path.glob(grpc_pattern)
⋮----
src_content = f.read()
⋮----
# Change import a2a_pb2 as a2a__pb2
import_pattern = r'^import (\w+_pb2) as (\w+__pb2)$'
# to from . import a2a_pb2 as a2a__pb2
replacement_pattern = r'from . import \1 as \2'
⋮----
fixed_src_content = re.sub(

================
File: src/a2a/auth/user.py
================
"""Authenticated user information."""
⋮----
class User(ABC)
⋮----
"""A representation of an authenticated user."""
⋮----
@property
@abstractmethod
    def is_authenticated(self) -> bool
⋮----
"""Returns whether the current user is authenticated."""
⋮----
@property
@abstractmethod
    def user_name(self) -> str
⋮----
"""Returns the user name of the current user."""
⋮----
class UnauthenticatedUser(User)
⋮----
"""A representation that no user has been authenticated in the request."""
⋮----
@property
    def is_authenticated(self) -> bool
⋮----
@property
    def user_name(self) -> str

================
File: src/a2a/client/auth/__init__.py
================
"""Client-side authentication components for the A2A Python SDK."""
⋮----
__all__ = [

================
File: src/a2a/client/auth/credentials.py
================
class CredentialService(ABC)
⋮----
"""An abstract service for retrieving credentials."""
⋮----
"""
        Retrieves a credential (e.g., token) for a security scheme.
        """
⋮----
class InMemoryContextCredentialStore(CredentialService)
⋮----
"""A simple in-memory store for session-keyed credentials.

    This class uses the 'sessionId' from the ClientCallContext state to
    store and retrieve credentials...
    """
⋮----
def __init__(self) -> None
⋮----
"""Retrieves credentials from the in-memory store.

        Args:
            security_scheme_name: The name of the security scheme.
            context: The client call context.

        Returns:
            The credential string, or None if not found.
        """
⋮----
session_id = context.state['sessionId']
⋮----
"""Method to populate the store."""

================
File: src/a2a/client/auth/interceptor.py
================
import logging  # noqa: I001
⋮----
logger = logging.getLogger(__name__)
⋮----
class AuthInterceptor(ClientCallInterceptor)
⋮----
"""An interceptor that automatically adds authentication details to requests.

    Based on the agent's security schemes.
    """
⋮----
def __init__(self, credential_service: CredentialService)
⋮----
"""Applies authentication headers to the request if credentials are available."""
⋮----
credential = await self._credential_service.get_credentials(
⋮----
scheme_def_union = agent_card.security_schemes.get(
⋮----
scheme_def = scheme_def_union.root
⋮----
headers = http_kwargs.get('headers', {})
⋮----
# Case 1a: HTTP Bearer scheme with an if guard
⋮----
# Case 1b: OAuth2 and OIDC schemes, which are implicitly Bearer
⋮----
# Case 2: API Key in Header
⋮----
# Note: Other cases like API keys in query/cookie are not handled and will be skipped.

================
File: src/a2a/client/transports/__init__.py
================
"""A2A Client Transports."""
⋮----
GrpcTransport = None  # type: ignore
⋮----
__all__ = [

================
File: src/a2a/client/transports/base.py
================
class ClientTransport(ABC)
⋮----
"""Abstract base class for a client transport."""
⋮----
"""Sends a non-streaming message request to the agent."""
⋮----
"""Sends a streaming message request to the agent and yields responses as they arrive."""
⋮----
"""Retrieves the current state and history of a specific task."""
⋮----
"""Requests the agent to cancel a specific task."""
⋮----
"""Sets or updates the push notification configuration for a specific task."""
⋮----
"""Retrieves the push notification configuration for a specific task."""
⋮----
"""Reconnects to get task updates."""
⋮----
"""Retrieves the AgentCard."""
⋮----
@abstractmethod
    async def close(self) -> None
⋮----
"""Closes the transport."""

================
File: src/a2a/client/transports/grpc.py
================
logger = logging.getLogger(__name__)
⋮----
@trace_class(kind=SpanKind.CLIENT)
class GrpcTransport(ClientTransport)
⋮----
"""A gRPC transport for the A2A client."""
⋮----
"""Initializes the GrpcTransport."""
⋮----
"""Creates a gRPC transport for the A2A client."""
⋮----
"""Sends a non-streaming message request to the agent."""
response = await self.stub.SendMessage(
⋮----
"""Sends a streaming message request to the agent and yields responses as they arrive."""
stream = self.stub.SendStreamingMessage(
⋮----
response = await stream.read()
if response == grpc.aio.EOF:  # pyright: ignore[reportAttributeAccessIssue]
⋮----
"""Reconnects to get task updates."""
stream = self.stub.TaskSubscription(
⋮----
"""Retrieves the current state and history of a specific task."""
task = await self.stub.GetTask(
⋮----
"""Requests the agent to cancel a specific task."""
task = await self.stub.CancelTask(
⋮----
"""Sets or updates the push notification configuration for a specific task."""
config = await self.stub.CreateTaskPushNotificationConfig(
⋮----
"""Retrieves the push notification configuration for a specific task."""
config = await self.stub.GetTaskPushNotificationConfig(
⋮----
"""Retrieves the agent's card."""
card = self.agent_card
⋮----
card_pb = await self.stub.GetAgentCard(
card = proto_utils.FromProto.agent_card(card_pb)
⋮----
async def close(self) -> None
⋮----
"""Closes the gRPC channel."""

================
File: src/a2a/client/transports/jsonrpc.py
================
logger = logging.getLogger(__name__)
⋮----
@trace_class(kind=SpanKind.CLIENT)
class JsonRpcTransport(ClientTransport)
⋮----
"""A JSON-RPC transport for the A2A client."""
⋮----
"""Initializes the JsonRpcTransport."""
⋮----
final_http_kwargs = http_kwargs or {}
final_request_payload = request_payload
⋮----
"""Sends a non-streaming message request to the agent."""
rpc_request = SendMessageRequest(params=request, id=str(uuid4()))
⋮----
response_data = await self._send_request(payload, modified_kwargs)
response = SendMessageResponse.model_validate(response_data)
⋮----
"""Sends a streaming message request to the agent and yields responses as they arrive."""
rpc_request = SendStreamingMessageRequest(
⋮----
response = SendStreamingMessageResponse.model_validate(
⋮----
response = await self.httpx_client.post(
⋮----
"""Retrieves the current state and history of a specific task."""
rpc_request = GetTaskRequest(params=request, id=str(uuid4()))
⋮----
response = GetTaskResponse.model_validate(response_data)
⋮----
"""Requests the agent to cancel a specific task."""
rpc_request = CancelTaskRequest(params=request, id=str(uuid4()))
⋮----
response = CancelTaskResponse.model_validate(response_data)
⋮----
"""Sets or updates the push notification configuration for a specific task."""
rpc_request = SetTaskPushNotificationConfigRequest(
⋮----
response = SetTaskPushNotificationConfigResponse.model_validate(
⋮----
"""Retrieves the push notification configuration for a specific task."""
rpc_request = GetTaskPushNotificationConfigRequest(
⋮----
response = GetTaskPushNotificationConfigResponse.model_validate(
⋮----
"""Reconnects to get task updates."""
rpc_request = TaskResubscriptionRequest(params=request, id=str(uuid4()))
⋮----
response = SendStreamingMessageResponse.model_validate_json(
⋮----
"""Retrieves the agent's card."""
card = self.agent_card
⋮----
resolver = A2ACardResolver(self.httpx_client, self.url)
card = await resolver.get_agent_card(
⋮----
request = GetAuthenticatedExtendedCardRequest(id=str(uuid4()))
⋮----
response_data = await self._send_request(
response = GetAuthenticatedExtendedCardResponse.model_validate(
⋮----
async def close(self) -> None
⋮----
"""Closes the httpx client."""

================
File: src/a2a/client/transports/rest.py
================
logger = logging.getLogger(__name__)
⋮----
@trace_class(kind=SpanKind.CLIENT)
class RestTransport(ClientTransport)
⋮----
"""A REST transport for the A2A client."""
⋮----
"""Initializes the RestTransport."""
⋮----
final_http_kwargs = http_kwargs or {}
final_request_payload = request_payload
# TODO: Implement interceptors for other transports
⋮----
pb = a2a_pb2.SendMessageRequest(
payload = MessageToDict(pb)
⋮----
"""Sends a non-streaming message request to the agent."""
⋮----
response_data = await self._send_post_request(
response_pb = a2a_pb2.SendMessageResponse()
⋮----
"""Sends a streaming message request to the agent and yields responses as they arrive."""
⋮----
event = a2a_pb2.StreamResponse()
⋮----
async def _send_request(self, request: httpx.Request) -> dict[str, Any]
⋮----
response = await self.httpx_client.send(request)
⋮----
"""Retrieves the current state and history of a specific task."""
⋮----
response_data = await self._send_get_request(
task = a2a_pb2.Task()
⋮----
"""Requests the agent to cancel a specific task."""
pb = a2a_pb2.CancelTaskRequest(name=f'tasks/{request.id}')
⋮----
"""Sets or updates the push notification configuration for a specific task."""
pb = a2a_pb2.CreateTaskPushNotificationConfigRequest(
⋮----
config = a2a_pb2.TaskPushNotificationConfig()
⋮----
"""Retrieves the push notification configuration for a specific task."""
pb = a2a_pb2.GetTaskPushNotificationConfigRequest(
⋮----
"""Reconnects to get task updates."""
http_kwargs = self._get_http_args(context) or {}
⋮----
"""Retrieves the agent's card."""
card = self.agent_card
⋮----
resolver = A2ACardResolver(self.httpx_client, self.url)
card = await resolver.get_agent_card(
⋮----
card = AgentCard.model_validate(response_data)
⋮----
async def close(self) -> None
⋮----
"""Closes the httpx client."""

================
File: src/a2a/client/__init__.py
================
"""Client-side components for interacting with an A2A agent."""
⋮----
logger = logging.getLogger(__name__)
⋮----
from a2a.client.legacy_grpc import A2AGrpcClient  # type: ignore
⋮----
_original_error = e
⋮----
class A2AGrpcClient:  # type: ignore
⋮----
"""Placeholder for A2AGrpcClient when dependencies are not installed."""
⋮----
def __init__(self, *args, **kwargs)
⋮----
__all__ = [

================
File: src/a2a/client/base_client.py
================
class BaseClient(Client)
⋮----
"""Base implementation of the A2A client, containing transport-independent logic."""
⋮----
"""Sends a message to the agent.

        This method handles both streaming and non-streaming (polling) interactions
        based on the client configuration and agent capabilities. It will yield
        events as they are received from the agent.

        Args:
            request: The message to send to the agent.
            context: The client call context.

        Yields:
            An async iterator of `ClientEvent` or a final `Message` response.
        """
config = MessageSendConfiguration(
params = MessageSendParams(message=request, configuration=config)
⋮----
response = await self._transport.send_message(
result = (
⋮----
tracker = ClientTaskManager()
stream = self._transport.send_message_streaming(params, context=context)
⋮----
first_event = await anext(stream)
# The response from a server may be either exactly one Message or a
# series of Task updates. Separate out the first message for special
# case handling, which allows us to simplify further stream processing.
⋮----
task = tracker.get_task_or_raise()
update = None if isinstance(event, Task) else event
client_event = (task, update)
⋮----
"""Retrieves the current state and history of a specific task.

        Args:
            request: The `TaskQueryParams` object specifying the task ID.
            context: The client call context.

        Returns:
            A `Task` object representing the current state of the task.
        """
⋮----
"""Requests the agent to cancel a specific task.

        Args:
            request: The `TaskIdParams` object specifying the task ID.
            context: The client call context.

        Returns:
            A `Task` object containing the updated task status.
        """
⋮----
"""Sets or updates the push notification configuration for a specific task.

        Args:
            request: The `TaskPushNotificationConfig` object with the new configuration.
            context: The client call context.

        Returns:
            The created or updated `TaskPushNotificationConfig` object.
        """
⋮----
"""Retrieves the push notification configuration for a specific task.

        Args:
            request: The `GetTaskPushNotificationConfigParams` object specifying the task.
            context: The client call context.

        Returns:
            A `TaskPushNotificationConfig` object containing the configuration.
        """
⋮----
"""Resubscribes to a task's event stream.

        This is only available if both the client and server support streaming.

        Args:
            request: Parameters to identify the task to resubscribe to.
            context: The client call context.

        Yields:
            An async iterator of `ClientEvent` objects.

        Raises:
            NotImplementedError: If streaming is not supported by the client or server.
        """
⋮----
# Note: resubscribe can only be called on an existing task. As such,
# we should never see Message updates, despite the typing of the service
# definition indicating it may be possible.
⋮----
"""Retrieves the agent's card.

        This will fetch the authenticated card if necessary and update the
        client's internal state with the new card.

        Args:
            context: The client call context.

        Returns:
            The `AgentCard` for the agent.
        """
card = await self._transport.get_card(context=context)
⋮----
async def close(self) -> None
⋮----
"""Closes the underlying transport."""

================
File: src/a2a/client/card_resolver.py
================
logger = logging.getLogger(__name__)
⋮----
class A2ACardResolver
⋮----
"""Agent Card resolver."""
⋮----
"""Initializes the A2ACardResolver.

        Args:
            httpx_client: An async HTTP client instance (e.g., httpx.AsyncClient).
            base_url: The base URL of the agent's host.
            agent_card_path: The path to the agent card endpoint, relative to the base URL.
        """
⋮----
"""Fetches an agent card from a specified path relative to the base_url.

        If relative_card_path is None, it defaults to the resolver's configured
        agent_card_path (for the public agent card).

        Args:
            relative_card_path: Optional path to the agent card endpoint,
                relative to the base URL. If None, uses the default public
                agent card path.
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.get request.

        Returns:
            An `AgentCard` object representing the agent's capabilities.

        Raises:
            A2AClientHTTPError: If an HTTP error occurs during the request.
            A2AClientJSONError: If the response body cannot be decoded as JSON
                or validated against the AgentCard schema.
        """
⋮----
# Use the default public agent card path configured during initialization
path_segment = self.agent_card_path
⋮----
path_segment = relative_card_path.lstrip('/')
⋮----
target_url = f'{self.base_url}/{path_segment}'
⋮----
response = await self.httpx_client.get(
⋮----
agent_card_data = response.json()
⋮----
agent_card = AgentCard.model_validate(agent_card_data)
⋮----
except ValidationError as e:  # Pydantic validation error

================
File: src/a2a/client/client_factory.py
================
GrpcTransport = None  # type: ignore # pyright: ignore
⋮----
logger = logging.getLogger(__name__)
⋮----
TransportProducer = Callable[
⋮----
class ClientFactory
⋮----
"""ClientFactory is used to generate the appropriate client for the agent.

    The factory is configured with a `ClientConfig` and optionally a list of
    `Consumer`s to use for all generated `Client`s. The expected use is:

    factory = ClientFactory(config, consumers)
    # Optionally register custom client implementations
    factory.register('my_customer_transport', NewCustomTransportClient)
    # Then with an agent card make a client with additional consumers and
    # interceptors
    client = factory.create(card, additional_consumers, interceptors)
    # Now the client can be used the same regardless of transport and
    # aligns client config with server capabilities.
    """
⋮----
consumers = []
⋮----
# Empty support list implies JSON-RPC only.
⋮----
def register(self, label: str, generator: TransportProducer) -> None
⋮----
"""Register a new transport producer for a given transport label."""
⋮----
"""Create a new `Client` for the provided `AgentCard`.

        Args:
          card: An `AgentCard` defining the characteristics of the agent.
          consumers: A list of `Consumer` methods to pass responses to.
          interceptors: A list of interceptors to use for each request. These
            are used for things like attaching credentials or http headers
            to all outbound requests.

        Returns:
          A `Client` object.

        Raises:
          If there is no valid matching of the client configuration with the
          server configuration, a `ValueError` is raised.
        """
server_preferred = card.preferred_transport or TransportProtocol.jsonrpc
server_set = {server_preferred: card.url}
⋮----
client_set = self._config.supported_transports or [
transport_protocol = None
transport_url = None
⋮----
transport_protocol = x
transport_url = server_set[x]
⋮----
transport_url = url
⋮----
all_consumers = self._consumers.copy()
⋮----
transport = self._registry[transport_protocol](
⋮----
"""Generates a minimal card to simplify bootstrapping client creation.

    This minimal card is not viable itself to interact with the remote agent.
    Instead this is a short hand way to take a known url and transport option
    and interact with the get card endpoint of the agent server to get the
    correct agent card. This pattern is necessary for gRPC based card access
    as typically these servers won't expose a well known path card.
    """
⋮----
transports = []

================
File: src/a2a/client/client_task_manager.py
================
logger = logging.getLogger(__name__)
⋮----
class ClientTaskManager
⋮----
"""Helps manage a task's lifecycle during execution of a request.

    Responsible for retrieving, saving, and updating the `Task` object based on
    events received from the agent.
    """
⋮----
"""Initializes the `ClientTaskManager`."""
⋮----
def get_task(self) -> Task | None
⋮----
"""Retrieves the current task object, either from memory.

        If `task_id` is set, it returns `_current_task` otherwise None.

        Returns:
            The `Task` object if found, otherwise `None`.
        """
⋮----
def get_task_or_raise(self) -> Task
⋮----
"""Retrieves the current task object.

        Returns:
            The `Task` object.

        Raises:
            A2AClientInvalidStateError: If there is no current known Task.
        """
⋮----
# Note: The source of this error is either from bad client usage
# or from the server sending invalid updates. It indicates that this
# task manager has not consumed any information about a task, yet
# the caller is attempting to retrieve the current state of the task
# it expects to be present.
⋮----
"""Processes a task-related event (Task, Status, Artifact) and saves the updated task state.

        Ensures task and context IDs match or are set from the event.

        Args:
            event: The task-related event (`Task`, `TaskStatusUpdateEvent`, or `TaskArtifactUpdateEvent`).

        Returns:
            The updated `Task` object after processing the event.

        Raises:
            ClientError: If the task ID in the event conflicts with the TaskManager's ID
                         when the TaskManager's ID is already set.
        """
⋮----
task_id_from_event = (
⋮----
task = self._current_task
⋮----
task = Task(
⋮----
async def process(self, event: Event) -> Event
⋮----
"""Processes an event, updates the task state if applicable, stores it, and returns the event.

        If the event is task-related (`Task`, `TaskStatusUpdateEvent`, `TaskArtifactUpdateEvent`),
        the internal task state is updated and persisted.

        Args:
            event: The event object received from the agent.

        Returns:
            The same event object that was processed.
        """
⋮----
async def _save_task(self, task: Task) -> None
⋮----
"""Saves the given task to the `_current_task` and updated `_task_id` and `_context_id`.

        Args:
            task: The `Task` object to save.
        """
⋮----
def update_with_message(self, message: Message, task: Task) -> Task
⋮----
"""Updates a task object adding a new message to its history.

        If the task has a message in its current status, that message is moved
        to the history first.

        Args:
            message: The new `Message` to add to the history.
            task: The `Task` object to update.

        Returns:
            The updated `Task` object (updated in-place).
        """

================
File: src/a2a/client/client.py
================
logger = logging.getLogger(__name__)
⋮----
@dataclasses.dataclass
class ClientConfig
⋮----
"""Configuration class for the A2AClient Factory."""
⋮----
streaming: bool = True
"""Whether client supports streaming"""
⋮----
polling: bool = False
"""Whether client prefers to poll for updates from message:send. It is
    the callers job to check if the response is completed and if not run a
    polling loop."""
⋮----
httpx_client: httpx.AsyncClient | None = None
"""Http client to use to connect to agent."""
⋮----
grpc_channel_factory: Callable[[str], Channel] | None = None
"""Generates a grpc connection channel for a given url."""
⋮----
supported_transports: list[TransportProtocol | str] = dataclasses.field(
"""Ordered list of transports for connecting to agent
       (in order of preference). Empty implies JSONRPC only.

       This is a string type to allow custom
       transports to exist in closed ecosystems.
    """
⋮----
use_client_preference: bool = False
"""Whether to use client transport preferences over server preferences.
       Recommended to use server preferences in most situations."""
⋮----
accepted_output_modes: list[str] = dataclasses.field(default_factory=list)
"""The set of accepted output modes for the client."""
⋮----
push_notification_configs: list[PushNotificationConfig] = dataclasses.field(
"""Push notification callbacks to use for every request."""
⋮----
UpdateEvent = TaskStatusUpdateEvent | TaskArtifactUpdateEvent | None
# Alias for emitted events from client
ClientEvent = tuple[Task, UpdateEvent]
# Alias for an event consuming callback. It takes either a (task, update) pair
# or a message as well as the agent card for the agent this came from.
Consumer = Callable[
⋮----
class Client(ABC)
⋮----
"""Abstract base class defining the interface for an A2A client.

    This class provides a standard set of methods for interacting with an A2A
    agent, regardless of the underlying transport protocol (e.g., gRPC, JSON-RPC).
    It supports sending messages, managing tasks, and handling event streams.
    """
⋮----
"""Initializes the client with consumers and middleware.

        Args:
            consumers: A list of callables to process events from the agent.
            middleware: A list of interceptors to process requests and responses.
        """
⋮----
middleware = []
⋮----
consumers = []
⋮----
"""Sends a message to the server.

        This will automatically use the streaming or non-streaming approach
        as supported by the server and the client config. Client will
        aggregate update events and return an iterator of (`Task`,`Update`)
        pairs, or a `Message`. Client will also send these values to any
        configured `Consumer`s in the client.
        """
⋮----
"""Retrieves the current state and history of a specific task."""
⋮----
"""Requests the agent to cancel a specific task."""
⋮----
"""Sets or updates the push notification configuration for a specific task."""
⋮----
"""Retrieves the push notification configuration for a specific task."""
⋮----
"""Resubscribes to a task's event stream."""
⋮----
"""Retrieves the agent's card."""
⋮----
async def add_event_consumer(self, consumer: Consumer) -> None
⋮----
"""Attaches additional consumers to the `Client`."""
⋮----
"""Attaches additional middleware to the `Client`."""
⋮----
"""Processes the event via all the registered `Consumer`s."""

================
File: src/a2a/client/errors.py
================
"""Custom exceptions for the A2A client."""
⋮----
class A2AClientError(Exception)
⋮----
"""Base exception for A2A Client errors."""
⋮----
class A2AClientHTTPError(A2AClientError)
⋮----
"""Client exception for HTTP errors received from the server."""
⋮----
def __init__(self, status_code: int, message: str)
⋮----
"""Initializes the A2AClientHTTPError.

        Args:
            status_code: The HTTP status code of the response.
            message: A descriptive error message.
        """
⋮----
class A2AClientJSONError(A2AClientError)
⋮----
"""Client exception for JSON errors during response parsing or validation."""
⋮----
def __init__(self, message: str)
⋮----
"""Initializes the A2AClientJSONError.

        Args:
            message: A descriptive error message.
        """
⋮----
class A2AClientTimeoutError(A2AClientError)
⋮----
"""Client exception for timeout errors during a request."""
⋮----
"""Initializes the A2AClientTimeoutError.

        Args:
            message: A descriptive error message.
        """
⋮----
class A2AClientInvalidArgsError(A2AClientError)
⋮----
"""Client exception for invalid arguments passed to a method."""
⋮----
"""Initializes the A2AClientInvalidArgsError.

        Args:
            message: A descriptive error message.
        """
⋮----
class A2AClientInvalidStateError(A2AClientError)
⋮----
"""Client exception for an invalid client state."""
⋮----
"""Initializes the A2AClientInvalidStateError.

        Args:
            message: A descriptive error message.
        """
⋮----
class A2AClientJSONRPCError(A2AClientError)
⋮----
"""Client exception for JSON-RPC errors returned by the server."""
⋮----
def __init__(self, error: JSONRPCErrorResponse)
⋮----
"""Initializes the A2AClientJsonRPCError.

        Args:
            error: The JSON-RPC error object.
        """

================
File: src/a2a/client/helpers.py
================
"""Helper functions for the A2A client."""
⋮----
"""Create a Message object containing a single TextPart.

    Args:
        role: The role of the message sender (user or agent). Defaults to Role.user.
        content: The text content of the message. Defaults to an empty string.

    Returns:
        A `Message` object with a new UUID message_id.
    """

================
File: src/a2a/client/legacy_grpc.py
================
"""Backwards compatibility layer for the legacy A2A gRPC client."""
⋮----
class A2AGrpcClient(GrpcTransport)
⋮----
"""[DEPRECATED] Backwards compatibility wrapper for the gRPC client."""
⋮----
def __init__(  # pylint: disable=super-init-not-called
⋮----
# The old gRPC client accepted a stub directly. The new one accepts a
# channel and builds the stub itself. We just have a stub here, so we
# need to handle initialization ourselves.
⋮----
class _NopChannel
⋮----
async def close(self) -> None

================
File: src/a2a/client/legacy.py
================
"""Backwards compatibility layer for legacy A2A clients."""
⋮----
class A2AClient
⋮----
"""[DEPRECATED] Backwards compatibility wrapper for the JSON-RPC client."""
⋮----
"""Sends a non-streaming message request to the agent.

        Args:
            request: The `SendMessageRequest` object containing the message and configuration.
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.post request.
            context: The client call context.

        Returns:
            A `SendMessageResponse` object containing the agent's response (Task or Message) or an error.

        Raises:
            A2AClientHTTPError: If an HTTP error occurs during the request.
            A2AClientJSONError: If the response body cannot be decoded as JSON or validated.
        """
⋮----
context = ClientCallContext(state={'http_kwargs': http_kwargs})
⋮----
result = await self._transport.send_message(
⋮----
"""Sends a streaming message request to the agent and yields responses as they arrive.

        This method uses Server-Sent Events (SSE) to receive a stream of updates from the agent.

        Args:
            request: The `SendStreamingMessageRequest` object containing the message and configuration.
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.post request. A default `timeout=None` is set but can be overridden.
            context: The client call context.

        Yields:
            `SendStreamingMessageResponse` objects as they are received in the SSE stream.
            These can be Task, Message, TaskStatusUpdateEvent, or TaskArtifactUpdateEvent.

        Raises:
            A2AClientHTTPError: If an HTTP or SSE protocol error occurs during the request.
            A2AClientJSONError: If an SSE event data cannot be decoded as JSON or validated.
        """
⋮----
"""Retrieves the current state and history of a specific task.

        Args:
            request: The `GetTaskRequest` object specifying the task ID and history length.
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.post request.
            context: The client call context.

        Returns:
            A `GetTaskResponse` object containing the Task or an error.

        Raises:
            A2AClientHTTPError: If an HTTP error occurs during the request.
            A2AClientJSONError: If the response body cannot be decoded as JSON or validated.
        """
⋮----
result = await self._transport.get_task(
⋮----
"""Requests the agent to cancel a specific task.

        Args:
            request: The `CancelTaskRequest` object specifying the task ID.
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.post request.
            context: The client call context.

        Returns:
            A `CancelTaskResponse` object containing the updated Task with canceled status or an error.

        Raises:
            A2AClientHTTPError: If an HTTP error occurs during the request.
            A2AClientJSONError: If the response body cannot be decoded as JSON or validated.
        """
⋮----
result = await self._transport.cancel_task(
⋮----
"""Sets or updates the push notification configuration for a specific task.

        Args:
            request: The `SetTaskPushNotificationConfigRequest` object specifying the task ID and configuration.
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.post request.
            context: The client call context.

        Returns:
            A `SetTaskPushNotificationConfigResponse` object containing the confirmation or an error.

        Raises:
            A2AClientHTTPError: If an HTTP error occurs during the request.
            A2AClientJSONError: If the response body cannot be decoded as JSON or validated.
        """
⋮----
result = await self._transport.set_task_callback(
⋮----
"""Retrieves the push notification configuration for a specific task.

        Args:
            request: The `GetTaskPushNotificationConfigRequest` object specifying the task ID.
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.post request.
            context: The client call context.

        Returns:
            A `GetTaskPushNotificationConfigResponse` object containing the configuration or an error.

        Raises:
            A2AClientHTTPError: If an HTTP error occurs during the request.
            A2AClientJSONError: If the response body cannot be decoded as JSON or validated.
        """
⋮----
params = request.params
⋮----
params = GetTaskPushNotificationConfigParams(id=request.params.id)
⋮----
result = await self._transport.get_task_callback(
⋮----
"""Reconnects to get task updates.

        This method uses Server-Sent Events (SSE) to receive a stream of updates from the agent.

        Args:
            request: The `TaskResubscriptionRequest` object containing the task information to reconnect to.
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.post request. A default `timeout=None` is set but can be overridden.
            context: The client call context.

        Yields:
            `SendStreamingMessageResponse` objects as they are received in the SSE stream.
            These can be Task, Message, TaskStatusUpdateEvent, or TaskArtifactUpdateEvent.

        Raises:
            A2AClientHTTPError: If an HTTP or SSE protocol error occurs during the request.
            A2AClientJSONError: If an SSE event data cannot be decoded as JSON or validated.
        """
⋮----
"""Retrieves the authenticated card (if necessary) or the public one.

        Args:
            http_kwargs: Optional dictionary of keyword arguments to pass to the
                underlying httpx.post request.
            context: The client call context.

        Returns:
            A `AgentCard` object containing the card or an error.

        Raises:
            A2AClientHTTPError: If an HTTP error occurs during the request.
            A2AClientJSONError: If the response body cannot be decoded as JSON or validated.
        """

================
File: src/a2a/client/middleware.py
================
from collections.abc import MutableMapping  # noqa: TC003
⋮----
class ClientCallContext(BaseModel)
⋮----
"""A context passed with each client call, allowing for call-specific.

    configuration and data passing. Such as authentication details or
    request deadlines.
    """
⋮----
state: MutableMapping[str, Any] = Field(default_factory=dict)
⋮----
class ClientCallInterceptor(ABC)
⋮----
"""An abstract base class for client-side call interceptors.

    Interceptors can inspect and modify requests before they are sent,
    which is ideal for concerns like authentication, logging, or tracing.
    """
⋮----
"""
        Intercepts a client call before the request is sent.

        Args:
            method_name: The name of the RPC method (e.g., 'message/send').
            request_payload: The JSON RPC request payload dictionary.
            http_kwargs: The keyword arguments for the httpx request.
            agent_card: The AgentCard associated with the client.
            context: The ClientCallContext for this specific call.

        Returns:
            A tuple containing the (potentially modified) request_payload
            and http_kwargs.
        """

================
File: src/a2a/client/optionals.py
================
# Attempt to import the optional module
⋮----
from grpc.aio import Channel  # pyright: ignore[reportAssignmentType]
⋮----
# If grpc.aio is not available, define a dummy type for type checking.
# This dummy type will only be used by type checkers.
⋮----
class Channel:  # type: ignore[no-redef]
⋮----
"""Dummy class for type hinting when grpc.aio is not available."""
⋮----
Channel = None  # At runtime, pd will be None if the import failed.

================
File: src/a2a/extensions/common.py
================
HTTP_EXTENSION_HEADER = 'X-A2A-Extensions'
⋮----
def get_requested_extensions(values: list[str]) -> set[str]
⋮----
"""Get the set of requested extensions from an input list.

    This handles the list containing potentially comma-separated values, as
    occurs when using a list in an HTTP header.
    """
⋮----
def find_extension_by_uri(card: AgentCard, uri: str) -> AgentExtension | None
⋮----
"""Find an AgentExtension in an AgentCard given a uri."""

================
File: src/a2a/grpc/a2a_pb2_grpc.py
================
# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
⋮----
class A2AServiceStub(object)
⋮----
"""A2AService defines the gRPC version of the A2A protocol. This has a slightly
    different shape than the JSONRPC version to better conform to AIP-127,
    where appropriate. The nouns are AgentCard, Message, Task and
    TaskPushNotificationConfig.
    - Messages are not a standard resource so there is no get/delete/update/list
    interface, only a send and stream custom methods.
    - Tasks have a get interface and custom cancel and subscribe methods.
    - TaskPushNotificationConfig are a resource whose parent is a task.
    They have get, list and create methods.
    - AgentCard is a static resource with only a get method.
    """
⋮----
def __init__(self, channel)
⋮----
"""Constructor.

        Args:
            channel: A grpc.Channel.
        """
⋮----
class A2AServiceServicer(object)
⋮----
def SendMessage(self, request, context)
⋮----
"""Send a message to the agent. This is a blocking call that will return the
        task once it is completed, or a LRO if requested.
        """
⋮----
def SendStreamingMessage(self, request, context)
⋮----
"""SendStreamingMessage is a streaming call that will return a stream of
        task update events until the Task is in an interrupted or terminal state.
        """
⋮----
def GetTask(self, request, context)
⋮----
"""Get the current state of a task from the agent.
        """
⋮----
def CancelTask(self, request, context)
⋮----
"""Cancel a task from the agent. If supported one should expect no
        more task updates for the task.
        """
⋮----
def TaskSubscription(self, request, context)
⋮----
"""TaskSubscription is a streaming call that will return a stream of task
        update events. This attaches the stream to an existing in process task.
        If the task is complete the stream will return the completed task (like
        GetTask) and close the stream.
        """
⋮----
def CreateTaskPushNotificationConfig(self, request, context)
⋮----
"""Set a push notification config for a task.
        """
⋮----
def GetTaskPushNotificationConfig(self, request, context)
⋮----
"""Get a push notification config for a task.
        """
⋮----
def ListTaskPushNotificationConfig(self, request, context)
⋮----
"""Get a list of push notifications configured for a task.
        """
⋮----
def GetAgentCard(self, request, context)
⋮----
"""GetAgentCard returns the agent card for the agent.
        """
⋮----
def DeleteTaskPushNotificationConfig(self, request, context)
⋮----
"""Delete a push notification config for a task.
        """
⋮----
def add_A2AServiceServicer_to_server(servicer, server)
⋮----
rpc_method_handlers = {
generic_handler = grpc.method_handlers_generic_handler(
⋮----
# This class is part of an EXPERIMENTAL API.
class A2AService(object)

================
File: src/a2a/grpc/a2a_pb2.py
================
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: a2a.proto
# Protobuf Python Version: 5.29.3
"""Generated protocol buffer code."""
⋮----
# @@protoc_insertion_point(imports)
⋮----
_sym_db = _symbol_database.Default()
⋮----
DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\ta2a.proto\x12\x06\x61\x32\x61.v1\x1a\x1cgoogle/api/annotations.proto\x1a\x17google/api/client.proto\x1a\x1fgoogle/api/field_behavior.proto\x1a\x1bgoogle/protobuf/empty.proto\x1a\x1cgoogle/protobuf/struct.proto\x1a\x1fgoogle/protobuf/timestamp.proto\"\xde\x01\n\x18SendMessageConfiguration\x12\x32\n\x15\x61\x63\x63\x65pted_output_modes\x18\x01 \x03(\tR\x13\x61\x63\x63\x65ptedOutputModes\x12K\n\x11push_notification\x18\x02 \x01(\x0b\x32\x1e.a2a.v1.PushNotificationConfigR\x10pushNotification\x12%\n\x0ehistory_length\x18\x03 \x01(\x05R\rhistoryLength\x12\x1a\n\x08\x62locking\x18\x04 \x01(\x08R\x08\x62locking\"\xf1\x01\n\x04Task\x12\x0e\n\x02id\x18\x01 \x01(\tR\x02id\x12\x1d\n\ncontext_id\x18\x02 \x01(\tR\tcontextId\x12*\n\x06status\x18\x03 \x01(\x0b\x32\x12.a2a.v1.TaskStatusR\x06status\x12.\n\tartifacts\x18\x04 \x03(\x0b\x32\x10.a2a.v1.ArtifactR\tartifacts\x12)\n\x07history\x18\x05 \x03(\x0b\x32\x0f.a2a.v1.MessageR\x07history\x12\x33\n\x08metadata\x18\x06 \x01(\x0b\x32\x17.google.protobuf.StructR\x08metadata\"\x99\x01\n\nTaskStatus\x12\'\n\x05state\x18\x01 \x01(\x0e\x32\x11.a2a.v1.TaskStateR\x05state\x12(\n\x06update\x18\x02 \x01(\x0b\x32\x0f.a2a.v1.MessageR\x07message\x12\x38\n\ttimestamp\x18\x03 \x01(\x0b\x32\x1a.google.protobuf.TimestampR\ttimestamp\"t\n\x04Part\x12\x14\n\x04text\x18\x01 \x01(\tH\x00R\x04text\x12&\n\x04\x66ile\x18\x02 \x01(\x0b\x32\x10.a2a.v1.FilePartH\x00R\x04\x66ile\x12&\n\x04\x64\x61ta\x18\x03 \x01(\x0b\x32\x10.a2a.v1.DataPartH\x00R\x04\x64\x61taB\x06\n\x04part\"\x7f\n\x08\x46ilePart\x12$\n\rfile_with_uri\x18\x01 \x01(\tH\x00R\x0b\x66ileWithUri\x12(\n\x0f\x66ile_with_bytes\x18\x02 \x01(\x0cH\x00R\rfileWithBytes\x12\x1b\n\tmime_type\x18\x03 \x01(\tR\x08mimeTypeB\x06\n\x04\x66ile\"7\n\x08\x44\x61taPart\x12+\n\x04\x64\x61ta\x18\x01 \x01(\x0b\x32\x17.google.protobuf.StructR\x04\x64\x61ta\"\xff\x01\n\x07Message\x12\x1d\n\nmessage_id\x18\x01 \x01(\tR\tmessageId\x12\x1d\n\ncontext_id\x18\x02 \x01(\tR\tcontextId\x12\x17\n\x07task_id\x18\x03 \x01(\tR\x06taskId\x12 \n\x04role\x18\x04 \x01(\x0e\x32\x0c.a2a.v1.RoleR\x04role\x12&\n\x07\x63ontent\x18\x05 \x03(\x0b\x32\x0c.a2a.v1.PartR\x07\x63ontent\x12\x33\n\x08metadata\x18\x06 \x01(\x0b\x32\x17.google.protobuf.StructR\x08metadata\x12\x1e\n\nextensions\x18\x07 \x03(\tR\nextensions\"\xda\x01\n\x08\x41rtifact\x12\x1f\n\x0b\x61rtifact_id\x18\x01 \x01(\tR\nartifactId\x12\x12\n\x04name\x18\x03 \x01(\tR\x04name\x12 \n\x0b\x64\x65scription\x18\x04 \x01(\tR\x0b\x64\x65scription\x12\"\n\x05parts\x18\x05 \x03(\x0b\x32\x0c.a2a.v1.PartR\x05parts\x12\x33\n\x08metadata\x18\x06 \x01(\x0b\x32\x17.google.protobuf.StructR\x08metadata\x12\x1e\n\nextensions\x18\x07 \x03(\tR\nextensions\"\xc6\x01\n\x15TaskStatusUpdateEvent\x12\x17\n\x07task_id\x18\x01 \x01(\tR\x06taskId\x12\x1d\n\ncontext_id\x18\x02 \x01(\tR\tcontextId\x12*\n\x06status\x18\x03 \x01(\x0b\x32\x12.a2a.v1.TaskStatusR\x06status\x12\x14\n\x05\x66inal\x18\x04 \x01(\x08R\x05\x66inal\x12\x33\n\x08metadata\x18\x05 \x01(\x0b\x32\x17.google.protobuf.StructR\x08metadata\"\xeb\x01\n\x17TaskArtifactUpdateEvent\x12\x17\n\x07task_id\x18\x01 \x01(\tR\x06taskId\x12\x1d\n\ncontext_id\x18\x02 \x01(\tR\tcontextId\x12,\n\x08\x61rtifact\x18\x03 \x01(\x0b\x32\x10.a2a.v1.ArtifactR\x08\x61rtifact\x12\x16\n\x06\x61ppend\x18\x04 \x01(\x08R\x06\x61ppend\x12\x1d\n\nlast_chunk\x18\x05 \x01(\x08R\tlastChunk\x12\x33\n\x08metadata\x18\x06 \x01(\x0b\x32\x17.google.protobuf.StructR\x08metadata\"\x94\x01\n\x16PushNotificationConfig\x12\x0e\n\x02id\x18\x01 \x01(\tR\x02id\x12\x10\n\x03url\x18\x02 \x01(\tR\x03url\x12\x14\n\x05token\x18\x03 \x01(\tR\x05token\x12\x42\n\x0e\x61uthentication\x18\x04 \x01(\x0b\x32\x1a.a2a.v1.AuthenticationInfoR\x0e\x61uthentication\"P\n\x12\x41uthenticationInfo\x12\x18\n\x07schemes\x18\x01 \x03(\tR\x07schemes\x12 \n\x0b\x63redentials\x18\x02 \x01(\tR\x0b\x63redentials\"@\n\x0e\x41gentInterface\x12\x10\n\x03url\x18\x01 \x01(\tR\x03url\x12\x1c\n\ttransport\x18\x02 \x01(\tR\ttransport\"\xad\x07\n\tAgentCard\x12)\n\x10protocol_version\x18\x10 \x01(\tR\x0fprotocolVersion\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\x12 \n\x0b\x64\x65scription\x18\x02 \x01(\tR\x0b\x64\x65scription\x12\x10\n\x03url\x18\x03 \x01(\tR\x03url\x12/\n\x13preferred_transport\x18\x0e \x01(\tR\x12preferredTransport\x12K\n\x15\x61\x64\x64itional_interfaces\x18\x0f \x03(\x0b\x32\x16.a2a.v1.AgentInterfaceR\x14\x61\x64\x64itionalInterfaces\x12\x31\n\x08provider\x18\x04 \x01(\x0b\x32\x15.a2a.v1.AgentProviderR\x08provider\x12\x18\n\x07version\x18\x05 \x01(\tR\x07version\x12+\n\x11\x64ocumentation_url\x18\x06 \x01(\tR\x10\x64ocumentationUrl\x12=\n\x0c\x63\x61pabilities\x18\x07 \x01(\x0b\x32\x19.a2a.v1.AgentCapabilitiesR\x0c\x63\x61pabilities\x12Q\n\x10security_schemes\x18\x08 \x03(\x0b\x32&.a2a.v1.AgentCard.SecuritySchemesEntryR\x0fsecuritySchemes\x12,\n\x08security\x18\t \x03(\x0b\x32\x10.a2a.v1.SecurityR\x08security\x12.\n\x13\x64\x65\x66\x61ult_input_modes\x18\n \x03(\tR\x11\x64\x65\x66\x61ultInputModes\x12\x30\n\x14\x64\x65\x66\x61ult_output_modes\x18\x0b \x03(\tR\x12\x64\x65\x66\x61ultOutputModes\x12*\n\x06skills\x18\x0c \x03(\x0b\x32\x12.a2a.v1.AgentSkillR\x06skills\x12O\n$supports_authenticated_extended_card\x18\r \x01(\x08R!supportsAuthenticatedExtendedCard\x12:\n\nsignatures\x18\x11 \x03(\x0b\x32\x1a.a2a.v1.AgentCardSignatureR\nsignatures\x1aZ\n\x14SecuritySchemesEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12,\n\x05value\x18\x02 \x01(\x0b\x32\x16.a2a.v1.SecuritySchemeR\x05value:\x02\x38\x01\"E\n\rAgentProvider\x12\x10\n\x03url\x18\x01 \x01(\tR\x03url\x12\"\n\x0corganization\x18\x02 \x01(\tR\x0corganization\"\x98\x01\n\x11\x41gentCapabilities\x12\x1c\n\tstreaming\x18\x01 \x01(\x08R\tstreaming\x12-\n\x12push_notifications\x18\x02 \x01(\x08R\x11pushNotifications\x12\x36\n\nextensions\x18\x03 \x03(\x0b\x32\x16.a2a.v1.AgentExtensionR\nextensions\"\x91\x01\n\x0e\x41gentExtension\x12\x10\n\x03uri\x18\x01 \x01(\tR\x03uri\x12 \n\x0b\x64\x65scription\x18\x02 \x01(\tR\x0b\x64\x65scription\x12\x1a\n\x08required\x18\x03 \x01(\x08R\x08required\x12/\n\x06params\x18\x04 \x01(\x0b\x32\x17.google.protobuf.StructR\x06params\"\xf4\x01\n\nAgentSkill\x12\x0e\n\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n\x04name\x18\x02 \x01(\tR\x04name\x12 \n\x0b\x64\x65scription\x18\x03 \x01(\tR\x0b\x64\x65scription\x12\x12\n\x04tags\x18\x04 \x03(\tR\x04tags\x12\x1a\n\x08\x65xamples\x18\x05 \x03(\tR\x08\x65xamples\x12\x1f\n\x0binput_modes\x18\x06 \x03(\tR\ninputModes\x12!\n\x0coutput_modes\x18\x07 \x03(\tR\x0boutputModes\x12,\n\x08security\x18\x08 \x03(\x0b\x32\x10.a2a.v1.SecurityR\x08security\"\x8b\x01\n\x12\x41gentCardSignature\x12!\n\tprotected\x18\x01 \x01(\tB\x03\xe0\x41\x02R\tprotected\x12!\n\tsignature\x18\x02 \x01(\tB\x03\xe0\x41\x02R\tsignature\x12/\n\x06header\x18\x03 \x01(\x0b\x32\x17.google.protobuf.StructR\x06header\"\x8a\x01\n\x1aTaskPushNotificationConfig\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\x12X\n\x18push_notification_config\x18\x02 \x01(\x0b\x32\x1e.a2a.v1.PushNotificationConfigR\x16pushNotificationConfig\" \n\nStringList\x12\x12\n\x04list\x18\x01 \x03(\tR\x04list\"\x93\x01\n\x08Security\x12\x37\n\x07schemes\x18\x01 \x03(\x0b\x32\x1d.a2a.v1.Security.SchemesEntryR\x07schemes\x1aN\n\x0cSchemesEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12(\n\x05value\x18\x02 \x01(\x0b\x32\x12.a2a.v1.StringListR\x05value:\x02\x38\x01\"\xe6\x03\n\x0eSecurityScheme\x12U\n\x17\x61pi_key_security_scheme\x18\x01 \x01(\x0b\x32\x1c.a2a.v1.APIKeySecuritySchemeH\x00R\x14\x61piKeySecurityScheme\x12[\n\x19http_auth_security_scheme\x18\x02 \x01(\x0b\x32\x1e.a2a.v1.HTTPAuthSecuritySchemeH\x00R\x16httpAuthSecurityScheme\x12T\n\x16oauth2_security_scheme\x18\x03 \x01(\x0b\x32\x1c.a2a.v1.OAuth2SecuritySchemeH\x00R\x14oauth2SecurityScheme\x12k\n\x1fopen_id_connect_security_scheme\x18\x04 \x01(\x0b\x32#.a2a.v1.OpenIdConnectSecuritySchemeH\x00R\x1bopenIdConnectSecurityScheme\x12S\n\x14mtls_security_scheme\x18\x05 \x01(\x0b\x32\x1f.a2a.v1.MutualTlsSecuritySchemeH\x00R\x12mtlsSecuritySchemeB\x08\n\x06scheme\"h\n\x14\x41PIKeySecurityScheme\x12 \n\x0b\x64\x65scription\x18\x01 \x01(\tR\x0b\x64\x65scription\x12\x1a\n\x08location\x18\x02 \x01(\tR\x08location\x12\x12\n\x04name\x18\x03 \x01(\tR\x04name\"w\n\x16HTTPAuthSecurityScheme\x12 \n\x0b\x64\x65scription\x18\x01 \x01(\tR\x0b\x64\x65scription\x12\x16\n\x06scheme\x18\x02 \x01(\tR\x06scheme\x12#\n\rbearer_format\x18\x03 \x01(\tR\x0c\x62\x65\x61rerFormat\"\x92\x01\n\x14OAuth2SecurityScheme\x12 \n\x0b\x64\x65scription\x18\x01 \x01(\tR\x0b\x64\x65scription\x12(\n\x05\x66lows\x18\x02 \x01(\x0b\x32\x12.a2a.v1.OAuthFlowsR\x05\x66lows\x12.\n\x13oauth2_metadata_url\x18\x03 \x01(\tR\x11oauth2MetadataUrl\"n\n\x1bOpenIdConnectSecurityScheme\x12 \n\x0b\x64\x65scription\x18\x01 \x01(\tR\x0b\x64\x65scription\x12-\n\x13open_id_connect_url\x18\x02 \x01(\tR\x10openIdConnectUrl\";\n\x17MutualTlsSecurityScheme\x12 \n\x0b\x64\x65scription\x18\x01 \x01(\tR\x0b\x64\x65scription\"\xb0\x02\n\nOAuthFlows\x12S\n\x12\x61uthorization_code\x18\x01 \x01(\x0b\x32\".a2a.v1.AuthorizationCodeOAuthFlowH\x00R\x11\x61uthorizationCode\x12S\n\x12\x63lient_credentials\x18\x02 \x01(\x0b\x32\".a2a.v1.ClientCredentialsOAuthFlowH\x00R\x11\x63lientCredentials\x12\x37\n\x08implicit\x18\x03 \x01(\x0b\x32\x19.a2a.v1.ImplicitOAuthFlowH\x00R\x08implicit\x12\x37\n\x08password\x18\x04 \x01(\x0b\x32\x19.a2a.v1.PasswordOAuthFlowH\x00R\x08passwordB\x06\n\x04\x66low\"\x8a\x02\n\x1a\x41uthorizationCodeOAuthFlow\x12+\n\x11\x61uthorization_url\x18\x01 \x01(\tR\x10\x61uthorizationUrl\x12\x1b\n\ttoken_url\x18\x02 \x01(\tR\x08tokenUrl\x12\x1f\n\x0brefresh_url\x18\x03 \x01(\tR\nrefreshUrl\x12\x46\n\x06scopes\x18\x04 \x03(\x0b\x32..a2a.v1.AuthorizationCodeOAuthFlow.ScopesEntryR\x06scopes\x1a\x39\n\x0bScopesEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\"\xdd\x01\n\x1a\x43lientCredentialsOAuthFlow\x12\x1b\n\ttoken_url\x18\x01 \x01(\tR\x08tokenUrl\x12\x1f\n\x0brefresh_url\x18\x02 \x01(\tR\nrefreshUrl\x12\x46\n\x06scopes\x18\x03 \x03(\x0b\x32..a2a.v1.ClientCredentialsOAuthFlow.ScopesEntryR\x06scopes\x1a\x39\n\x0bScopesEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\"\xdb\x01\n\x11ImplicitOAuthFlow\x12+\n\x11\x61uthorization_url\x18\x01 \x01(\tR\x10\x61uthorizationUrl\x12\x1f\n\x0brefresh_url\x18\x02 \x01(\tR\nrefreshUrl\x12=\n\x06scopes\x18\x03 \x03(\x0b\x32%.a2a.v1.ImplicitOAuthFlow.ScopesEntryR\x06scopes\x1a\x39\n\x0bScopesEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\"\xcb\x01\n\x11PasswordOAuthFlow\x12\x1b\n\ttoken_url\x18\x01 \x01(\tR\x08tokenUrl\x12\x1f\n\x0brefresh_url\x18\x02 \x01(\tR\nrefreshUrl\x12=\n\x06scopes\x18\x03 \x03(\x0b\x32%.a2a.v1.PasswordOAuthFlow.ScopesEntryR\x06scopes\x1a\x39\n\x0bScopesEntry\x12\x10\n\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n\x05value\x18\x02 \x01(\tR\x05value:\x02\x38\x01\"\xc1\x01\n\x12SendMessageRequest\x12.\n\x07request\x18\x01 \x01(\x0b\x32\x0f.a2a.v1.MessageB\x03\xe0\x41\x02R\x07message\x12\x46\n\rconfiguration\x18\x02 \x01(\x0b\x32 .a2a.v1.SendMessageConfigurationR\rconfiguration\x12\x33\n\x08metadata\x18\x03 \x01(\x0b\x32\x17.google.protobuf.StructR\x08metadata\"P\n\x0eGetTaskRequest\x12\x17\n\x04name\x18\x01 \x01(\tB\x03\xe0\x41\x02R\x04name\x12%\n\x0ehistory_length\x18\x02 \x01(\x05R\rhistoryLength\"\'\n\x11\x43\x61ncelTaskRequest\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\":\n$GetTaskPushNotificationConfigRequest\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\"=\n\'DeleteTaskPushNotificationConfigRequest\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\"\xa9\x01\n\'CreateTaskPushNotificationConfigRequest\x12\x1b\n\x06parent\x18\x01 \x01(\tB\x03\xe0\x41\x02R\x06parent\x12 \n\tconfig_id\x18\x02 \x01(\tB\x03\xe0\x41\x02R\x08\x63onfigId\x12?\n\x06\x63onfig\x18\x03 \x01(\x0b\x32\".a2a.v1.TaskPushNotificationConfigB\x03\xe0\x41\x02R\x06\x63onfig\"-\n\x17TaskSubscriptionRequest\x12\x12\n\x04name\x18\x01 \x01(\tR\x04name\"{\n%ListTaskPushNotificationConfigRequest\x12\x16\n\x06parent\x18\x01 \x01(\tR\x06parent\x12\x1b\n\tpage_size\x18\x02 \x01(\x05R\x08pageSize\x12\x1d\n\npage_token\x18\x03 \x01(\tR\tpageToken\"\x15\n\x13GetAgentCardRequest\"m\n\x13SendMessageResponse\x12\"\n\x04task\x18\x01 \x01(\x0b\x32\x0c.a2a.v1.TaskH\x00R\x04task\x12\'\n\x03msg\x18\x02 \x01(\x0b\x32\x0f.a2a.v1.MessageH\x00R\x07messageB\t\n\x07payload\"\xfa\x01\n\x0eStreamResponse\x12\"\n\x04task\x18\x01 \x01(\x0b\x32\x0c.a2a.v1.TaskH\x00R\x04task\x12\'\n\x03msg\x18\x02 \x01(\x0b\x32\x0f.a2a.v1.MessageH\x00R\x07message\x12\x44\n\rstatus_update\x18\x03 \x01(\x0b\x32\x1d.a2a.v1.TaskStatusUpdateEventH\x00R\x0cstatusUpdate\x12J\n\x0f\x61rtifact_update\x18\x04 \x01(\x0b\x32\x1f.a2a.v1.TaskArtifactUpdateEventH\x00R\x0e\x61rtifactUpdateB\t\n\x07payload\"\x8e\x01\n&ListTaskPushNotificationConfigResponse\x12<\n\x07\x63onfigs\x18\x01 \x03(\x0b\x32\".a2a.v1.TaskPushNotificationConfigR\x07\x63onfigs\x12&\n\x0fnext_page_token\x18\x02 \x01(\tR\rnextPageToken*\xfa\x01\n\tTaskState\x12\x1a\n\x16TASK_STATE_UNSPECIFIED\x10\x00\x12\x18\n\x14TASK_STATE_SUBMITTED\x10\x01\x12\x16\n\x12TASK_STATE_WORKING\x10\x02\x12\x18\n\x14TASK_STATE_COMPLETED\x10\x03\x12\x15\n\x11TASK_STATE_FAILED\x10\x04\x12\x18\n\x14TASK_STATE_CANCELLED\x10\x05\x12\x1d\n\x19TASK_STATE_INPUT_REQUIRED\x10\x06\x12\x17\n\x13TASK_STATE_REJECTED\x10\x07\x12\x1c\n\x18TASK_STATE_AUTH_REQUIRED\x10\x08*;\n\x04Role\x12\x14\n\x10ROLE_UNSPECIFIED\x10\x00\x12\r\n\tROLE_USER\x10\x01\x12\x0e\n\nROLE_AGENT\x10\x02\x32\xba\n\n\nA2AService\x12\x63\n\x0bSendMessage\x12\x1a.a2a.v1.SendMessageRequest\x1a\x1b.a2a.v1.SendMessageResponse\"\x1b\x82\xd3\xe4\x93\x02\x15\"\x10/v1/message:send:\x01*\x12k\n\x14SendStreamingMessage\x12\x1a.a2a.v1.SendMessageRequest\x1a\x16.a2a.v1.StreamResponse\"\x1d\x82\xd3\xe4\x93\x02\x17\"\x12/v1/message:stream:\x01*0\x01\x12R\n\x07GetTask\x12\x16.a2a.v1.GetTaskRequest\x1a\x0c.a2a.v1.Task\"!\xda\x41\x04name\x82\xd3\xe4\x93\x02\x14\x12\x12/v1/{name=tasks/*}\x12[\n\nCancelTask\x12\x19.a2a.v1.CancelTaskRequest\x1a\x0c.a2a.v1.Task\"$\x82\xd3\xe4\x93\x02\x1e\"\x19/v1/{name=tasks/*}:cancel:\x01*\x12s\n\x10TaskSubscription\x12\x1f.a2a.v1.TaskSubscriptionRequest\x1a\x16.a2a.v1.StreamResponse\"$\x82\xd3\xe4\x93\x02\x1e\x12\x1c/v1/{name=tasks/*}:subscribe0\x01\x12\xc4\x01\n CreateTaskPushNotificationConfig\x12/.a2a.v1.CreateTaskPushNotificationConfigRequest\x1a\".a2a.v1.TaskPushNotificationConfig\"K\xda\x41\rparent,config\x82\xd3\xe4\x93\x02\x35\"+/v1/{parent=task/*/pushNotificationConfigs}:\x06\x63onfig\x12\xae\x01\n\x1dGetTaskPushNotificationConfig\x12,.a2a.v1.GetTaskPushNotificationConfigRequest\x1a\".a2a.v1.TaskPushNotificationConfig\";\xda\x41\x04name\x82\xd3\xe4\x93\x02.\x12,/v1/{name=tasks/*/pushNotificationConfigs/*}\x12\xbe\x01\n\x1eListTaskPushNotificationConfig\x12-.a2a.v1.ListTaskPushNotificationConfigRequest\x1a..a2a.v1.ListTaskPushNotificationConfigResponse\"=\xda\x41\x06parent\x82\xd3\xe4\x93\x02.\x12,/v1/{parent=tasks/*}/pushNotificationConfigs\x12P\n\x0cGetAgentCard\x12\x1b.a2a.v1.GetAgentCardRequest\x1a\x11.a2a.v1.AgentCard\"\x10\x82\xd3\xe4\x93\x02\n\x12\x08/v1/card\x12\xa8\x01\n DeleteTaskPushNotificationConfig\x12/.a2a.v1.DeleteTaskPushNotificationConfigRequest\x1a\x16.google.protobuf.Empty\";\xda\x41\x04name\x82\xd3\xe4\x93\x02.*,/v1/{name=tasks/*/pushNotificationConfigs/*}Bi\n\ncom.a2a.v1B\x08\x41\x32\x61ProtoP\x01Z\x18google.golang.org/a2a/v1\xa2\x02\x03\x41XX\xaa\x02\x06\x41\x32\x61.V1\xca\x02\x06\x41\x32\x61\\V1\xe2\x02\x12\x41\x32\x61\\V1\\GPBMetadata\xea\x02\x07\x41\x32\x61::V1b\x06proto3')
⋮----
_globals = globals()
⋮----
# @@protoc_insertion_point(module_scope)

================
File: src/a2a/grpc/a2a_pb2.pyi
================
import datetime

from google.api import annotations_pb2 as _annotations_pb2
from google.api import client_pb2 as _client_pb2
from google.api import field_behavior_pb2 as _field_behavior_pb2
from google.protobuf import empty_pb2 as _empty_pb2
from google.protobuf import struct_pb2 as _struct_pb2
from google.protobuf import timestamp_pb2 as _timestamp_pb2
from google.protobuf.internal import containers as _containers
from google.protobuf.internal import enum_type_wrapper as _enum_type_wrapper
from google.protobuf import descriptor as _descriptor
from google.protobuf import message as _message
from collections.abc import Iterable as _Iterable, Mapping as _Mapping
from typing import ClassVar as _ClassVar, Optional as _Optional, Union as _Union

DESCRIPTOR: _descriptor.FileDescriptor

class TaskState(int, metaclass=_enum_type_wrapper.EnumTypeWrapper):
    __slots__ = ()
    TASK_STATE_UNSPECIFIED: _ClassVar[TaskState]
    TASK_STATE_SUBMITTED: _ClassVar[TaskState]
    TASK_STATE_WORKING: _ClassVar[TaskState]
    TASK_STATE_COMPLETED: _ClassVar[TaskState]
    TASK_STATE_FAILED: _ClassVar[TaskState]
    TASK_STATE_CANCELLED: _ClassVar[TaskState]
    TASK_STATE_INPUT_REQUIRED: _ClassVar[TaskState]
    TASK_STATE_REJECTED: _ClassVar[TaskState]
    TASK_STATE_AUTH_REQUIRED: _ClassVar[TaskState]

class Role(int, metaclass=_enum_type_wrapper.EnumTypeWrapper):
    __slots__ = ()
    ROLE_UNSPECIFIED: _ClassVar[Role]
    ROLE_USER: _ClassVar[Role]
    ROLE_AGENT: _ClassVar[Role]
TASK_STATE_UNSPECIFIED: TaskState
TASK_STATE_SUBMITTED: TaskState
TASK_STATE_WORKING: TaskState
TASK_STATE_COMPLETED: TaskState
TASK_STATE_FAILED: TaskState
TASK_STATE_CANCELLED: TaskState
TASK_STATE_INPUT_REQUIRED: TaskState
TASK_STATE_REJECTED: TaskState
TASK_STATE_AUTH_REQUIRED: TaskState
ROLE_UNSPECIFIED: Role
ROLE_USER: Role
ROLE_AGENT: Role

class SendMessageConfiguration(_message.Message):
    __slots__ = ("accepted_output_modes", "push_notification", "history_length", "blocking")
    ACCEPTED_OUTPUT_MODES_FIELD_NUMBER: _ClassVar[int]
    PUSH_NOTIFICATION_FIELD_NUMBER: _ClassVar[int]
    HISTORY_LENGTH_FIELD_NUMBER: _ClassVar[int]
    BLOCKING_FIELD_NUMBER: _ClassVar[int]
    accepted_output_modes: _containers.RepeatedScalarFieldContainer[str]
    push_notification: PushNotificationConfig
    history_length: int
    blocking: bool
    def __init__(self, accepted_output_modes: _Optional[_Iterable[str]] = ..., push_notification: _Optional[_Union[PushNotificationConfig, _Mapping]] = ..., history_length: _Optional[int] = ..., blocking: bool = ...) -> None: ...

class Task(_message.Message):
    __slots__ = ("id", "context_id", "status", "artifacts", "history", "metadata")
    ID_FIELD_NUMBER: _ClassVar[int]
    CONTEXT_ID_FIELD_NUMBER: _ClassVar[int]
    STATUS_FIELD_NUMBER: _ClassVar[int]
    ARTIFACTS_FIELD_NUMBER: _ClassVar[int]
    HISTORY_FIELD_NUMBER: _ClassVar[int]
    METADATA_FIELD_NUMBER: _ClassVar[int]
    id: str
    context_id: str
    status: TaskStatus
    artifacts: _containers.RepeatedCompositeFieldContainer[Artifact]
    history: _containers.RepeatedCompositeFieldContainer[Message]
    metadata: _struct_pb2.Struct
    def __init__(self, id: _Optional[str] = ..., context_id: _Optional[str] = ..., status: _Optional[_Union[TaskStatus, _Mapping]] = ..., artifacts: _Optional[_Iterable[_Union[Artifact, _Mapping]]] = ..., history: _Optional[_Iterable[_Union[Message, _Mapping]]] = ..., metadata: _Optional[_Union[_struct_pb2.Struct, _Mapping]] = ...) -> None: ...

class TaskStatus(_message.Message):
    __slots__ = ("state", "update", "timestamp")
    STATE_FIELD_NUMBER: _ClassVar[int]
    UPDATE_FIELD_NUMBER: _ClassVar[int]
    TIMESTAMP_FIELD_NUMBER: _ClassVar[int]
    state: TaskState
    update: Message
    timestamp: _timestamp_pb2.Timestamp
    def __init__(self, state: _Optional[_Union[TaskState, str]] = ..., update: _Optional[_Union[Message, _Mapping]] = ..., timestamp: _Optional[_Union[datetime.datetime, _timestamp_pb2.Timestamp, _Mapping]] = ...) -> None: ...

class Part(_message.Message):
    __slots__ = ("text", "file", "data")
    TEXT_FIELD_NUMBER: _ClassVar[int]
    FILE_FIELD_NUMBER: _ClassVar[int]
    DATA_FIELD_NUMBER: _ClassVar[int]
    text: str
    file: FilePart
    data: DataPart
    def __init__(self, text: _Optional[str] = ..., file: _Optional[_Union[FilePart, _Mapping]] = ..., data: _Optional[_Union[DataPart, _Mapping]] = ...) -> None: ...

class FilePart(_message.Message):
    __slots__ = ("file_with_uri", "file_with_bytes", "mime_type")
    FILE_WITH_URI_FIELD_NUMBER: _ClassVar[int]
    FILE_WITH_BYTES_FIELD_NUMBER: _ClassVar[int]
    MIME_TYPE_FIELD_NUMBER: _ClassVar[int]
    file_with_uri: str
    file_with_bytes: bytes
    mime_type: str
    def __init__(self, file_with_uri: _Optional[str] = ..., file_with_bytes: _Optional[bytes] = ..., mime_type: _Optional[str] = ...) -> None: ...

class DataPart(_message.Message):
    __slots__ = ("data",)
    DATA_FIELD_NUMBER: _ClassVar[int]
    data: _struct_pb2.Struct
    def __init__(self, data: _Optional[_Union[_struct_pb2.Struct, _Mapping]] = ...) -> None: ...

class Message(_message.Message):
    __slots__ = ("message_id", "context_id", "task_id", "role", "content", "metadata", "extensions")
    MESSAGE_ID_FIELD_NUMBER: _ClassVar[int]
    CONTEXT_ID_FIELD_NUMBER: _ClassVar[int]
    TASK_ID_FIELD_NUMBER: _ClassVar[int]
    ROLE_FIELD_NUMBER: _ClassVar[int]
    CONTENT_FIELD_NUMBER: _ClassVar[int]
    METADATA_FIELD_NUMBER: _ClassVar[int]
    EXTENSIONS_FIELD_NUMBER: _ClassVar[int]
    message_id: str
    context_id: str
    task_id: str
    role: Role
    content: _containers.RepeatedCompositeFieldContainer[Part]
    metadata: _struct_pb2.Struct
    extensions: _containers.RepeatedScalarFieldContainer[str]
    def __init__(self, message_id: _Optional[str] = ..., context_id: _Optional[str] = ..., task_id: _Optional[str] = ..., role: _Optional[_Union[Role, str]] = ..., content: _Optional[_Iterable[_Union[Part, _Mapping]]] = ..., metadata: _Optional[_Union[_struct_pb2.Struct, _Mapping]] = ..., extensions: _Optional[_Iterable[str]] = ...) -> None: ...

class Artifact(_message.Message):
    __slots__ = ("artifact_id", "name", "description", "parts", "metadata", "extensions")
    ARTIFACT_ID_FIELD_NUMBER: _ClassVar[int]
    NAME_FIELD_NUMBER: _ClassVar[int]
    DESCRIPTION_FIELD_NUMBER: _ClassVar[int]
    PARTS_FIELD_NUMBER: _ClassVar[int]
    METADATA_FIELD_NUMBER: _ClassVar[int]
    EXTENSIONS_FIELD_NUMBER: _ClassVar[int]
    artifact_id: str
    name: str
    description: str
    parts: _containers.RepeatedCompositeFieldContainer[Part]
    metadata: _struct_pb2.Struct
    extensions: _containers.RepeatedScalarFieldContainer[str]
    def __init__(self, artifact_id: _Optional[str] = ..., name: _Optional[str] = ..., description: _Optional[str] = ..., parts: _Optional[_Iterable[_Union[Part, _Mapping]]] = ..., metadata: _Optional[_Union[_struct_pb2.Struct, _Mapping]] = ..., extensions: _Optional[_Iterable[str]] = ...) -> None: ...

class TaskStatusUpdateEvent(_message.Message):
    __slots__ = ("task_id", "context_id", "status", "final", "metadata")
    TASK_ID_FIELD_NUMBER: _ClassVar[int]
    CONTEXT_ID_FIELD_NUMBER: _ClassVar[int]
    STATUS_FIELD_NUMBER: _ClassVar[int]
    FINAL_FIELD_NUMBER: _ClassVar[int]
    METADATA_FIELD_NUMBER: _ClassVar[int]
    task_id: str
    context_id: str
    status: TaskStatus
    final: bool
    metadata: _struct_pb2.Struct
    def __init__(self, task_id: _Optional[str] = ..., context_id: _Optional[str] = ..., status: _Optional[_Union[TaskStatus, _Mapping]] = ..., final: bool = ..., metadata: _Optional[_Union[_struct_pb2.Struct, _Mapping]] = ...) -> None: ...

class TaskArtifactUpdateEvent(_message.Message):
    __slots__ = ("task_id", "context_id", "artifact", "append", "last_chunk", "metadata")
    TASK_ID_FIELD_NUMBER: _ClassVar[int]
    CONTEXT_ID_FIELD_NUMBER: _ClassVar[int]
    ARTIFACT_FIELD_NUMBER: _ClassVar[int]
    APPEND_FIELD_NUMBER: _ClassVar[int]
    LAST_CHUNK_FIELD_NUMBER: _ClassVar[int]
    METADATA_FIELD_NUMBER: _ClassVar[int]
    task_id: str
    context_id: str
    artifact: Artifact
    append: bool
    last_chunk: bool
    metadata: _struct_pb2.Struct
    def __init__(self, task_id: _Optional[str] = ..., context_id: _Optional[str] = ..., artifact: _Optional[_Union[Artifact, _Mapping]] = ..., append: bool = ..., last_chunk: bool = ..., metadata: _Optional[_Union[_struct_pb2.Struct, _Mapping]] = ...) -> None: ...

class PushNotificationConfig(_message.Message):
    __slots__ = ("id", "url", "token", "authentication")
    ID_FIELD_NUMBER: _ClassVar[int]
    URL_FIELD_NUMBER: _ClassVar[int]
    TOKEN_FIELD_NUMBER: _ClassVar[int]
    AUTHENTICATION_FIELD_NUMBER: _ClassVar[int]
    id: str
    url: str
    token: str
    authentication: AuthenticationInfo
    def __init__(self, id: _Optional[str] = ..., url: _Optional[str] = ..., token: _Optional[str] = ..., authentication: _Optional[_Union[AuthenticationInfo, _Mapping]] = ...) -> None: ...

class AuthenticationInfo(_message.Message):
    __slots__ = ("schemes", "credentials")
    SCHEMES_FIELD_NUMBER: _ClassVar[int]
    CREDENTIALS_FIELD_NUMBER: _ClassVar[int]
    schemes: _containers.RepeatedScalarFieldContainer[str]
    credentials: str
    def __init__(self, schemes: _Optional[_Iterable[str]] = ..., credentials: _Optional[str] = ...) -> None: ...

class AgentInterface(_message.Message):
    __slots__ = ("url", "transport")
    URL_FIELD_NUMBER: _ClassVar[int]
    TRANSPORT_FIELD_NUMBER: _ClassVar[int]
    url: str
    transport: str
    def __init__(self, url: _Optional[str] = ..., transport: _Optional[str] = ...) -> None: ...

class AgentCard(_message.Message):
    __slots__ = ("protocol_version", "name", "description", "url", "preferred_transport", "additional_interfaces", "provider", "version", "documentation_url", "capabilities", "security_schemes", "security", "default_input_modes", "default_output_modes", "skills", "supports_authenticated_extended_card", "signatures")
    class SecuritySchemesEntry(_message.Message):
        __slots__ = ("key", "value")
        KEY_FIELD_NUMBER: _ClassVar[int]
        VALUE_FIELD_NUMBER: _ClassVar[int]
        key: str
        value: SecurityScheme
        def __init__(self, key: _Optional[str] = ..., value: _Optional[_Union[SecurityScheme, _Mapping]] = ...) -> None: ...
    PROTOCOL_VERSION_FIELD_NUMBER: _ClassVar[int]
    NAME_FIELD_NUMBER: _ClassVar[int]
    DESCRIPTION_FIELD_NUMBER: _ClassVar[int]
    URL_FIELD_NUMBER: _ClassVar[int]
    PREFERRED_TRANSPORT_FIELD_NUMBER: _ClassVar[int]
    ADDITIONAL_INTERFACES_FIELD_NUMBER: _ClassVar[int]
    PROVIDER_FIELD_NUMBER: _ClassVar[int]
    VERSION_FIELD_NUMBER: _ClassVar[int]
    DOCUMENTATION_URL_FIELD_NUMBER: _ClassVar[int]
    CAPABILITIES_FIELD_NUMBER: _ClassVar[int]
    SECURITY_SCHEMES_FIELD_NUMBER: _ClassVar[int]
    SECURITY_FIELD_NUMBER: _ClassVar[int]
    DEFAULT_INPUT_MODES_FIELD_NUMBER: _ClassVar[int]
    DEFAULT_OUTPUT_MODES_FIELD_NUMBER: _ClassVar[int]
    SKILLS_FIELD_NUMBER: _ClassVar[int]
    SUPPORTS_AUTHENTICATED_EXTENDED_CARD_FIELD_NUMBER: _ClassVar[int]
    SIGNATURES_FIELD_NUMBER: _ClassVar[int]
    protocol_version: str
    name: str
    description: str
    url: str
    preferred_transport: str
    additional_interfaces: _containers.RepeatedCompositeFieldContainer[AgentInterface]
    provider: AgentProvider
    version: str
    documentation_url: str
    capabilities: AgentCapabilities
    security_schemes: _containers.MessageMap[str, SecurityScheme]
    security: _containers.RepeatedCompositeFieldContainer[Security]
    default_input_modes: _containers.RepeatedScalarFieldContainer[str]
    default_output_modes: _containers.RepeatedScalarFieldContainer[str]
    skills: _containers.RepeatedCompositeFieldContainer[AgentSkill]
    supports_authenticated_extended_card: bool
    signatures: _containers.RepeatedCompositeFieldContainer[AgentCardSignature]
    def __init__(self, protocol_version: _Optional[str] = ..., name: _Optional[str] = ..., description: _Optional[str] = ..., url: _Optional[str] = ..., preferred_transport: _Optional[str] = ..., additional_interfaces: _Optional[_Iterable[_Union[AgentInterface, _Mapping]]] = ..., provider: _Optional[_Union[AgentProvider, _Mapping]] = ..., version: _Optional[str] = ..., documentation_url: _Optional[str] = ..., capabilities: _Optional[_Union[AgentCapabilities, _Mapping]] = ..., security_schemes: _Optional[_Mapping[str, SecurityScheme]] = ..., security: _Optional[_Iterable[_Union[Security, _Mapping]]] = ..., default_input_modes: _Optional[_Iterable[str]] = ..., default_output_modes: _Optional[_Iterable[str]] = ..., skills: _Optional[_Iterable[_Union[AgentSkill, _Mapping]]] = ..., supports_authenticated_extended_card: bool = ..., signatures: _Optional[_Iterable[_Union[AgentCardSignature, _Mapping]]] = ...) -> None: ...

class AgentProvider(_message.Message):
    __slots__ = ("url", "organization")
    URL_FIELD_NUMBER: _ClassVar[int]
    ORGANIZATION_FIELD_NUMBER: _ClassVar[int]
    url: str
    organization: str
    def __init__(self, url: _Optional[str] = ..., organization: _Optional[str] = ...) -> None: ...

class AgentCapabilities(_message.Message):
    __slots__ = ("streaming", "push_notifications", "extensions")
    STREAMING_FIELD_NUMBER: _ClassVar[int]
    PUSH_NOTIFICATIONS_FIELD_NUMBER: _ClassVar[int]
    EXTENSIONS_FIELD_NUMBER: _ClassVar[int]
    streaming: bool
    push_notifications: bool
    extensions: _containers.RepeatedCompositeFieldContainer[AgentExtension]
    def __init__(self, streaming: bool = ..., push_notifications: bool = ..., extensions: _Optional[_Iterable[_Union[AgentExtension, _Mapping]]] = ...) -> None: ...

class AgentExtension(_message.Message):
    __slots__ = ("uri", "description", "required", "params")
    URI_FIELD_NUMBER: _ClassVar[int]
    DESCRIPTION_FIELD_NUMBER: _ClassVar[int]
    REQUIRED_FIELD_NUMBER: _ClassVar[int]
    PARAMS_FIELD_NUMBER: _ClassVar[int]
    uri: str
    description: str
    required: bool
    params: _struct_pb2.Struct
    def __init__(self, uri: _Optional[str] = ..., description: _Optional[str] = ..., required: bool = ..., params: _Optional[_Union[_struct_pb2.Struct, _Mapping]] = ...) -> None: ...

class AgentSkill(_message.Message):
    __slots__ = ("id", "name", "description", "tags", "examples", "input_modes", "output_modes", "security")
    ID_FIELD_NUMBER: _ClassVar[int]
    NAME_FIELD_NUMBER: _ClassVar[int]
    DESCRIPTION_FIELD_NUMBER: _ClassVar[int]
    TAGS_FIELD_NUMBER: _ClassVar[int]
    EXAMPLES_FIELD_NUMBER: _ClassVar[int]
    INPUT_MODES_FIELD_NUMBER: _ClassVar[int]
    OUTPUT_MODES_FIELD_NUMBER: _ClassVar[int]
    SECURITY_FIELD_NUMBER: _ClassVar[int]
    id: str
    name: str
    description: str
    tags: _containers.RepeatedScalarFieldContainer[str]
    examples: _containers.RepeatedScalarFieldContainer[str]
    input_modes: _containers.RepeatedScalarFieldContainer[str]
    output_modes: _containers.RepeatedScalarFieldContainer[str]
    security: _containers.RepeatedCompositeFieldContainer[Security]
    def __init__(self, id: _Optional[str] = ..., name: _Optional[str] = ..., description: _Optional[str] = ..., tags: _Optional[_Iterable[str]] = ..., examples: _Optional[_Iterable[str]] = ..., input_modes: _Optional[_Iterable[str]] = ..., output_modes: _Optional[_Iterable[str]] = ..., security: _Optional[_Iterable[_Union[Security, _Mapping]]] = ...) -> None: ...

class AgentCardSignature(_message.Message):
    __slots__ = ("protected", "signature", "header")
    PROTECTED_FIELD_NUMBER: _ClassVar[int]
    SIGNATURE_FIELD_NUMBER: _ClassVar[int]
    HEADER_FIELD_NUMBER: _ClassVar[int]
    protected: str
    signature: str
    header: _struct_pb2.Struct
    def __init__(self, protected: _Optional[str] = ..., signature: _Optional[str] = ..., header: _Optional[_Union[_struct_pb2.Struct, _Mapping]] = ...) -> None: ...

class TaskPushNotificationConfig(_message.Message):
    __slots__ = ("name", "push_notification_config")
    NAME_FIELD_NUMBER: _ClassVar[int]
    PUSH_NOTIFICATION_CONFIG_FIELD_NUMBER: _ClassVar[int]
    name: str
    push_notification_config: PushNotificationConfig
    def __init__(self, name: _Optional[str] = ..., push_notification_config: _Optional[_Union[PushNotificationConfig, _Mapping]] = ...) -> None: ...

class StringList(_message.Message):
    __slots__ = ("list",)
    LIST_FIELD_NUMBER: _ClassVar[int]
    list: _containers.RepeatedScalarFieldContainer[str]
    def __init__(self, list: _Optional[_Iterable[str]] = ...) -> None: ...

class Security(_message.Message):
    __slots__ = ("schemes",)
    class SchemesEntry(_message.Message):
        __slots__ = ("key", "value")
        KEY_FIELD_NUMBER: _ClassVar[int]
        VALUE_FIELD_NUMBER: _ClassVar[int]
        key: str
        value: StringList
        def __init__(self, key: _Optional[str] = ..., value: _Optional[_Union[StringList, _Mapping]] = ...) -> None: ...
    SCHEMES_FIELD_NUMBER: _ClassVar[int]
    schemes: _containers.MessageMap[str, StringList]
    def __init__(self, schemes: _Optional[_Mapping[str, StringList]] = ...) -> None: ...

class SecurityScheme(_message.Message):
    __slots__ = ("api_key_security_scheme", "http_auth_security_scheme", "oauth2_security_scheme", "open_id_connect_security_scheme", "mtls_security_scheme")
    API_KEY_SECURITY_SCHEME_FIELD_NUMBER: _ClassVar[int]
    HTTP_AUTH_SECURITY_SCHEME_FIELD_NUMBER: _ClassVar[int]
    OAUTH2_SECURITY_SCHEME_FIELD_NUMBER: _ClassVar[int]
    OPEN_ID_CONNECT_SECURITY_SCHEME_FIELD_NUMBER: _ClassVar[int]
    MTLS_SECURITY_SCHEME_FIELD_NUMBER: _ClassVar[int]
    api_key_security_scheme: APIKeySecurityScheme
    http_auth_security_scheme: HTTPAuthSecurityScheme
    oauth2_security_scheme: OAuth2SecurityScheme
    open_id_connect_security_scheme: OpenIdConnectSecurityScheme
    mtls_security_scheme: MutualTlsSecurityScheme
    def __init__(self, api_key_security_scheme: _Optional[_Union[APIKeySecurityScheme, _Mapping]] = ..., http_auth_security_scheme: _Optional[_Union[HTTPAuthSecurityScheme, _Mapping]] = ..., oauth2_security_scheme: _Optional[_Union[OAuth2SecurityScheme, _Mapping]] = ..., open_id_connect_security_scheme: _Optional[_Union[OpenIdConnectSecurityScheme, _Mapping]] = ..., mtls_security_scheme: _Optional[_Union[MutualTlsSecurityScheme, _Mapping]] = ...) -> None: ...

class APIKeySecurityScheme(_message.Message):
    __slots__ = ("description", "location", "name")
    DESCRIPTION_FIELD_NUMBER: _ClassVar[int]
    LOCATION_FIELD_NUMBER: _ClassVar[int]
    NAME_FIELD_NUMBER: _ClassVar[int]
    description: str
    location: str
    name: str
    def __init__(self, description: _Optional[str] = ..., location: _Optional[str] = ..., name: _Optional[str] = ...) -> None: ...

class HTTPAuthSecurityScheme(_message.Message):
    __slots__ = ("description", "scheme", "bearer_format")
    DESCRIPTION_FIELD_NUMBER: _ClassVar[int]
    SCHEME_FIELD_NUMBER: _ClassVar[int]
    BEARER_FORMAT_FIELD_NUMBER: _ClassVar[int]
    description: str
    scheme: str
    bearer_format: str
    def __init__(self, description: _Optional[str] = ..., scheme: _Optional[str] = ..., bearer_format: _Optional[str] = ...) -> None: ...

class OAuth2SecurityScheme(_message.Message):
    __slots__ = ("description", "flows", "oauth2_metadata_url")
    DESCRIPTION_FIELD_NUMBER: _ClassVar[int]
    FLOWS_FIELD_NUMBER: _ClassVar[int]
    OAUTH2_METADATA_URL_FIELD_NUMBER: _ClassVar[int]
    description: str
    flows: OAuthFlows
    oauth2_metadata_url: str
    def __init__(self, description: _Optional[str] = ..., flows: _Optional[_Union[OAuthFlows, _Mapping]] = ..., oauth2_metadata_url: _Optional[str] = ...) -> None: ...

class OpenIdConnectSecurityScheme(_message.Message):
    __slots__ = ("description", "open_id_connect_url")
    DESCRIPTION_FIELD_NUMBER: _ClassVar[int]
    OPEN_ID_CONNECT_URL_FIELD_NUMBER: _ClassVar[int]
    description: str
    open_id_connect_url: str
    def __init__(self, description: _Optional[str] = ..., open_id_connect_url: _Optional[str] = ...) -> None: ...

class MutualTlsSecurityScheme(_message.Message):
    __slots__ = ("description",)
    DESCRIPTION_FIELD_NUMBER: _ClassVar[int]
    description: str
    def __init__(self, description: _Optional[str] = ...) -> None: ...

class OAuthFlows(_message.Message):
    __slots__ = ("authorization_code", "client_credentials", "implicit", "password")
    AUTHORIZATION_CODE_FIELD_NUMBER: _ClassVar[int]
    CLIENT_CREDENTIALS_FIELD_NUMBER: _ClassVar[int]
    IMPLICIT_FIELD_NUMBER: _ClassVar[int]
    PASSWORD_FIELD_NUMBER: _ClassVar[int]
    authorization_code: AuthorizationCodeOAuthFlow
    client_credentials: ClientCredentialsOAuthFlow
    implicit: ImplicitOAuthFlow
    password: PasswordOAuthFlow
    def __init__(self, authorization_code: _Optional[_Union[AuthorizationCodeOAuthFlow, _Mapping]] = ..., client_credentials: _Optional[_Union[ClientCredentialsOAuthFlow, _Mapping]] = ..., implicit: _Optional[_Union[ImplicitOAuthFlow, _Mapping]] = ..., password: _Optional[_Union[PasswordOAuthFlow, _Mapping]] = ...) -> None: ...

class AuthorizationCodeOAuthFlow(_message.Message):
    __slots__ = ("authorization_url", "token_url", "refresh_url", "scopes")
    class ScopesEntry(_message.Message):
        __slots__ = ("key", "value")
        KEY_FIELD_NUMBER: _ClassVar[int]
        VALUE_FIELD_NUMBER: _ClassVar[int]
        key: str
        value: str
        def __init__(self, key: _Optional[str] = ..., value: _Optional[str] = ...) -> None: ...
    AUTHORIZATION_URL_FIELD_NUMBER: _ClassVar[int]
    TOKEN_URL_FIELD_NUMBER: _ClassVar[int]
    REFRESH_URL_FIELD_NUMBER: _ClassVar[int]
    SCOPES_FIELD_NUMBER: _ClassVar[int]
    authorization_url: str
    token_url: str
    refresh_url: str
    scopes: _containers.ScalarMap[str, str]
    def __init__(self, authorization_url: _Optional[str] = ..., token_url: _Optional[str] = ..., refresh_url: _Optional[str] = ..., scopes: _Optional[_Mapping[str, str]] = ...) -> None: ...

class ClientCredentialsOAuthFlow(_message.Message):
    __slots__ = ("token_url", "refresh_url", "scopes")
    class ScopesEntry(_message.Message):
        __slots__ = ("key", "value")
        KEY_FIELD_NUMBER: _ClassVar[int]
        VALUE_FIELD_NUMBER: _ClassVar[int]
        key: str
        value: str
        def __init__(self, key: _Optional[str] = ..., value: _Optional[str] = ...) -> None: ...
    TOKEN_URL_FIELD_NUMBER: _ClassVar[int]
    REFRESH_URL_FIELD_NUMBER: _ClassVar[int]
    SCOPES_FIELD_NUMBER: _ClassVar[int]
    token_url: str
    refresh_url: str
    scopes: _containers.ScalarMap[str, str]
    def __init__(self, token_url: _Optional[str] = ..., refresh_url: _Optional[str] = ..., scopes: _Optional[_Mapping[str, str]] = ...) -> None: ...

class ImplicitOAuthFlow(_message.Message):
    __slots__ = ("authorization_url", "refresh_url", "scopes")
    class ScopesEntry(_message.Message):
        __slots__ = ("key", "value")
        KEY_FIELD_NUMBER: _ClassVar[int]
        VALUE_FIELD_NUMBER: _ClassVar[int]
        key: str
        value: str
        def __init__(self, key: _Optional[str] = ..., value: _Optional[str] = ...) -> None: ...
    AUTHORIZATION_URL_FIELD_NUMBER: _ClassVar[int]
    REFRESH_URL_FIELD_NUMBER: _ClassVar[int]
    SCOPES_FIELD_NUMBER: _ClassVar[int]
    authorization_url: str
    refresh_url: str
    scopes: _containers.ScalarMap[str, str]
    def __init__(self, authorization_url: _Optional[str] = ..., refresh_url: _Optional[str] = ..., scopes: _Optional[_Mapping[str, str]] = ...) -> None: ...

class PasswordOAuthFlow(_message.Message):
    __slots__ = ("token_url", "refresh_url", "scopes")
    class ScopesEntry(_message.Message):
        __slots__ = ("key", "value")
        KEY_FIELD_NUMBER: _ClassVar[int]
        VALUE_FIELD_NUMBER: _ClassVar[int]
        key: str
        value: str
        def __init__(self, key: _Optional[str] = ..., value: _Optional[str] = ...) -> None: ...
    TOKEN_URL_FIELD_NUMBER: _ClassVar[int]
    REFRESH_URL_FIELD_NUMBER: _ClassVar[int]
    SCOPES_FIELD_NUMBER: _ClassVar[int]
    token_url: str
    refresh_url: str
    scopes: _containers.ScalarMap[str, str]
    def __init__(self, token_url: _Optional[str] = ..., refresh_url: _Optional[str] = ..., scopes: _Optional[_Mapping[str, str]] = ...) -> None: ...

class SendMessageRequest(_message.Message):
    __slots__ = ("request", "configuration", "metadata")
    REQUEST_FIELD_NUMBER: _ClassVar[int]
    CONFIGURATION_FIELD_NUMBER: _ClassVar[int]
    METADATA_FIELD_NUMBER: _ClassVar[int]
    request: Message
    configuration: SendMessageConfiguration
    metadata: _struct_pb2.Struct
    def __init__(self, request: _Optional[_Union[Message, _Mapping]] = ..., configuration: _Optional[_Union[SendMessageConfiguration, _Mapping]] = ..., metadata: _Optional[_Union[_struct_pb2.Struct, _Mapping]] = ...) -> None: ...

class GetTaskRequest(_message.Message):
    __slots__ = ("name", "history_length")
    NAME_FIELD_NUMBER: _ClassVar[int]
    HISTORY_LENGTH_FIELD_NUMBER: _ClassVar[int]
    name: str
    history_length: int
    def __init__(self, name: _Optional[str] = ..., history_length: _Optional[int] = ...) -> None: ...

class CancelTaskRequest(_message.Message):
    __slots__ = ("name",)
    NAME_FIELD_NUMBER: _ClassVar[int]
    name: str
    def __init__(self, name: _Optional[str] = ...) -> None: ...

class GetTaskPushNotificationConfigRequest(_message.Message):
    __slots__ = ("name",)
    NAME_FIELD_NUMBER: _ClassVar[int]
    name: str
    def __init__(self, name: _Optional[str] = ...) -> None: ...

class DeleteTaskPushNotificationConfigRequest(_message.Message):
    __slots__ = ("name",)
    NAME_FIELD_NUMBER: _ClassVar[int]
    name: str
    def __init__(self, name: _Optional[str] = ...) -> None: ...

class CreateTaskPushNotificationConfigRequest(_message.Message):
    __slots__ = ("parent", "config_id", "config")
    PARENT_FIELD_NUMBER: _ClassVar[int]
    CONFIG_ID_FIELD_NUMBER: _ClassVar[int]
    CONFIG_FIELD_NUMBER: _ClassVar[int]
    parent: str
    config_id: str
    config: TaskPushNotificationConfig
    def __init__(self, parent: _Optional[str] = ..., config_id: _Optional[str] = ..., config: _Optional[_Union[TaskPushNotificationConfig, _Mapping]] = ...) -> None: ...

class TaskSubscriptionRequest(_message.Message):
    __slots__ = ("name",)
    NAME_FIELD_NUMBER: _ClassVar[int]
    name: str
    def __init__(self, name: _Optional[str] = ...) -> None: ...

class ListTaskPushNotificationConfigRequest(_message.Message):
    __slots__ = ("parent", "page_size", "page_token")
    PARENT_FIELD_NUMBER: _ClassVar[int]
    PAGE_SIZE_FIELD_NUMBER: _ClassVar[int]
    PAGE_TOKEN_FIELD_NUMBER: _ClassVar[int]
    parent: str
    page_size: int
    page_token: str
    def __init__(self, parent: _Optional[str] = ..., page_size: _Optional[int] = ..., page_token: _Optional[str] = ...) -> None: ...

class GetAgentCardRequest(_message.Message):
    __slots__ = ()
    def __init__(self) -> None: ...

class SendMessageResponse(_message.Message):
    __slots__ = ("task", "msg")
    TASK_FIELD_NUMBER: _ClassVar[int]
    MSG_FIELD_NUMBER: _ClassVar[int]
    task: Task
    msg: Message
    def __init__(self, task: _Optional[_Union[Task, _Mapping]] = ..., msg: _Optional[_Union[Message, _Mapping]] = ...) -> None: ...

class StreamResponse(_message.Message):
    __slots__ = ("task", "msg", "status_update", "artifact_update")
    TASK_FIELD_NUMBER: _ClassVar[int]
    MSG_FIELD_NUMBER: _ClassVar[int]
    STATUS_UPDATE_FIELD_NUMBER: _ClassVar[int]
    ARTIFACT_UPDATE_FIELD_NUMBER: _ClassVar[int]
    task: Task
    msg: Message
    status_update: TaskStatusUpdateEvent
    artifact_update: TaskArtifactUpdateEvent
    def __init__(self, task: _Optional[_Union[Task, _Mapping]] = ..., msg: _Optional[_Union[Message, _Mapping]] = ..., status_update: _Optional[_Union[TaskStatusUpdateEvent, _Mapping]] = ..., artifact_update: _Optional[_Union[TaskArtifactUpdateEvent, _Mapping]] = ...) -> None: ...

class ListTaskPushNotificationConfigResponse(_message.Message):
    __slots__ = ("configs", "next_page_token")
    CONFIGS_FIELD_NUMBER: _ClassVar[int]
    NEXT_PAGE_TOKEN_FIELD_NUMBER: _ClassVar[int]
    configs: _containers.RepeatedCompositeFieldContainer[TaskPushNotificationConfig]
    next_page_token: str
    def __init__(self, configs: _Optional[_Iterable[_Union[TaskPushNotificationConfig, _Mapping]]] = ..., next_page_token: _Optional[str] = ...) -> None: ...

================
File: src/a2a/server/agent_execution/__init__.py
================
"""Components for executing agent logic within the A2A server."""
⋮----
__all__ = [

================
File: src/a2a/server/agent_execution/agent_executor.py
================
class AgentExecutor(ABC)
⋮----
"""Agent Executor interface.

    Implementations of this interface contain the core logic of the agent,
    executing tasks based on requests and publishing updates to an event queue.
    """
⋮----
"""Execute the agent's logic for a given request context.

        The agent should read necessary information from the `context` and
        publish `Task` or `Message` events, or `TaskStatusUpdateEvent` /
        `TaskArtifactUpdateEvent` to the `event_queue`. This method should
        return once the agent's execution for this request is complete or
        yields control (e.g., enters an input-required state).

        Args:
            context: The request context containing the message, task ID, etc.
            event_queue: The queue to publish events to.
        """
⋮----
"""Request the agent to cancel an ongoing task.

        The agent should attempt to stop the task identified by the task_id
        in the context and publish a `TaskStatusUpdateEvent` with state
        `TaskState.canceled` to the `event_queue`.

        Args:
            context: The request context containing the task ID to cancel.
            event_queue: The queue to publish the cancellation status update to.
        """

================
File: src/a2a/server/agent_execution/context.py
================
class RequestContext
⋮----
"""Request Context.

    Holds information about the current request being processed by the server,
    including the incoming message, task and context identifiers, and related
    tasks.
    """
⋮----
def __init__(  # noqa: PLR0913
⋮----
"""Initializes the RequestContext.

        Args:
            request: The incoming `MessageSendParams` request payload.
            task_id: The ID of the task explicitly provided in the request or path.
            context_id: The ID of the context explicitly provided in the request or path.
            task: The existing `Task` object retrieved from the store, if any.
            related_tasks: A list of other tasks related to the current request (e.g., for tool use).
            call_context: The server call context associated with this request.
        """
⋮----
related_tasks = []
⋮----
# If the task id and context id were provided, make sure they
# match the request. Otherwise, create them
⋮----
def get_user_input(self, delimiter: str = '\n') -> str
⋮----
"""Extracts text content from the user's message parts.

        Args:
            delimiter: The string to use when joining multiple text parts.

        Returns:
            A single string containing all text content from the user message,
            joined by the specified delimiter. Returns an empty string if no
            user message is present or if it contains no text parts.
        """
⋮----
def attach_related_task(self, task: Task) -> None
⋮----
"""Attaches a related task to the context.

        This is useful for scenarios like tool execution where a new task
        might be spawned.

        Args:
            task: The `Task` object to attach.
        """
⋮----
@property
    def message(self) -> Message | None
⋮----
"""The incoming `Message` object from the request, if available."""
⋮----
@property
    def related_tasks(self) -> list[Task]
⋮----
"""A list of tasks related to the current request."""
⋮----
@property
    def current_task(self) -> Task | None
⋮----
"""The current `Task` object being processed."""
⋮----
@current_task.setter
    def current_task(self, task: Task) -> None
⋮----
"""Sets the current task object."""
⋮----
@property
    def task_id(self) -> str | None
⋮----
"""The ID of the task associated with this context."""
⋮----
@property
    def context_id(self) -> str | None
⋮----
"""The ID of the conversation context associated with this task."""
⋮----
@property
    def configuration(self) -> MessageSendConfiguration | None
⋮----
"""The `MessageSendConfiguration` from the request, if available."""
⋮----
@property
    def call_context(self) -> ServerCallContext | None
⋮----
"""The server call context associated with this request."""
⋮----
@property
    def metadata(self) -> dict[str, Any]
⋮----
"""Metadata associated with the request, if available."""
⋮----
def add_activated_extension(self, uri: str) -> None
⋮----
"""Add an extension to the set of activated extensions for this request.

        This causes the extension to be indicated back to the client in the
        response.
        """
⋮----
@property
    def requested_extensions(self) -> set[str]
⋮----
"""Extensions that the client requested to activate."""
⋮----
def _check_or_generate_task_id(self) -> None
⋮----
"""Ensures a task ID is present, generating one if necessary."""
⋮----
def _check_or_generate_context_id(self) -> None
⋮----
"""Ensures a context ID is present, generating one if necessary."""

================
File: src/a2a/server/agent_execution/request_context_builder.py
================
class RequestContextBuilder(ABC)
⋮----
"""Builds request context to be supplied to agent executor."""

================
File: src/a2a/server/agent_execution/simple_request_context_builder.py
================
class SimpleRequestContextBuilder(RequestContextBuilder)
⋮----
"""Builds request context and populates referred tasks."""
⋮----
"""Initializes the SimpleRequestContextBuilder.

        Args:
            should_populate_referred_tasks: If True, the builder will fetch tasks
                referenced in `params.message.reference_task_ids` and populate the
                `related_tasks` field in the RequestContext. Defaults to False.
            task_store: The TaskStore instance to use for fetching referred tasks.
                Required if `should_populate_referred_tasks` is True.
        """
⋮----
"""Builds the request context for an agent execution.

        This method assembles the RequestContext object. If the builder was
        initialized with `should_populate_referred_tasks=True`, it fetches all tasks
        referenced in `params.message.reference_task_ids` from the `task_store`.

        Args:
            params: The parameters of the incoming message send request.
            task_id: The ID of the task being executed.
            context_id: The ID of the current execution context.
            task: The primary task object associated with the request.
            context: The server call context, containing metadata about the call.

        Returns:
            An instance of RequestContext populated with the provided information
            and potentially a list of related tasks.
        """
related_tasks: list[Task] | None = None
⋮----
tasks = await asyncio.gather(
related_tasks = [x for x in tasks if x is not None]

================
File: src/a2a/server/apps/jsonrpc/__init__.py
================
"""A2A JSON-RPC Applications."""
⋮----
__all__ = [

================
File: src/a2a/server/apps/jsonrpc/fastapi_app.py
================
_package_fastapi_installed = True
⋮----
FastAPI = Any
⋮----
_package_fastapi_installed = False
⋮----
logger = logging.getLogger(__name__)
⋮----
class A2AFastAPI(FastAPI)
⋮----
"""A FastAPI application that adds A2A-specific OpenAPI components."""
⋮----
_a2a_components_added: bool = False
⋮----
def openapi(self) -> dict[str, Any]
⋮----
"""Generates the OpenAPI schema for the application."""
openapi_schema = super().openapi()
⋮----
a2a_request_schema = A2ARequest.model_json_schema(
defs = a2a_request_schema.pop('$defs', {})
component_schemas = openapi_schema.setdefault(
⋮----
class A2AFastAPIApplication(JSONRPCApplication)
⋮----
"""A FastAPI application implementing the A2A protocol server endpoints.

    Handles incoming JSON-RPC requests, routes them to the appropriate
    handler methods, and manages response generation including Server-Sent Events
    (SSE).
    """
⋮----
def __init__(  # noqa: PLR0913
⋮----
"""Initializes the A2AFastAPIApplication.

        Args:
            agent_card: The AgentCard describing the agent's capabilities.
            http_handler: The handler instance responsible for processing A2A
              requests via http.
            extended_agent_card: An optional, distinct AgentCard to be served
              at the authenticated extended card endpoint.
            context_builder: The CallContextBuilder used to construct the
              ServerCallContext passed to the http_handler. If None, no
              ServerCallContext is passed.
            card_modifier: An optional callback to dynamically modify the public
              agent card before it is served.
            extended_card_modifier: An optional callback to dynamically modify
              the extended agent card before it is served. It receives the
              call context.
        """
⋮----
"""Adds the routes to the FastAPI application.

        Args:
            app: The FastAPI application to add the routes to.
            agent_card_url: The URL for the agent card endpoint.
            rpc_url: The URL for the A2A JSON-RPC endpoint.
            extended_agent_card_url: The URL for the authenticated extended agent card endpoint.
        """
⋮----
# For backward compatibility, serve the agent card at the deprecated path as well.
# TODO: remove in a future release
⋮----
"""Builds and returns the FastAPI application instance.

        Args:
            agent_card_url: The URL for the agent card endpoint.
            rpc_url: The URL for the A2A JSON-RPC endpoint.
            extended_agent_card_url: The URL for the authenticated extended agent card endpoint.
            **kwargs: Additional keyword arguments to pass to the FastAPI constructor.

        Returns:
            A configured FastAPI application instance.
        """
app = A2AFastAPI(**kwargs)

================
File: src/a2a/server/apps/jsonrpc/jsonrpc_app.py
================
logger = logging.getLogger(__name__)
⋮----
_package_starlette_installed = True
⋮----
FastAPI = Any
⋮----
_package_starlette_installed = False
# Provide placeholder types for runtime type hinting when dependencies are not installed.
# These will not be used if the code path that needs them is guarded by _http_server_installed.
EventSourceResponse = Any
Starlette = Any
BaseUser = Any
HTTPException = Any
Request = Any
JSONResponse = Any
Response = Any
HTTP_413_REQUEST_ENTITY_TOO_LARGE = Any
⋮----
class StarletteUserProxy(A2AUser)
⋮----
"""Adapts the Starlette User class to the A2A user representation."""
⋮----
def __init__(self, user: BaseUser)
⋮----
@property
    def is_authenticated(self) -> bool
⋮----
"""Returns whether the current user is authenticated."""
⋮----
@property
    def user_name(self) -> str
⋮----
"""Returns the user name of the current user."""
⋮----
class CallContextBuilder(ABC)
⋮----
"""A class for building ServerCallContexts using the Starlette Request."""
⋮----
@abstractmethod
    def build(self, request: Request) -> ServerCallContext
⋮----
"""Builds a ServerCallContext from a Starlette Request."""
⋮----
class DefaultCallContextBuilder(CallContextBuilder)
⋮----
"""A default implementation of CallContextBuilder."""
⋮----
def build(self, request: Request) -> ServerCallContext
⋮----
"""Builds a ServerCallContext from a Starlette Request.

        Args:
            request: The incoming Starlette Request object.

        Returns:
            A ServerCallContext instance populated with user and state
            information from the request.
        """
user: A2AUser = UnauthenticatedUser()
state = {}
⋮----
user = StarletteUserProxy(request.user)
⋮----
class JSONRPCApplication(ABC)
⋮----
"""Base class for A2A JSONRPC applications.

    Handles incoming JSON-RPC requests, routes them to the appropriate
    handler methods, and manages response generation including Server-Sent Events
    (SSE).
    """
⋮----
def __init__(  # noqa: PLR0913
⋮----
"""Initializes the JSONRPCApplication.

        Args:
            agent_card: The AgentCard describing the agent's capabilities.
            http_handler: The handler instance responsible for processing A2A
              requests via http.
            extended_agent_card: An optional, distinct AgentCard to be served
              at the authenticated extended card endpoint.
            context_builder: The CallContextBuilder used to construct the
              ServerCallContext passed to the http_handler. If None, no
              ServerCallContext is passed.
            card_modifier: An optional callback to dynamically modify the public
              agent card before it is served.
            extended_card_modifier: An optional callback to dynamically modify
              the extended agent card before it is served. It receives the
              call context.
        """
⋮----
"""Creates a Starlette JSONResponse for a JSON-RPC error.

        Logs the error based on its type.

        Args:
            request_id: The ID of the request that caused the error.
            error: The `JSONRPCError` or `A2AError` object.

        Returns:
            A `JSONResponse` object formatted as a JSON-RPC error response.
        """
error_resp = JSONRPCErrorResponse(
⋮----
log_level = (
⋮----
async def _handle_requests(self, request: Request) -> Response:  # noqa: PLR0911
⋮----
"""Handles incoming POST requests to the main A2A endpoint.

        Parses the request body as JSON, validates it against A2A request types,
        dispatches it to the appropriate handler method, and returns the response.
        Handles JSON parsing errors, validation errors, and other exceptions,
        returning appropriate JSON-RPC error responses.

        Args:
            request: The incoming Starlette Request object.

        Returns:
            A Starlette Response object (JSONResponse or EventSourceResponse).

        Raises:
            (Implicitly handled): Various exceptions are caught and converted
            into JSON-RPC error responses by this method.
        """
request_id = None
body = None
⋮----
body = await request.json()
⋮----
request_id = body.get('id')
⋮----
# First, validate the basic JSON-RPC structure. This is crucial
# because the A2ARequest model is a discriminated union where some
# request types have default values for the 'method' field
⋮----
a2a_request = A2ARequest.model_validate(body)
⋮----
call_context = self._context_builder.build(request)
⋮----
request_id = a2a_request.root.id
request_obj = a2a_request.root
⋮----
"""Processes streaming requests (message/stream or tasks/resubscribe).

        Args:
            request_id: The ID of the request.
            a2a_request: The validated A2ARequest object.
            context: The ServerCallContext for the request.

        Returns:
            An `EventSourceResponse` object to stream results to the client.
        """
⋮----
handler_result: Any = None
⋮----
handler_result = self.handler.on_message_send_stream(
⋮----
handler_result = self.handler.on_resubscribe_to_task(
⋮----
"""Processes non-streaming requests (message/send, tasks/get, tasks/cancel, tasks/pushNotificationConfig/*).

        Args:
            request_id: The ID of the request.
            a2a_request: The validated A2ARequest object.
            context: The ServerCallContext for the request.

        Returns:
            A `JSONResponse` object containing the result or error.
        """
⋮----
handler_result = await self.handler.on_message_send(
⋮----
handler_result = await self.handler.on_cancel_task(
⋮----
handler_result = await self.handler.on_get_task(
⋮----
handler_result = (
⋮----
error = UnsupportedOperationError(
handler_result = JSONRPCErrorResponse(
⋮----
"""Creates a Starlette Response based on the result from the request handler.

        Handles:
        - AsyncGenerator for Server-Sent Events (SSE).
        - JSONRPCErrorResponse for explicit errors returned by handlers.
        - Pydantic RootModels (like GetTaskResponse) containing success or error
        payloads.

        Args:
            context: The ServerCallContext provided to the request handler.
            handler_result: The result from a request handler method. Can be an
                async generator for streaming or a Pydantic model for non-streaming.

        Returns:
            A Starlette JSONResponse or EventSourceResponse.
        """
headers = {}
⋮----
# Result is a stream of SendStreamingMessageResponse objects
⋮----
async def _handle_get_agent_card(self, request: Request) -> JSONResponse
⋮----
"""Handles GET requests for the agent card endpoint.

        Args:
            request: The incoming Starlette Request object.

        Returns:
            A JSONResponse containing the agent card data.
        """
⋮----
card_to_serve = self.agent_card
⋮----
card_to_serve = self.card_modifier(card_to_serve)
⋮----
"""Handles GET requests for the authenticated extended agent card."""
⋮----
card_to_serve = self.extended_agent_card
⋮----
context = self._context_builder.build(request)
# If no base extended card is provided, pass the public card to the modifier
base_card = card_to_serve if card_to_serve else self.agent_card
card_to_serve = self.extended_card_modifier(base_card, context)
⋮----
# If supports_authenticated_extended_card is true, but no
# extended_agent_card was provided, and no modifier produced a card,
# return a 404.
⋮----
"""Builds and returns the JSONRPC application instance.

        Args:
            agent_card_url: The URL for the agent card endpoint.
            rpc_url: The URL for the A2A JSON-RPC endpoint.
            extended_agent_card_url: The URL for the authenticated extended
              agent card endpoint.
            **kwargs: Additional keyword arguments to pass to the FastAPI constructor.

        Returns:
            A configured JSONRPC application instance.
        """

================
File: src/a2a/server/apps/jsonrpc/starlette_app.py
================
_package_starlette_installed = True
⋮----
Starlette = Any
Route = Any
⋮----
_package_starlette_installed = False
⋮----
logger = logging.getLogger(__name__)
⋮----
class A2AStarletteApplication(JSONRPCApplication)
⋮----
"""A Starlette application implementing the A2A protocol server endpoints.

    Handles incoming JSON-RPC requests, routes them to the appropriate
    handler methods, and manages response generation including Server-Sent Events
    (SSE).
    """
⋮----
def __init__(  # noqa: PLR0913
⋮----
"""Initializes the A2AStarletteApplication.

        Args:
            agent_card: The AgentCard describing the agent's capabilities.
            http_handler: The handler instance responsible for processing A2A
              requests via http.
            extended_agent_card: An optional, distinct AgentCard to be served
              at the authenticated extended card endpoint.
            context_builder: The CallContextBuilder used to construct the
              ServerCallContext passed to the http_handler. If None, no
              ServerCallContext is passed.
            card_modifier: An optional callback to dynamically modify the public
              agent card before it is served.
            extended_card_modifier: An optional callback to dynamically modify
              the extended agent card before it is served. It receives the
              call context.
        """
⋮----
"""Returns the Starlette Routes for handling A2A requests.

        Args:
            agent_card_url: The URL path for the agent card endpoint.
            rpc_url: The URL path for the A2A JSON-RPC endpoint (POST requests).
            extended_agent_card_url: The URL for the authenticated extended agent card endpoint.

        Returns:
            A list of Starlette Route objects.
        """
app_routes = [
⋮----
# For backward compatibility, serve the agent card at the deprecated path as well.
# TODO: remove in a future release
⋮----
# TODO: deprecated endpoint to be removed in a future release
⋮----
"""Adds the routes to the Starlette application.

        Args:
            app: The Starlette application to add the routes to.
            agent_card_url: The URL path for the agent card endpoint.
            rpc_url: The URL path for the A2A JSON-RPC endpoint (POST requests).
            extended_agent_card_url: The URL for the authenticated extended agent card endpoint.
        """
routes = self.routes(
⋮----
"""Builds and returns the Starlette application instance.

        Args:
            agent_card_url: The URL path for the agent card endpoint.
            rpc_url: The URL path for the A2A JSON-RPC endpoint (POST requests).
            extended_agent_card_url: The URL for the authenticated extended agent card endpoint.
            **kwargs: Additional keyword arguments to pass to the Starlette constructor.

        Returns:
            A configured Starlette application instance.
        """
app = Starlette(**kwargs)

================
File: src/a2a/server/apps/rest/__init__.py
================
"""A2A REST Applications."""
⋮----
__all__ = [

================
File: src/a2a/server/apps/rest/fastapi_app.py
================
_package_fastapi_installed = True
⋮----
APIRouter = Any
FastAPI = Any
Request = Any
Response = Any
⋮----
_package_fastapi_installed = False
⋮----
logger = logging.getLogger(__name__)
⋮----
class A2ARESTFastAPIApplication
⋮----
"""A FastAPI application implementing the A2A protocol server REST endpoints.

    Handles incoming REST requests, routes them to the appropriate
    handler methods, and manages response generation including Server-Sent Events
    (SSE).
    """
⋮----
"""Initializes the A2ARESTFastAPIApplication.

        Args:
            agent_card: The AgentCard describing the agent's capabilities.
            http_handler: The handler instance responsible for processing A2A
              requests via http.
            extended_agent_card: An optional, distinct AgentCard to be served
              at the authenticated extended card endpoint.
            context_builder: The CallContextBuilder used to construct the
              ServerCallContext passed to the http_handler. If None, no
              ServerCallContext is passed.
        """
⋮----
"""Builds and returns the FastAPI application instance.

        Args:
            agent_card_url: The URL for the agent card endpoint.
            rpc_url: The URL for the A2A JSON-RPC endpoint.
            extended_agent_card_url: The URL for the authenticated extended agent card endpoint.
            **kwargs: Additional keyword arguments to pass to the FastAPI constructor.

        Returns:
            A configured FastAPI application instance.
        """
app = FastAPI(**kwargs)
router = APIRouter()
⋮----
@router.get(f'{rpc_url}{agent_card_url}')
        async def get_agent_card(request: Request) -> Response

================
File: src/a2a/server/apps/rest/rest_adapter.py
================
_package_starlette_installed = True
⋮----
EventSourceResponse = Any
Request = Any
JSONResponse = Any
Response = Any
⋮----
_package_starlette_installed = False
⋮----
logger = logging.getLogger(__name__)
⋮----
class RESTAdapter
⋮----
"""Adapter to make RequestHandler work with RESTful API.

    Defines REST requests processors and the routes to attach them too, as well as
    manages response generation including Server-Sent Events (SSE).
    """
⋮----
"""Initializes the RESTApplication.

        Args:
            agent_card: The AgentCard describing the agent's capabilities.
            http_handler: The handler instance responsible for processing A2A
              requests via http.
            context_builder: The CallContextBuilder used to construct the
              ServerCallContext passed to the http_handler. If None, no
              ServerCallContext is passed.
        """
⋮----
call_context = self._context_builder.build(request)
response = await method(request, call_context)
⋮----
@rest_error_handler
    async def handle_get_agent_card(self, request: Request) -> JSONResponse
⋮----
"""Handles GET requests for the agent card endpoint.

        Args:
            request: The incoming Starlette Request object.

        Returns:
            A JSONResponse containing the agent card data.
        """
# The public agent card is a direct serialization of the agent_card
# provided at initialization.
⋮----
"""Hook for per credential agent card response.

        If a dynamic card is needed based on the credentials provided in the request
        override this method and return the customized content.

        Args:
            request: The incoming Starlette Request  object.

        Returns:
            A JSONResponse containing the authenticated card.
        """
⋮----
def routes(self) -> dict[tuple[str, str], Callable[[Request], Any]]
⋮----
"""Constructs a dictionary of API routes and their corresponding handlers.

        This method maps URL paths and HTTP methods to the appropriate handler
        functions from the RESTHandler. It can be used by a web framework
        (like Starlette or FastAPI) to set up the application's endpoints.

        Returns:
            A dictionary where each key is a tuple of (path, http_method) and
            the value is the callable handler for that route.
        """
routes: dict[tuple[str, str], Callable[[Request], Any]] = {

================
File: src/a2a/server/apps/__init__.py
================
"""HTTP application components for the A2A server."""
⋮----
__all__ = [

================
File: src/a2a/server/events/__init__.py
================
"""Event handling components for the A2A server."""
⋮----
__all__ = [

================
File: src/a2a/server/events/event_consumer.py
================
# This is an alias to the exception for closed queue
QueueClosed: type[Exception] = asyncio.QueueEmpty
⋮----
# When using python 3.13 or higher, the closed queue signal is QueueShutdown
⋮----
QueueClosed = asyncio.QueueShutDown
⋮----
logger = logging.getLogger(__name__)
⋮----
@trace_class(kind=SpanKind.SERVER)
class EventConsumer
⋮----
"""Consumer to read events from the agent event queue."""
⋮----
def __init__(self, queue: EventQueue)
⋮----
"""Initializes the EventConsumer.

        Args:
            queue: The `EventQueue` instance to consume events from.
        """
⋮----
async def consume_one(self) -> Event
⋮----
"""Consume one event from the agent event queue non-blocking.

        Returns:
            The next event from the queue.

        Raises:
            ServerError: If the queue is empty when attempting to dequeue
                immediately.
        """
⋮----
event = await self.queue.dequeue_event(no_wait=True)
⋮----
async def consume_all(self) -> AsyncGenerator[Event]
⋮----
"""Consume all the generated streaming events from the agent.

        This method yields events as they become available from the queue
        until a final event is received or the queue is closed. It also
        monitors for exceptions set by the `agent_task_callback`.

        Yields:
            Events dequeued from the queue.

        Raises:
            BaseException: If an exception was set by the `agent_task_callback`.
        """
⋮----
# We use a timeout when waiting for an event from the queue.
# This is required because it allows the loop to check if
# `self._exception` has been set by the `agent_task_callback`.
# Without the timeout, loop might hang indefinitely if no events are
# enqueued by the agent and the agent simply threw an exception
event = await asyncio.wait_for(
⋮----
is_final_event = (
⋮----
# Make sure the yield is after the close events, otherwise
# the caller may end up in a blocked state where this
# generator isn't called again to close things out and the
# other part is waiting for an event or a closed queue.
⋮----
# continue polling until there is a final event
⋮----
except asyncio.TimeoutError:  # pyright: ignore [reportUnusedExcept]
# This class was made an alias of build-in TimeoutError after 3.11
⋮----
# Confirm that the queue is closed, e.g. we aren't on
# python 3.12 and get a queue empty error on an open queue
⋮----
def agent_task_callback(self, agent_task: asyncio.Task[None]) -> None
⋮----
"""Callback to handle exceptions from the agent's execution task.

        If the agent's asyncio task raises an exception, this callback is
        invoked, and the exception is stored to be re-raised by the consumer loop.

        Args:
            agent_task: The asyncio.Task that completed.
        """

================
File: src/a2a/server/events/event_queue.py
================
logger = logging.getLogger(__name__)
⋮----
Event = Message | Task | TaskStatusUpdateEvent | TaskArtifactUpdateEvent
"""Type alias for events that can be enqueued."""
⋮----
DEFAULT_MAX_QUEUE_SIZE = 1024
⋮----
@trace_class(kind=SpanKind.SERVER)
class EventQueue
⋮----
"""Event queue for A2A responses from agent.

    Acts as a buffer between the agent's asynchronous execution and the
    server's response handling (e.g., streaming via SSE). Supports tapping
    to create child queues that receive the same events.
    """
⋮----
def __init__(self, max_queue_size: int = DEFAULT_MAX_QUEUE_SIZE) -> None
⋮----
"""Initializes the EventQueue."""
# Make sure the `asyncio.Queue` is bounded.
# If it's unbounded (maxsize=0), then `queue.put()` never needs to wait,
# and so the streaming won't work correctly.
⋮----
async def enqueue_event(self, event: Event) -> None
⋮----
"""Enqueues an event to this queue and all its children.

        Args:
            event: The event object to enqueue.
        """
⋮----
# Make sure to use put instead of put_nowait to avoid blocking the event loop.
⋮----
async def dequeue_event(self, no_wait: bool = False) -> Event
⋮----
"""Dequeues an event from the queue.

        This implementation expects that dequeue to raise an exception when
        the queue has been closed. In python 3.13+ this is naturally provided
        by the QueueShutDown exception generated when the queue has closed and
        the user is awaiting the queue.get method. Python<=3.12 this needs to
        manage this lifecycle itself. The current implementation can lead to
        blocking if the dequeue_event is called before the EventQueue has been
        closed but when there are no events on the queue. Two ways to avoid this
        are to call this with no_wait = True which won't block, but is the
        callers responsibility to retry as appropriate. Alternatively, one can
        use a async Task management solution to cancel the get task if the queue
        has closed or some other condition is met. The implementation of the
        EventConsumer uses an async.wait with a timeout to abort the
        dequeue_event call and retry, when it will return with a closed error.

        Args:
            no_wait: If True, retrieve an event immediately or raise `asyncio.QueueEmpty`.
                     If False (default), wait until an event is available.

        Returns:
            The next event from the queue.

        Raises:
            asyncio.QueueEmpty: If `no_wait` is True and the queue is empty.
            asyncio.QueueShutDown: If the queue has been closed and is empty.
        """
⋮----
event = self.queue.get_nowait()
⋮----
event = await self.queue.get()
⋮----
def task_done(self) -> None
⋮----
"""Signals that a formerly enqueued task is complete.

        Used in conjunction with `dequeue_event` to track processed items.
        """
⋮----
def tap(self) -> 'EventQueue'
⋮----
"""Taps the event queue to create a new child queue that receives all future events.

        Returns:
            A new `EventQueue` instance that will receive all events enqueued
            to this parent queue from this point forward.
        """
⋮----
queue = EventQueue()
⋮----
async def close(self) -> None
⋮----
"""Closes the queue for future push events.

        Once closed, `dequeue_event` will eventually raise `asyncio.QueueShutDown`
        when the queue is empty. Also closes all child queues.
        """
⋮----
# If already closed, just return.
⋮----
# If using python 3.13 or higher, use the shutdown method
⋮----
# Otherwise, join the queue
⋮----
tasks = [asyncio.create_task(self.queue.join())]
⋮----
def is_closed(self) -> bool
⋮----
"""Checks if the queue is closed."""

================
File: src/a2a/server/events/in_memory_queue_manager.py
================
@trace_class(kind=SpanKind.SERVER)
class InMemoryQueueManager(QueueManager)
⋮----
"""InMemoryQueueManager is used for a single binary management.

    This implements the `QueueManager` interface using in-memory storage for event
    queues. It requires all incoming interactions for a given task ID to hit the
    same binary instance.

    This implementation is suitable for single-instance deployments but needs
    a distributed approach for scalable deployments.
    """
⋮----
def __init__(self) -> None
⋮----
"""Initializes the InMemoryQueueManager."""
⋮----
async def add(self, task_id: str, queue: EventQueue) -> None
⋮----
"""Adds a new event queue for a task ID.

        Raises:
            TaskQueueExists: If a queue for the given `task_id` already exists.
        """
⋮----
async def get(self, task_id: str) -> EventQueue | None
⋮----
"""Retrieves the event queue for a task ID.

        Returns:
            The `EventQueue` instance for the `task_id`, or `None` if not found.
        """
⋮----
async def tap(self, task_id: str) -> EventQueue | None
⋮----
"""Taps the event queue for a task ID to create a child queue.

        Returns:
            A new child `EventQueue` instance, or `None` if the task ID is not found.
        """
⋮----
async def close(self, task_id: str) -> None
⋮----
"""Closes and removes the event queue for a task ID.

        Raises:
            NoTaskQueue: If no queue exists for the given `task_id`.
        """
⋮----
queue = self._task_queue.pop(task_id)
⋮----
async def create_or_tap(self, task_id: str) -> EventQueue
⋮----
"""Creates a new event queue for a task ID if one doesn't exist, otherwise taps the existing one.

        Returns:
            A new or child `EventQueue` instance for the `task_id`.
        """
⋮----
queue = EventQueue()

================
File: src/a2a/server/events/queue_manager.py
================
class QueueManager(ABC)
⋮----
"""Interface for managing the event queue lifecycles per task."""
⋮----
@abstractmethod
    async def add(self, task_id: str, queue: EventQueue) -> None
⋮----
"""Adds a new event queue associated with a task ID."""
⋮----
@abstractmethod
    async def get(self, task_id: str) -> EventQueue | None
⋮----
"""Retrieves the event queue for a task ID."""
⋮----
@abstractmethod
    async def tap(self, task_id: str) -> EventQueue | None
⋮----
"""Creates a child event queue (tap) for an existing task ID."""
⋮----
@abstractmethod
    async def close(self, task_id: str) -> None
⋮----
"""Closes and removes the event queue for a task ID."""
⋮----
@abstractmethod
    async def create_or_tap(self, task_id: str) -> EventQueue
⋮----
"""Creates a queue if one doesn't exist, otherwise taps the existing one."""
⋮----
class TaskQueueExists(Exception):  # noqa: N818
⋮----
"""Exception raised when attempting to add a queue for a task ID that already exists."""
⋮----
class NoTaskQueue(Exception):  # noqa: N818
⋮----
"""Exception raised when attempting to access or close a queue for a task ID that does not exist."""

================
File: src/a2a/server/request_handlers/__init__.py
================
"""Request handler components for the A2A server."""
⋮----
logger = logging.getLogger(__name__)
⋮----
GrpcHandler,  # type: ignore
⋮----
_original_error = e
⋮----
class GrpcHandler:  # type: ignore
⋮----
"""Placeholder for GrpcHandler when dependencies are not installed."""
⋮----
def __init__(self, *args, **kwargs)
⋮----
__all__ = [

================
File: src/a2a/server/request_handlers/default_request_handler.py
================
logger = logging.getLogger(__name__)
⋮----
TERMINAL_TASK_STATES = {
⋮----
@trace_class(kind=SpanKind.SERVER)
class DefaultRequestHandler(RequestHandler)
⋮----
"""Default request handler for all incoming requests.

    This handler provides default implementations for all A2A JSON-RPC methods,
    coordinating between the `AgentExecutor`, `TaskStore`, `QueueManager`,
    and optional `PushNotifier`.
    """
⋮----
_running_agents: dict[str, asyncio.Task]
⋮----
def __init__(  # noqa: PLR0913
⋮----
"""Initializes the DefaultRequestHandler.

        Args:
            agent_executor: The `AgentExecutor` instance to run agent logic.
            task_store: The `TaskStore` instance to manage task persistence.
            queue_manager: The `QueueManager` instance to manage event queues. Defaults to `InMemoryQueueManager`.
            push_config_store: The `PushNotificationConfigStore` instance for managing push notification configurations. Defaults to None.
            push_sender: The `PushNotificationSender` instance for sending push notifications. Defaults to None.
            request_context_builder: The `RequestContextBuilder` instance used
              to build request contexts. Defaults to `SimpleRequestContextBuilder`.
        """
⋮----
# TODO: Likely want an interface for managing this, like AgentExecutionManager.
⋮----
"""Default handler for 'tasks/get'."""
task: Task | None = await self.task_store.get(params.id)
⋮----
"""Default handler for 'tasks/cancel'.

        Attempts to cancel the task managed by the `AgentExecutor`.
        """
⋮----
task_manager = TaskManager(
result_aggregator = ResultAggregator(task_manager)
⋮----
queue = await self._queue_manager.tap(task.id)
⋮----
queue = EventQueue()
⋮----
# Cancel the ongoing task, if one exists.
⋮----
consumer = EventConsumer(queue)
result = await result_aggregator.consume_all(consumer)
⋮----
"""Runs the agent's `execute` method and closes the queue afterwards.

        Args:
            request: The request context for the agent.
            queue: The event queue for the agent to publish to.
        """
⋮----
"""Common setup logic for both streaming and non-streaming message handling.

        Returns:
            A tuple of (task_manager, task_id, queue, result_aggregator, producer_task)
        """
# Create task manager and validate existing task
⋮----
task: Task | None = await task_manager.get_task()
⋮----
task = task_manager.update_with_message(params.message, task)
⋮----
# Build request context
request_context = await self._request_context_builder.build(
⋮----
task_id = cast('str', request_context.task_id)
# Always assign a task ID. We may not actually upgrade to a task, but
# dictating the task ID at this layer is useful for tracking running
# agents.
⋮----
queue = await self._queue_manager.create_or_tap(task_id)
⋮----
# TODO: to manage the non-blocking flows.
producer_task = asyncio.create_task(
⋮----
def _validate_task_id_match(self, task_id: str, event_task_id: str) -> None
⋮----
"""Validates that agent-generated task ID matches the expected task ID."""
⋮----
"""Sends push notification if configured and task is available."""
⋮----
latest_task = await result_aggregator.current_result
⋮----
"""Default handler for 'message/send' interface (non-streaming).

        Starts the agent execution for the message and waits for the final
        result (Task or Message).
        """
⋮----
blocking = True  # Default to blocking behavior
⋮----
blocking = False
⋮----
interrupted_or_non_blocking = False
⋮----
# TODO: Track this disconnected cleanup task.
asyncio.create_task(  # noqa: RUF006
⋮----
"""Default handler for 'message/stream' (streaming).

        Starts the agent execution and yields events as they are produced
        by the agent.
        """
⋮----
"""Registers the agent execution task with the handler."""
⋮----
"""Cleans up the agent execution task and queue manager entry."""
⋮----
"""Default handler for 'tasks/pushNotificationConfig/set'.

        Requires a `PushNotifier` to be configured.
        """
⋮----
task: Task | None = await self.task_store.get(params.task_id)
⋮----
"""Default handler for 'tasks/pushNotificationConfig/get'.

        Requires a `PushConfigStore` to be configured.
        """
⋮----
push_notification_config = await self._push_config_store.get_info(
⋮----
"""Default handler for 'tasks/resubscribe'.

        Allows a client to re-attach to a running streaming task's event stream.
        Requires the task and its queue to still be active.
        """
⋮----
"""Default handler for 'tasks/pushNotificationConfig/list'.

        Requires a `PushConfigStore` to be configured.
        """
⋮----
push_notification_config_list = await self._push_config_store.get_info(
⋮----
task_push_notification_config = []
⋮----
"""Default handler for 'tasks/pushNotificationConfig/delete'.

        Requires a `PushConfigStore` to be configured.
        """

================
File: src/a2a/server/request_handlers/grpc_handler.py
================
# ruff: noqa: N802
⋮----
logger = logging.getLogger(__name__)
⋮----
# For now we use a trivial wrapper on the grpc context object
⋮----
class CallContextBuilder(ABC)
⋮----
"""A class for building ServerCallContexts using the Starlette Request."""
⋮----
@abstractmethod
    def build(self, context: grpc.aio.ServicerContext) -> ServerCallContext
⋮----
"""Builds a ServerCallContext from a gRPC Request."""
⋮----
md = context.invocation_metadata
raw_values: list[str | bytes] = []
⋮----
raw_values = md.get_all(key)
⋮----
lower_key = key.lower()
raw_values = [e for (k, e) in md if k.lower() == lower_key]
⋮----
class DefaultCallContextBuilder(CallContextBuilder)
⋮----
"""A default implementation of CallContextBuilder."""
⋮----
def build(self, context: grpc.aio.ServicerContext) -> ServerCallContext
⋮----
"""Builds the ServerCallContext."""
user = UnauthenticatedUser()
state = {}
⋮----
class GrpcHandler(a2a_grpc.A2AServiceServicer)
⋮----
"""Maps incoming gRPC requests to the appropriate request handler method."""
⋮----
"""Initializes the GrpcHandler.

        Args:
            agent_card: The AgentCard describing the agent's capabilities.
            request_handler: The underlying `RequestHandler` instance to
                             delegate requests to.
            context_builder: The CallContextBuilder object. If none the
                             DefaultCallContextBuilder is used.
            card_modifier: An optional callback to dynamically modify the public
              agent card before it is served.
        """
⋮----
"""Handles the 'SendMessage' gRPC method.

        Args:
            request: The incoming `SendMessageRequest` object.
            context: Context provided by the server.

        Returns:
            A `SendMessageResponse` object containing the result (Task or
            Message) or throws an error response if a `ServerError` is raised
            by the handler.
        """
⋮----
# Construct the server context object
server_context = self.context_builder.build(context)
# Transform the proto object to the python internal objects
a2a_request = proto_utils.FromProto.message_send_params(
task_or_message = await self.request_handler.on_message_send(
⋮----
"""Handles the 'StreamMessage' gRPC method.

        Yields response objects as they are produced by the underlying handler's
        stream.

        Args:
            request: The incoming `SendMessageRequest` object.
            context: Context provided by the server.

        Yields:
            `StreamResponse` objects containing streaming events
            (Task, Message, TaskStatusUpdateEvent, TaskArtifactUpdateEvent)
            or gRPC error responses if a `ServerError` is raised.
        """
⋮----
# Transform the proto object to the python internal objects
⋮----
"""Handles the 'CancelTask' gRPC method.

        Args:
            request: The incoming `CancelTaskRequest` object.
            context: Context provided by the server.

        Returns:
            A `Task` object containing the updated Task or a gRPC error.
        """
⋮----
task_id_params = proto_utils.FromProto.task_id_params(request)
task = await self.request_handler.on_cancel_task(
⋮----
"""Handles the 'TaskSubscription' gRPC method.

        Yields response objects as they are produced by the underlying handler's
        stream.

        Args:
            request: The incoming `TaskSubscriptionRequest` object.
            context: Context provided by the server.

        Yields:
            `StreamResponse` objects containing streaming events
        """
⋮----
"""Handles the 'GetTaskPushNotificationConfig' gRPC method.

        Args:
            request: The incoming `GetTaskPushNotificationConfigRequest` object.
            context: Context provided by the server.

        Returns:
            A `TaskPushNotificationConfig` object containing the config.
        """
⋮----
config = (
⋮----
"""Handles the 'CreateTaskPushNotificationConfig' gRPC method.

        Requires the agent to support push notifications.

        Args:
            request: The incoming `CreateTaskPushNotificationConfigRequest` object.
            context: Context provided by the server.

        Returns:
            A `TaskPushNotificationConfig` object

        Raises:
            ServerError: If push notifications are not supported by the agent
                (due to the `@validate` decorator).
        """
⋮----
"""Handles the 'GetTask' gRPC method.

        Args:
            request: The incoming `GetTaskRequest` object.
            context: Context provided by the server.

        Returns:
            A `Task` object.
        """
⋮----
task = await self.request_handler.on_get_task(
⋮----
"""Get the agent card for the agent served."""
card_to_serve = self.agent_card
⋮----
card_to_serve = self.card_modifier(card_to_serve)
⋮----
"""Sets the grpc errors appropriately in the context."""

================
File: src/a2a/server/request_handlers/jsonrpc_handler.py
================
logger = logging.getLogger(__name__)
⋮----
@trace_class(kind=SpanKind.SERVER)
class JSONRPCHandler
⋮----
"""Maps incoming JSON-RPC requests to the appropriate request handler method and formats responses."""
⋮----
"""Initializes the JSONRPCHandler.

        Args:
            agent_card: The AgentCard describing the agent's capabilities.
            request_handler: The underlying `RequestHandler` instance to delegate requests to.
            extended_agent_card: An optional, distinct Extended AgentCard to be served
            extended_card_modifier: An optional callback to dynamically modify
              the extended agent card before it is served. It receives the
              call context.
        """
⋮----
"""Handles the 'message/send' JSON-RPC method.

        Args:
            request: The incoming `SendMessageRequest` object.
            context: Context provided by the server.

        Returns:
            A `SendMessageResponse` object containing the result (Task or Message)
            or a JSON-RPC error response if a `ServerError` is raised by the handler.
        """
# TODO: Wrap in error handler to return error states
⋮----
task_or_message = await self.request_handler.on_message_send(
⋮----
"""Handles the 'message/stream' JSON-RPC method.

        Yields response objects as they are produced by the underlying handler's stream.

        Args:
            request: The incoming `SendStreamingMessageRequest` object.
            context: Context provided by the server.

        Yields:
            `SendStreamingMessageResponse` objects containing streaming events
            (Task, Message, TaskStatusUpdateEvent, TaskArtifactUpdateEvent)
            or JSON-RPC error responses if a `ServerError` is raised.
        """
⋮----
"""Handles the 'tasks/cancel' JSON-RPC method.

        Args:
            request: The incoming `CancelTaskRequest` object.
            context: Context provided by the server.

        Returns:
            A `CancelTaskResponse` object containing the updated Task or a JSON-RPC error.
        """
⋮----
task = await self.request_handler.on_cancel_task(
⋮----
"""Handles the 'tasks/resubscribe' JSON-RPC method.

        Yields response objects as they are produced by the underlying handler's stream.

        Args:
            request: The incoming `TaskResubscriptionRequest` object.
            context: Context provided by the server.

        Yields:
            `SendStreamingMessageResponse` objects containing streaming events
            or JSON-RPC error responses if a `ServerError` is raised.
        """
⋮----
"""Handles the 'tasks/pushNotificationConfig/get' JSON-RPC method.

        Args:
            request: The incoming `GetTaskPushNotificationConfigRequest` object.
            context: Context provided by the server.

        Returns:
            A `GetTaskPushNotificationConfigResponse` object containing the config or a JSON-RPC error.
        """
⋮----
config = (
⋮----
"""Handles the 'tasks/pushNotificationConfig/set' JSON-RPC method.

        Requires the agent to support push notifications.

        Args:
            request: The incoming `SetTaskPushNotificationConfigRequest` object.
            context: Context provided by the server.

        Returns:
            A `SetTaskPushNotificationConfigResponse` object containing the config or a JSON-RPC error.

        Raises:
            ServerError: If push notifications are not supported by the agent
                (due to the `@validate` decorator).
        """
⋮----
"""Handles the 'tasks/get' JSON-RPC method.

        Args:
            request: The incoming `GetTaskRequest` object.
            context: Context provided by the server.

        Returns:
            A `GetTaskResponse` object containing the Task or a JSON-RPC error.
        """
⋮----
task = await self.request_handler.on_get_task(
⋮----
"""Handles the 'tasks/pushNotificationConfig/list' JSON-RPC method.

        Args:
            request: The incoming `ListTaskPushNotificationConfigRequest` object.
            context: Context provided by the server.

        Returns:
            A `ListTaskPushNotificationConfigResponse` object containing the config or a JSON-RPC error.
        """
⋮----
config = await self.request_handler.on_list_task_push_notification_config(
⋮----
"""Handles the 'tasks/pushNotificationConfig/list' JSON-RPC method.

        Args:
            request: The incoming `DeleteTaskPushNotificationConfigRequest` object.
            context: Context provided by the server.

        Returns:
            A `DeleteTaskPushNotificationConfigResponse` object containing the config or a JSON-RPC error.
        """
⋮----
"""Handles the 'agent/authenticatedExtendedCard' JSON-RPC method.

        Args:
            request: The incoming `GetAuthenticatedExtendedCardRequest` object.
            context: Context provided by the server.

        Returns:
            A `GetAuthenticatedExtendedCardResponse` object containing the config or a JSON-RPC error.
        """
⋮----
base_card = self.extended_agent_card
⋮----
base_card = self.agent_card
⋮----
card_to_serve = base_card
⋮----
card_to_serve = self.extended_card_modifier(base_card, context)

================
File: src/a2a/server/request_handlers/request_handler.py
================
class RequestHandler(ABC)
⋮----
"""A2A request handler interface.

    This interface defines the methods that an A2A server implementation must
    provide to handle incoming JSON-RPC requests.
    """
⋮----
"""Handles the 'tasks/get' method.

        Retrieves the state and history of a specific task.

        Args:
            params: Parameters specifying the task ID and optionally history length.
            context: Context provided by the server.

        Returns:
            The `Task` object if found, otherwise `None`.
        """
⋮----
"""Handles the 'tasks/cancel' method.

        Requests the agent to cancel an ongoing task.

        Args:
            params: Parameters specifying the task ID.
            context: Context provided by the server.

        Returns:
            The `Task` object with its status updated to canceled, or `None` if the task was not found.
        """
⋮----
"""Handles the 'message/send' method (non-streaming).

        Sends a message to the agent to create, continue, or restart a task,
        and waits for the final result (Task or Message).

        Args:
            params: Parameters including the message and configuration.
            context: Context provided by the server.

        Returns:
            The final `Task` object or a final `Message` object.
        """
⋮----
"""Handles the 'message/stream' method (streaming).

        Sends a message to the agent and yields stream events as they are
        produced (Task updates, Message chunks, Artifact updates).

        Args:
            params: Parameters including the message and configuration.
            context: Context provided by the server.

        Yields:
            `Event` objects from the agent's execution.

        Raises:
             ServerError(UnsupportedOperationError): By default, if not implemented.
        """
⋮----
"""Handles the 'tasks/pushNotificationConfig/set' method.

        Sets or updates the push notification configuration for a task.

        Args:
            params: Parameters including the task ID and push notification configuration.
            context: Context provided by the server.

        Returns:
            The provided `TaskPushNotificationConfig` upon success.
        """
⋮----
"""Handles the 'tasks/pushNotificationConfig/get' method.

        Retrieves the current push notification configuration for a task.

        Args:
            params: Parameters including the task ID.
            context: Context provided by the server.

        Returns:
            The `TaskPushNotificationConfig` for the task.
        """
⋮----
"""Handles the 'tasks/resubscribe' method.

        Allows a client to re-subscribe to a running streaming task's event stream.

        Args:
            params: Parameters including the task ID.
            context: Context provided by the server.

        Yields:
             `Event` objects from the agent's ongoing execution for the specified task.

        Raises:
             ServerError(UnsupportedOperationError): By default, if not implemented.
        """
⋮----
"""Handles the 'tasks/pushNotificationConfig/list' method.

        Retrieves the current push notification configurations for a task.

        Args:
            params: Parameters including the task ID.
            context: Context provided by the server.

        Returns:
            The `list[TaskPushNotificationConfig]` for the task.
        """
⋮----
"""Handles the 'tasks/pushNotificationConfig/delete' method.

        Deletes a push notification configuration associated with a task.

        Args:
            params: Parameters including the task ID.
            context: Context provided by the server.

        Returns:
            None
        """

================
File: src/a2a/server/request_handlers/response_helpers.py
================
"""Helper functions for building A2A JSON-RPC responses."""
⋮----
# response types
⋮----
RT = TypeVar(
"""Type variable for RootModel response types."""
⋮----
# success types
SPT = TypeVar(
"""Type variable for SuccessResponse types."""
⋮----
# result types
EventTypes = (
"""Type alias for possible event types produced by handlers."""
⋮----
"""Helper method to build a JSONRPCErrorResponse wrapped in the appropriate response type.

    Args:
        request_id: The ID of the request that caused the error.
        error: The A2AError or JSONRPCError object.
        response_wrapper_type: The Pydantic RootModel type that wraps the response
                                for the specific RPC method (e.g., `SendMessageResponse`).

    Returns:
        A Pydantic model representing the JSON-RPC error response,
        wrapped in the specified response type.
    """
⋮----
"""Helper method to build appropriate JSONRPCResponse object for RPC methods.

    Based on the type of the `response` object received from the handler,
    it constructs either a success response wrapped in the appropriate payload type
    or an error response.

    Args:
        request_id: The ID of the request.
        response: The object received from the request handler.
        success_response_types: A tuple of expected Pydantic model types for a successful result.
        success_payload_type: The Pydantic model type for the success payload
                                (e.g., `SendMessageSuccessResponse`).
        response_type: The Pydantic RootModel type that wraps the final response
                       (e.g., `SendMessageResponse`).

    Returns:
        A Pydantic model representing the final JSON-RPC response (success or error).
    """
⋮----
root=success_payload_type(id=request_id, result=response)  # type:ignore
⋮----
# If consumer_data is not an expected success type and not an error,
# it's an invalid type of response from the agent for this specific method.
response = A2AError(

================
File: src/a2a/server/request_handlers/rest_handler.py
================
Request = Any
⋮----
logger = logging.getLogger(__name__)
⋮----
@trace_class(kind=SpanKind.SERVER)
class RESTHandler
⋮----
"""Maps incoming REST-like (JSON+HTTP) requests to the appropriate request handler method and formats responses.

    This uses the protobuf definitions of the gRPC service as the source of truth. By
    doing this, it ensures that this implementation and the gRPC transcoding
    (via Envoy) are equivalent. This handler should be used if using the gRPC handler
    with Envoy is not feasible for a given deployment solution. Use this handler
    and a related application if you desire to ONLY server the RESTful API.
    """
⋮----
"""Initializes the RESTHandler.

        Args:
          agent_card: The AgentCard describing the agent's capabilities.
          request_handler: The underlying `RequestHandler` instance to delegate requests to.
        """
⋮----
"""Handles the 'message/send' REST method.

        Args:
            request: The incoming `Request` object.
            context: Context provided by the server.

        Returns:
            A `dict` containing the result (Task or Message)
        """
body = await request.body()
params = a2a_pb2.SendMessageRequest()
⋮----
# Transform the proto object to the python internal objects
a2a_request = proto_utils.FromProto.message_send_params(
task_or_message = await self.request_handler.on_message_send(
⋮----
"""Handles the 'message/stream' REST method.

        Yields response objects as they are produced by the underlying handler's stream.

        Args:
            request: The incoming `Request` object.
            context: Context provided by the server.

        Yields:
            JSON serialized objects containing streaming events
            (Task, Message, TaskStatusUpdateEvent, TaskArtifactUpdateEvent) as JSON
        """
⋮----
response = proto_utils.ToProto.stream_response(event)
⋮----
"""Handles the 'tasks/cancel' REST method.

        Args:
            request: The incoming `Request` object.
            context: Context provided by the server.

        Returns:
            A `dict` containing the updated Task
        """
task_id = request.path_params['id']
task = await self.request_handler.on_cancel_task(
⋮----
"""Handles the 'tasks/resubscribe' REST method.

        Yields response objects as they are produced by the underlying handler's stream.

        Args:
            request: The incoming `Request` object.
            context: Context provided by the server.

        Yields:
            JSON serialized objects containing streaming events
        """
⋮----
"""Handles the 'tasks/pushNotificationConfig/get' REST method.

        Args:
            request: The incoming `Request` object.
            context: Context provided by the server.

        Returns:
            A `dict` containing the config
        """
⋮----
push_id = request.path_params['push_id']
params = GetTaskPushNotificationConfigParams(
config = (
⋮----
"""Handles the 'tasks/pushNotificationConfig/set' REST method.

        Requires the agent to support push notifications.

        Args:
            request: The incoming `TaskPushNotificationConfig` object.
            context: Context provided by the server.

        Returns:
            A `dict` containing the config object.

        Raises:
            ServerError: If push notifications are not supported by the agent
                (due to the `@validate` decorator), A2AError if processing error is
                found.
        """
⋮----
params = a2a_pb2.CreateTaskPushNotificationConfigRequest()
⋮----
a2a_request = (
⋮----
"""Handles the 'v1/tasks/{id}' REST method.

        Args:
            request: The incoming `Request` object.
            context: Context provided by the server.

        Returns:
            A `Task` object containing the Task.
        """
⋮----
history_length_str = request.query_params.get('historyLength')
history_length = int(history_length_str) if history_length_str else None
params = TaskQueryParams(id=task_id, history_length=history_length)
task = await self.request_handler.on_get_task(params, context)
⋮----
"""Handles the 'tasks/pushNotificationConfig/list' REST method.

        This method is currently not implemented.

        Args:
            request: The incoming `Request` object.
            context: Context provided by the server.

        Returns:
            A list of `dict` representing the `TaskPushNotificationConfig` objects.

        Raises:
            NotImplementedError: This method is not yet implemented.
        """
⋮----
"""Handles the 'tasks/list' REST method.

        This method is currently not implemented.

        Args:
            request: The incoming `Request` object.
            context: Context provided by the server.

        Returns:
            A list of dict representing the`Task` objects.

        Raises:
            NotImplementedError: This method is not yet implemented.
        """

================
File: src/a2a/server/tasks/__init__.py
================
"""Components for managing tasks within the A2A server."""
⋮----
logger = logging.getLogger(__name__)
⋮----
DatabaseTaskStore,  # type: ignore
⋮----
_original_error = e
# If the database task store is not available, we can still use in-memory stores.
⋮----
class DatabaseTaskStore:  # type: ignore
⋮----
"""Placeholder for DatabaseTaskStore when dependencies are not installed."""
⋮----
def __init__(self, *args, **kwargs)
⋮----
DatabasePushNotificationConfigStore,  # type: ignore
⋮----
# If the database push notification config store is not available, we can still use in-memory stores.
⋮----
class DatabasePushNotificationConfigStore:  # type: ignore
⋮----
"""Placeholder for DatabasePushNotificationConfigStore when dependencies are not installed."""
⋮----
__all__ = [

================
File: src/a2a/server/tasks/base_push_notification_sender.py
================
logger = logging.getLogger(__name__)
⋮----
class BasePushNotificationSender(PushNotificationSender)
⋮----
"""Base implementation of PushNotificationSender interface."""
⋮----
"""Initializes the BasePushNotificationSender.

        Args:
            httpx_client: An async HTTP client instance to send notifications.
            config_store: A PushNotificationConfigStore instance to retrieve configurations.
        """
⋮----
async def send_notification(self, task: Task) -> None
⋮----
"""Sends a push notification for a task if configuration exists."""
push_configs = await self._config_store.get_info(task.id)
⋮----
awaitables = [
results = await asyncio.gather(*awaitables)
⋮----
url = push_info.url
⋮----
headers = None
⋮----
headers = {'X-A2A-Notification-Token': push_info.token}
response = await self._client.post(

================
File: src/a2a/server/tasks/database_push_notification_config_store.py
================
# ruff: noqa: PLC0415
⋮----
logger = logging.getLogger(__name__)
⋮----
class DatabasePushNotificationConfigStore(PushNotificationConfigStore)
⋮----
"""SQLAlchemy-based implementation of PushNotificationConfigStore.

    Stores push notification configurations in a database supported by SQLAlchemy.
    """
⋮----
engine: AsyncEngine
async_session_maker: async_sessionmaker[AsyncSession]
create_table: bool
_initialized: bool
config_model: type[PushNotificationConfigModel]
_fernet: 'Fernet | None'
⋮----
"""Initializes the DatabasePushNotificationConfigStore.

        Args:
            engine: An existing SQLAlchemy AsyncEngine to be used by the store.
            create_table: If true, create the table on initialization.
            table_name: Name of the database table. Defaults to 'push_notification_configs'.
            encryption_key: A key for encrypting sensitive configuration data.
                If provided, `config_data` will be encrypted in the database.
                The key must be a URL-safe base64-encoded 32-byte key.
        """
⋮----
encryption_key = encryption_key.encode('utf-8')
⋮----
async def initialize(self) -> None
⋮----
"""Initialize the database and create the table if needed."""
⋮----
mapper = class_mapper(self.config_model)
tables_to_create = [
⋮----
async def _ensure_initialized(self) -> None
⋮----
"""Ensure the database connection is initialized."""
⋮----
"""Maps a Pydantic PushNotificationConfig to a SQLAlchemy model instance.

        The config data is serialized to JSON bytes, and encrypted if a key is configured.
        """
json_payload = config.model_dump_json().encode('utf-8')
⋮----
data_to_store = self._fernet.encrypt(json_payload)
⋮----
data_to_store = json_payload
⋮----
"""Maps a SQLAlchemy model instance to a Pydantic PushNotificationConfig.

        Handles decryption if a key is configured, with a fallback to plain JSON.
        """
payload = model_instance.config_data
⋮----
decrypted_payload = self._fernet.decrypt(payload)
⋮----
# Decryption failed. This could be because the data is not encrypted.
# We'll log a warning and try to parse it as plain JSON as a fallback.
⋮----
# Fall through to the unencrypted parsing logic below.
⋮----
# Try to parse as plain JSON.
⋮----
# if no key is configured and the payload is not valid JSON.
⋮----
"""Sets or updates the push notification configuration for a task."""
⋮----
config_to_save = notification_config.model_copy()
⋮----
db_config = self._to_orm(task_id, config_to_save)
⋮----
async def get_info(self, task_id: str) -> list[PushNotificationConfig]
⋮----
"""Retrieves all push notification configurations for a task."""
⋮----
stmt = select(self.config_model).where(
result = await session.execute(stmt)
models = result.scalars().all()
⋮----
configs = []
⋮----
"""Deletes push notification configurations for a task.

        If config_id is provided, only that specific configuration is deleted.
        If config_id is None, all configurations for the task are deleted.
        """
⋮----
stmt = delete(self.config_model).where(
⋮----
stmt = stmt.where(self.config_model.config_id == config_id)

================
File: src/a2a/server/tasks/database_task_store.py
================
from a2a.types import Task  # Task is the Pydantic model
⋮----
logger = logging.getLogger(__name__)
⋮----
class DatabaseTaskStore(TaskStore)
⋮----
"""SQLAlchemy-based implementation of TaskStore.

    Stores task objects in a database supported by SQLAlchemy.
    """
⋮----
engine: AsyncEngine
async_session_maker: async_sessionmaker[AsyncSession]
create_table: bool
_initialized: bool
task_model: type[TaskModel]
⋮----
"""Initializes the DatabaseTaskStore.

        Args:
            engine: An existing SQLAlchemy AsyncEngine to be used by Task Store
            create_table: If true, create tasks table on initialization.
            table_name: Name of the database table. Defaults to 'tasks'.
        """
⋮----
async def initialize(self) -> None
⋮----
"""Initialize the database and create the table if needed."""
⋮----
mapper = class_mapper(self.task_model)
tables_to_create = [
⋮----
async def _ensure_initialized(self) -> None
⋮----
"""Ensure the database connection is initialized."""
⋮----
def _to_orm(self, task: Task) -> TaskModel
⋮----
"""Maps a Pydantic Task to a SQLAlchemy TaskModel instance."""
⋮----
def _from_orm(self, task_model: TaskModel) -> Task
⋮----
"""Maps a SQLAlchemy TaskModel to a Pydantic Task instance."""
# Map database columns to Pydantic model fields
task_data_from_db = {
⋮----
'metadata': task_model.task_metadata,  # Map task_metadata column to metadata field
⋮----
# Pydantic's model_validate will parse the nested dicts/lists from JSON
⋮----
async def save(self, task: Task) -> None
⋮----
"""Saves or updates a task in the database."""
⋮----
db_task = self._to_orm(task)
⋮----
async def get(self, task_id: str) -> Task | None
⋮----
"""Retrieves a task from the database by ID."""
⋮----
stmt = select(self.task_model).where(self.task_model.id == task_id)
result = await session.execute(stmt)
task_model = result.scalar_one_or_none()
⋮----
task = self._from_orm(task_model)
⋮----
async def delete(self, task_id: str) -> None
⋮----
"""Deletes a task from the database by ID."""
⋮----
stmt = delete(self.task_model).where(self.task_model.id == task_id)
⋮----
# Commit is automatic when using session.begin()

================
File: src/a2a/server/tasks/inmemory_push_notification_config_store.py
================
logger = logging.getLogger(__name__)
⋮----
class InMemoryPushNotificationConfigStore(PushNotificationConfigStore)
⋮----
"""In-memory implementation of PushNotificationConfigStore interface.

    Stores push notification configurations in memory
    """
⋮----
def __init__(self) -> None
⋮----
"""Initializes the InMemoryPushNotificationConfigStore."""
⋮----
"""Sets or updates the push notification configuration for a task in memory."""
⋮----
async def get_info(self, task_id: str) -> list[PushNotificationConfig]
⋮----
"""Retrieves the push notification configuration for a task from memory."""
⋮----
"""Deletes the push notification configuration for a task from memory."""
⋮----
config_id = task_id
⋮----
configurations = self._push_notification_infos[task_id]

================
File: src/a2a/server/tasks/inmemory_task_store.py
================
logger = logging.getLogger(__name__)
⋮----
class InMemoryTaskStore(TaskStore)
⋮----
"""In-memory implementation of TaskStore.

    Stores task objects in a dictionary in memory. Task data is lost when the
    server process stops.
    """
⋮----
def __init__(self) -> None
⋮----
"""Initializes the InMemoryTaskStore."""
⋮----
async def save(self, task: Task) -> None
⋮----
"""Saves or updates a task in the in-memory store."""
⋮----
async def get(self, task_id: str) -> Task | None
⋮----
"""Retrieves a task from the in-memory store by ID."""
⋮----
task = self.tasks.get(task_id)
⋮----
async def delete(self, task_id: str) -> None
⋮----
"""Deletes a task from the in-memory store by ID."""

================
File: src/a2a/server/tasks/push_notification_config_store.py
================
class PushNotificationConfigStore(ABC)
⋮----
"""Interface for storing and retrieving push notification configurations for tasks."""
⋮----
"""Sets or updates the push notification configuration for a task."""
⋮----
@abstractmethod
    async def get_info(self, task_id: str) -> list[PushNotificationConfig]
⋮----
"""Retrieves the push notification configuration for a task."""
⋮----
"""Deletes the push notification configuration for a task."""

================
File: src/a2a/server/tasks/push_notification_sender.py
================
class PushNotificationSender(ABC)
⋮----
"""Interface for sending push notifications for tasks."""
⋮----
@abstractmethod
    async def send_notification(self, task: Task) -> None
⋮----
"""Sends a push notification containing the latest task state."""

================
File: src/a2a/server/tasks/result_aggregator.py
================
logger = logging.getLogger(__name__)
⋮----
class ResultAggregator
⋮----
"""ResultAggregator is used to process the event streams from an AgentExecutor.

    There are three main ways to use the ResultAggregator:
    1) As part of a processing pipe. consume_and_emit will construct the updated
       task as the events arrive, and re-emit those events for another consumer
    2) As part of a blocking call. consume_all will process the entire stream and
       return the final Task or Message object
    3) As part of a push solution where the latest Task is emitted after processing an event.
       consume_and_emit_task will consume the Event stream, process the events to the current
       Task object and emit that Task object.
    """
⋮----
def __init__(self, task_manager: TaskManager)
⋮----
"""Initializes the ResultAggregator.

        Args:
            task_manager: The `TaskManager` instance to use for processing events
                          and managing the task state.
        """
⋮----
@property
    async def current_result(self) -> Task | Message | None
⋮----
"""Returns the current aggregated result (Task or Message).

        This is the latest state processed from the event stream.

        Returns:
            The current `Task` object managed by the `TaskManager`, or the final
            `Message` if one was received, or `None` if no result has been produced yet.
        """
⋮----
"""Processes the event stream from the consumer, updates the task state, and re-emits the same events.

        Useful for streaming scenarios where the server needs to observe and
        process events (e.g., save task state, send push notifications) while
        forwarding them to the client.

        Args:
            consumer: The `EventConsumer` to read events from.

        Yields:
            The `Event` objects consumed from the `EventConsumer`.
        """
⋮----
"""Processes the entire event stream from the consumer and returns the final result.

        Blocks until the event stream ends (queue is closed after final event or exception).

        Args:
            consumer: The `EventConsumer` to read events from.

        Returns:
            The final `Task` object or `Message` object after the stream is exhausted.
            Returns `None` if the stream ends without producing a final result.

        Raises:
            BaseException: If the `EventConsumer` raises an exception during consumption.
        """
⋮----
"""Processes the event stream until completion or an interruptable state is encountered.

        If `blocking` is False, it returns after the first event that creates a Task or Message.
        If `blocking` is True, it waits for completion unless an `auth_required`
        state is encountered, which is always an interruption.
        If interrupted, consumption continues in a background task.

        Args:
            consumer: The `EventConsumer` to read events from.
            blocking: If `False`, the method returns as soon as a task/message
                      is available. If `True`, it waits for a terminal state.

        Returns:
            A tuple containing:
            - The current aggregated result (`Task` or `Message`) at the point of completion or interruption.
            - A boolean indicating whether the consumption was interrupted (`True`) or completed naturally (`False`).

        Raises:
            BaseException: If the `EventConsumer` raises an exception during consumption.
        """
event_stream = consumer.consume_all()
interrupted = False
⋮----
should_interrupt = False
is_auth_required = (
⋮----
# Always interrupt on auth_required, as it needs external action.
⋮----
# auth-required is a special state: the message should be
# escalated back to the caller, but the agent is expected to
# continue producing events once the authorization is received
# out-of-band. This is in contrast to input-required, where a
# new request is expected in order for the agent to make progress,
# so the agent should exit.
⋮----
should_interrupt = True
# For non-blocking calls, interrupt as soon as a task is available.
⋮----
# Continue consuming the rest of the events in the background.
# TODO: We should track all outstanding tasks to ensure they eventually complete.
asyncio.create_task(self._continue_consuming(event_stream))  # noqa: RUF006
interrupted = True
⋮----
"""Continues processing an event stream in a background task.

        Used after an interruptable state (like auth_required) is encountered
        in the synchronous consumption flow.

        Args:
            event_stream: The remaining `AsyncIterator` of events from the consumer.
        """

================
File: src/a2a/server/tasks/task_manager.py
================
logger = logging.getLogger(__name__)
⋮----
class TaskManager
⋮----
"""Helps manage a task's lifecycle during execution of a request.

    Responsible for retrieving, saving, and updating the `Task` object based on
    events received from the agent.
    """
⋮----
"""Initializes the TaskManager.

        Args:
            task_id: The ID of the task, if known from the request.
            context_id: The ID of the context, if known from the request.
            task_store: The `TaskStore` instance for persistence.
            initial_message: The `Message` that initiated the task, if any.
                             Used when creating a new task object.
        """
⋮----
async def get_task(self) -> Task | None
⋮----
"""Retrieves the current task object, either from memory or the store.

        If `task_id` is set, it first checks the in-memory `_current_task`,
        then attempts to load it from the `task_store`.

        Returns:
            The `Task` object if found, otherwise `None`.
        """
⋮----
"""Processes a task-related event (Task, Status, Artifact) and saves the updated task state.

        Ensures task and context IDs match or are set from the event.

        Args:
            event: The task-related event (`Task`, `TaskStatusUpdateEvent`, or `TaskArtifactUpdateEvent`).

        Returns:
            The updated `Task` object after processing the event.

        Raises:
            ServerError: If the task ID in the event conflicts with the TaskManager's ID
                         when the TaskManager's ID is already set.
        """
task_id_from_event = (
# If task id is known, make sure it is matched
⋮----
task: Task = await self.ensure_task(event)
⋮----
"""Ensures a Task object exists in memory, loading from store or creating new if needed.

        Args:
            event: The task-related event triggering the need for a Task object.

        Returns:
            An existing or newly created `Task` object.
        """
task: Task | None = self._current_task
⋮----
task = await self.task_store.get(self.task_id)
⋮----
# streaming agent did not previously stream task object.
# Create a task object with the available information and persist the event
task = self._init_task_obj(event.task_id, event.context_id)
⋮----
async def process(self, event: Event) -> Event
⋮----
"""Processes an event, updates the task state if applicable, stores it, and returns the event.

        If the event is task-related (`Task`, `TaskStatusUpdateEvent`, `TaskArtifactUpdateEvent`),
        the internal task state is updated and persisted.

        Args:
            event: The event object received from the agent.

        Returns:
            The same event object that was processed.
        """
⋮----
def _init_task_obj(self, task_id: str, context_id: str) -> Task
⋮----
"""Initializes a new task object in memory.

        Args:
            task_id: The ID for the new task.
            context_id: The context ID for the new task.

        Returns:
            A new `Task` object with initial status and potentially the initial message in history.
        """
⋮----
history = [self._initial_message] if self._initial_message else []
⋮----
async def _save_task(self, task: Task) -> None
⋮----
"""Saves the given task to the task store and updates the in-memory `_current_task`.

        Args:
            task: The `Task` object to save.
        """
⋮----
def update_with_message(self, message: Message, task: Task) -> Task
⋮----
"""Updates a task object in memory by adding a new message to its history.

        If the task has a message in its current status, that message is moved
        to the history first.

        Args:
            message: The new `Message` to add to the history.
            task: The `Task` object to update.

        Returns:
            The updated `Task` object (updated in-place).
        """

================
File: src/a2a/server/tasks/task_store.py
================
class TaskStore(ABC)
⋮----
"""Agent Task Store interface.

    Defines the methods for persisting and retrieving `Task` objects.
    """
⋮----
@abstractmethod
    async def save(self, task: Task) -> None
⋮----
"""Saves or updates a task in the store."""
⋮----
@abstractmethod
    async def get(self, task_id: str) -> Task | None
⋮----
"""Retrieves a task from the store by ID."""
⋮----
@abstractmethod
    async def delete(self, task_id: str) -> None
⋮----
"""Deletes a task from the store by ID."""

================
File: src/a2a/server/tasks/task_updater.py
================
class TaskUpdater
⋮----
"""Helper class for agents to publish updates to a task's event queue.

    Simplifies the process of creating and enqueueing standard task events.
    """
⋮----
def __init__(self, event_queue: EventQueue, task_id: str, context_id: str)
⋮----
"""Initializes the TaskUpdater.

        Args:
            event_queue: The `EventQueue` associated with the task.
            task_id: The ID of the task.
            context_id: The context ID of the task.
        """
⋮----
"""Updates the status of the task and publishes a `TaskStatusUpdateEvent`.

        Args:
            state: The new state of the task.
            message: An optional message associated with the status update.
            final: If True, indicates this is the final status update for the task.
            timestamp: Optional ISO 8601 datetime string. Defaults to current time.
            metadata: Optional metadata for extensions.
        """
⋮----
final = True
⋮----
current_timestamp = (
⋮----
async def add_artifact(  # noqa: PLR0913
⋮----
"""Adds an artifact chunk to the task and publishes a `TaskArtifactUpdateEvent`.

        Args:
            parts: A list of `Part` objects forming the artifact chunk.
            artifact_id: The ID of the artifact. A new UUID is generated if not provided.
            name: Optional name for the artifact.
            metadata: Optional metadata for the artifact.
            append: Optional boolean indicating if this chunk appends to a previous one.
            last_chunk: Optional boolean indicating if this is the last chunk.
        """
⋮----
artifact_id = str(uuid.uuid4())
⋮----
async def complete(self, message: Message | None = None) -> None
⋮----
"""Marks the task as completed and publishes a final status update."""
⋮----
async def failed(self, message: Message | None = None) -> None
⋮----
"""Marks the task as failed and publishes a final status update."""
⋮----
async def reject(self, message: Message | None = None) -> None
⋮----
"""Marks the task as rejected and publishes a final status update."""
⋮----
async def submit(self, message: Message | None = None) -> None
⋮----
"""Marks the task as submitted and publishes a status update."""
⋮----
async def start_work(self, message: Message | None = None) -> None
⋮----
"""Marks the task as working and publishes a status update."""
⋮----
async def cancel(self, message: Message | None = None) -> None
⋮----
"""Marks the task as cancelled and publishes a finalstatus update."""
⋮----
"""Marks the task as input required and publishes a status update."""
⋮----
"""Marks the task as auth required and publishes a status update."""
⋮----
"""Creates a new message object sent by the agent for this task/context.

        Note: This method only *creates* the message object. It does not
              automatically enqueue it.

        Args:
            parts: A list of `Part` objects for the message content.
            metadata: Optional metadata for the message.

        Returns:
            A new `Message` object.
        """

================
File: src/a2a/server/__init__.py
================
"""Server-side components for implementing an A2A agent."""

================
File: src/a2a/server/context.py
================
"""Defines the ServerCallContext class."""
⋮----
State = collections.abc.MutableMapping[str, typing.Any]
⋮----
class ServerCallContext(BaseModel)
⋮----
"""A context passed when calling a server method.

    This class allows storing arbitrary user data in the state attribute.
    """
⋮----
model_config = ConfigDict(arbitrary_types_allowed=True)
⋮----
state: State = Field(default={})
user: User = Field(default=UnauthenticatedUser())
requested_extensions: set[str] = Field(default_factory=set)
activated_extensions: set[str] = Field(default_factory=set)

================
File: src/a2a/server/models.py
================
def override(func):  # noqa: ANN001, ANN201
⋮----
"""Override decorator."""
⋮----
T = TypeVar('T', bound=BaseModel)
⋮----
class PydanticType(TypeDecorator[T], Generic[T])
⋮----
"""SQLAlchemy type that handles Pydantic model serialization."""
⋮----
impl = JSON
cache_ok = True
⋮----
def __init__(self, pydantic_type: type[T], **kwargs: dict[str, Any])
⋮----
"""Initialize the PydanticType.

        Args:
            pydantic_type: The Pydantic model type to handle.
            **kwargs: Additional arguments for TypeDecorator.
        """
⋮----
"""Convert Pydantic model to a JSON-serializable dictionary for the database."""
⋮----
"""Convert a JSON-like dictionary from the database back to a Pydantic model."""
⋮----
class PydanticListType(TypeDecorator, Generic[T])
⋮----
"""SQLAlchemy type that handles lists of Pydantic models."""
⋮----
"""Initialize the PydanticListType.

        Args:
            pydantic_type: The Pydantic model type for items in the list.
            **kwargs: Additional arguments for TypeDecorator.
        """
⋮----
"""Convert a list of Pydantic models to a JSON-serializable list for the DB."""
⋮----
"""Convert a JSON-like list from the DB back to a list of Pydantic models."""
⋮----
# Base class for all database models
class Base(DeclarativeBase)
⋮----
"""Base class for declarative models in A2A SDK."""
⋮----
# TaskMixin that can be used with any table name
class TaskMixin
⋮----
"""Mixin providing standard task columns with proper type handling."""
⋮----
id: Mapped[str] = mapped_column(String(36), primary_key=True, index=True)
context_id: Mapped[str] = mapped_column(String(36), nullable=False)
kind: Mapped[str] = mapped_column(
⋮----
# Properly typed Pydantic fields with automatic serialization
status: Mapped[TaskStatus] = mapped_column(PydanticType(TaskStatus))
artifacts: Mapped[list[Artifact] | None] = mapped_column(
history: Mapped[list[Message] | None] = mapped_column(
⋮----
# Using declared_attr to avoid conflict with Pydantic's metadata
⋮----
@declared_attr
@classmethod
    def task_metadata(cls) -> Mapped[dict[str, Any] | None]
⋮----
"""Define the 'metadata' column, avoiding name conflicts with Pydantic."""
⋮----
@override
    def __repr__(self) -> str
⋮----
"""Return a string representation of the task."""
repr_template = (
⋮----
"""Create a TaskModel class with a configurable table name.

    Args:
        table_name: Name of the database table. Defaults to 'tasks'.
        base: Base declarative class to use. Defaults to the SDK's Base class.

    Returns:
        TaskModel class with the specified table name.

    Example:
        # Create a task model with default table name
        TaskModel = create_task_model()

        # Create a task model with custom table name
        CustomTaskModel = create_task_model('my_tasks')

        # Use with a custom base
        from myapp.database import Base as MyBase
        TaskModel = create_task_model('tasks', MyBase)
    """
⋮----
class TaskModel(TaskMixin, base):  # type: ignore
⋮----
__tablename__ = table_name
⋮----
@override
        def __repr__(self) -> str
⋮----
"""Return a string representation of the task."""
repr_template = '<TaskModel[{TABLE}](id="{ID}", context_id="{CTX_ID}", status="{STATUS}")>'
⋮----
# Set a dynamic name for better debugging
⋮----
# Default TaskModel for backward compatibility
class TaskModel(TaskMixin, Base)
⋮----
"""Default task model with standard table name."""
⋮----
__tablename__ = 'tasks'
⋮----
# PushNotificationConfigMixin that can be used with any table name
class PushNotificationConfigMixin
⋮----
"""Mixin providing standard push notification config columns."""
⋮----
task_id: Mapped[str] = mapped_column(String(36), primary_key=True)
config_id: Mapped[str] = mapped_column(String(255), primary_key=True)
config_data: Mapped[bytes] = mapped_column(LargeBinary, nullable=False)
⋮----
"""Return a string representation of the push notification config."""
repr_template = '<{CLS}(task_id="{TID}", config_id="{CID}")>'
⋮----
"""Create a PushNotificationConfigModel class with a configurable table name."""
⋮----
class PushNotificationConfigModel(PushNotificationConfigMixin, base):  # type: ignore
⋮----
"""Return a string representation of the push notification config."""
repr_template = '<PushNotificationConfigModel[{TABLE}](task_id="{TID}", config_id="{CID}")>'
⋮----
# Default PushNotificationConfigModel for backward compatibility
class PushNotificationConfigModel(PushNotificationConfigMixin, Base)
⋮----
"""Default push notification config model with standard table name."""
⋮----
__tablename__ = 'push_notification_configs'

================
File: src/a2a/utils/__init__.py
================
"""Utility functions for the A2A Python SDK."""
⋮----
__all__ = [

================
File: src/a2a/utils/artifact.py
================
"""Utility functions for creating A2A Artifact objects."""
⋮----
"""Creates a new Artifact object.

    Args:
        parts: The list of `Part` objects forming the artifact's content.
        name: The human-readable name of the artifact.
        description: An optional description of the artifact.

    Returns:
        A new `Artifact` object with a generated artifact_id.
    """
⋮----
"""Creates a new Artifact object containing only a single TextPart.

    Args:
        name: The human-readable name of the artifact.
        text: The text content of the artifact.
        description: An optional description of the artifact.

    Returns:
        A new `Artifact` object with a generated artifact_id.
    """
⋮----
"""Creates a new Artifact object containing only a single DataPart.

    Args:
        name: The human-readable name of the artifact.
        data: The structured data content of the artifact.
        description: An optional description of the artifact.

    Returns:
        A new `Artifact` object with a generated artifact_id.
    """

================
File: src/a2a/utils/constants.py
================
"""Constants for well-known URIs used throughout the A2A Python SDK."""
⋮----
AGENT_CARD_WELL_KNOWN_PATH = '/.well-known/agent-card.json'
PREV_AGENT_CARD_WELL_KNOWN_PATH = '/.well-known/agent.json'
EXTENDED_AGENT_CARD_PATH = '/agent/authenticatedExtendedCard'
DEFAULT_RPC_URL = '/'

================
File: src/a2a/utils/error_handlers.py
================
JSONResponse = Any
Response = Any
⋮----
logger = logging.getLogger(__name__)
⋮----
A2AErrorToHttpStatus: dict[type[A2ABaseModel], int] = {
⋮----
"""Decorator to catch ServerError and map it to an appropriate JSONResponse."""
⋮----
@functools.wraps(func)
    async def wrapper(*args: Any, **kwargs: Any) -> Response
⋮----
error = e.error or InternalError(
http_code = A2AErrorToHttpStatus.get(type(error), 500)
⋮----
log_level = (
⋮----
"""Decorator to catch ServerError for a streaming method,log it and then rethrow it to be handled by framework."""
⋮----
@functools.wraps(func)
    async def wrapper(*args: Any, **kwargs: Any) -> Any
⋮----
# Since the stream has started, we can't return a JSONResponse.
# Instead, we runt the error handling logic (provides logging)
# and reraise the error and let server framework manage

================
File: src/a2a/utils/errors.py
================
"""Custom exceptions for A2A server-side errors."""
⋮----
class A2AServerError(Exception)
⋮----
"""Base exception for A2A Server errors."""
⋮----
class MethodNotImplementedError(A2AServerError)
⋮----
"""Exception raised for methods that are not implemented by the server handler."""
⋮----
"""Initializes the MethodNotImplementedError.

        Args:
            message: A descriptive error message.
        """
⋮----
class ServerError(Exception)
⋮----
"""Wrapper exception for A2A or JSON-RPC errors originating from the server's logic.

    This exception is used internally by request handlers and other server components
    to signal a specific error that should be formatted as a JSON-RPC error response.
    """
⋮----
"""Initializes the ServerError.

        Args:
            error: The specific A2A or JSON-RPC error model instance.
                   If None, an `InternalError` will be used when formatting the response.
        """

================
File: src/a2a/utils/helpers.py
================
"""General utility functions for the A2A Python SDK."""
⋮----
logger = logging.getLogger(__name__)
⋮----
@trace_function()
def create_task_obj(message_send_params: MessageSendParams) -> Task
⋮----
"""Create a new task object from message send params.

    Generates UUIDs for task and context IDs if they are not already present in the message.

    Args:
        message_send_params: The `MessageSendParams` object containing the initial message.

    Returns:
        A new `Task` object initialized with 'submitted' status and the input message in history.
    """
⋮----
@trace_function()
def append_artifact_to_task(task: Task, event: TaskArtifactUpdateEvent) -> None
⋮----
"""Helper method for updating a Task object with new artifact data from an event.

    Handles creating the artifacts list if it doesn't exist, adding new artifacts,
    and appending parts to existing artifacts based on the `append` flag in the event.

    Args:
        task: The `Task` object to modify.
        event: The `TaskArtifactUpdateEvent` containing the artifact data.
    """
⋮----
new_artifact_data: Artifact = event.artifact
artifact_id: str = new_artifact_data.artifact_id
append_parts: bool = event.append or False
⋮----
existing_artifact: Artifact | None = None
existing_artifact_list_index: int | None = None
⋮----
# Find existing artifact by its id
⋮----
existing_artifact = art
existing_artifact_list_index = i
⋮----
# This represents the first chunk for this artifact index.
⋮----
# Replace the existing artifact entirely with the new data
⋮----
# Append the new artifact since no artifact with this index exists yet
⋮----
# Append new parts to the existing artifact's part list
⋮----
# We received a chunk to append, but we don't have an existing artifact.
# we will ignore this chunk
⋮----
def build_text_artifact(text: str, artifact_id: str) -> Artifact
⋮----
"""Helper to create a text artifact.

    Args:
        text: The text content for the artifact.
        artifact_id: The ID for the artifact.

    Returns:
        An `Artifact` object containing a single `TextPart`.
    """
text_part = TextPart(text=text)
part = Part(root=text_part)
⋮----
"""Decorator that validates if a given expression evaluates to True.

    Typically used on class methods to check capabilities or configuration
    before executing the method's logic. If the expression is False,
    a `ServerError` with an `UnsupportedOperationError` is raised.

    Args:
        expression: A callable that takes the instance (`self`) as its argument
                    and returns a boolean.
        error_message: An optional custom error message for the `UnsupportedOperationError`.
                       If None, the string representation of the expression will be used.
    """
⋮----
def decorator(function: Callable) -> Callable
⋮----
@functools.wraps(function)
            async def async_wrapper(self: Any, *args, **kwargs) -> Any
⋮----
final_message = error_message or str(expression)
⋮----
@functools.wraps(function)
        def sync_wrapper(self: Any, *args, **kwargs) -> Any
⋮----
def decorator(function)
⋮----
@functools.wraps(function)
        async def wrapper(self, *args, **kwargs)
⋮----
"""Checks if server and client output modalities (MIME types) are compatible.

    Modalities are compatible if:
    1. The client specifies no preferred output modes (client_output_modes is None or empty).
    2. The server specifies no supported output modes (server_output_modes is None or empty).
    3. There is at least one common modality between the server's supported list and the client's preferred list.

    Args:
        server_output_modes: A list of MIME types supported by the server/agent for output.
                             Can be None or empty if the server doesn't specify.
        client_output_modes: A list of MIME types preferred by the client for output.
                             Can be None or empty if the client accepts any.

    Returns:
        True if the modalities are compatible, False otherwise.
    """

================
File: src/a2a/utils/message.py
================
"""Utility functions for creating and handling A2A Message objects."""
⋮----
"""Creates a new agent message containing a single TextPart.

    Args:
        text: The text content of the message.
        context_id: The context ID for the message.
        task_id: The task ID for the message.

    Returns:
        A new `Message` object with role 'agent'.
    """
⋮----
"""Creates a new agent message containing a list of Parts.

    Args:
        parts: The list of `Part` objects for the message content.
        context_id: The context ID for the message.
        task_id: The task ID for the message.

    Returns:
        A new `Message` object with role 'agent'.
    """
⋮----
def get_text_parts(parts: list[Part]) -> list[str]
⋮----
"""Extracts text content from all TextPart objects in a list of Parts.

    Args:
        parts: A list of `Part` objects.

    Returns:
        A list of strings containing the text content from any `TextPart` objects found.
    """
⋮----
def get_data_parts(parts: list[Part]) -> list[dict[str, Any]]
⋮----
"""Extracts dictionary data from all DataPart objects in a list of Parts.

    Args:
        parts: A list of `Part` objects.

    Returns:
        A list of dictionaries containing the data from any `DataPart` objects found.
    """
⋮----
def get_file_parts(parts: list[Part]) -> list[FileWithBytes | FileWithUri]
⋮----
"""Extracts file data from all FilePart objects in a list of Parts.

    Args:
        parts: A list of `Part` objects.

    Returns:
        A list of `FileWithBytes` or `FileWithUri` objects containing the file data from any `FilePart` objects found.
    """
⋮----
def get_message_text(message: Message, delimiter: str = '\n') -> str
⋮----
"""Extracts and joins all text content from a Message's parts.

    Args:
        message: The `Message` object.
        delimiter: The string to use when joining text from multiple TextParts.

    Returns:
        A single string containing all text content, or an empty string if no text parts are found.
    """

================
File: src/a2a/utils/proto_utils.py
================
# mypy: disable-error-code="arg-type"
"""Utils for converting between proto and Python types."""
⋮----
logger = logging.getLogger(__name__)
⋮----
# Regexp patterns for matching
_TASK_NAME_MATCH = r'tasks/([\w-]+)'
_TASK_PUSH_CONFIG_NAME_MATCH = (
⋮----
class ToProto
⋮----
"""Converts Python types to proto types."""
⋮----
@classmethod
    def message(cls, message: types.Message | None) -> a2a_pb2.Message | None
⋮----
# TODO: Add support for other types.
⋮----
@classmethod
    def part(cls, part: types.Part) -> a2a_pb2.Part
⋮----
@classmethod
    def data(cls, data: dict[str, Any]) -> a2a_pb2.DataPart
⋮----
json_data = json.dumps(data)
⋮----
@classmethod
    def task(cls, task: types.Task) -> a2a_pb2.Task
⋮----
[ToProto.message(h) for h in task.history]  # type: ignore[misc]
⋮----
@classmethod
    def task_status(cls, status: types.TaskStatus) -> a2a_pb2.TaskStatus
⋮----
@classmethod
    def task_state(cls, state: types.TaskState) -> a2a_pb2.TaskState
⋮----
@classmethod
    def artifact(cls, artifact: types.Artifact) -> a2a_pb2.Artifact
⋮----
auth_info = (
⋮----
"""Converts a task, message, or task update event to a StreamResponse."""
⋮----
rval: list[a2a_pb2.Security] = []
⋮----
@classmethod
    def oauth2_flows(cls, flows: types.OAuthFlows) -> a2a_pb2.OAuthFlows
⋮----
@classmethod
    def skill(cls, skill: types.AgentSkill) -> a2a_pb2.AgentSkill
⋮----
@classmethod
    def role(cls, role: types.Role) -> a2a_pb2.Role
⋮----
class FromProto
⋮----
"""Converts proto types to Python types."""
⋮----
@classmethod
    def message(cls, message: a2a_pb2.Message) -> types.Message
⋮----
@classmethod
    def metadata(cls, metadata: struct_pb2.Struct) -> dict[str, Any]
⋮----
@classmethod
    def part(cls, part: a2a_pb2.Part) -> types.Part
⋮----
@classmethod
    def data(cls, data: a2a_pb2.DataPart) -> dict[str, Any]
⋮----
json_data = json_format.MessageToJson(data.data)
⋮----
@classmethod
    def task(cls, task: a2a_pb2.Task) -> types.Task
⋮----
@classmethod
    def task_status(cls, status: a2a_pb2.TaskStatus) -> types.TaskStatus
⋮----
@classmethod
    def task_state(cls, state: a2a_pb2.TaskState) -> types.TaskState
⋮----
@classmethod
    def artifact(cls, artifact: a2a_pb2.Artifact) -> types.Artifact
⋮----
# This is currently incomplete until the core sdk supports multiple
# configs for a single task.
⋮----
m = re.match(_TASK_PUSH_CONFIG_NAME_MATCH, request.name)
⋮----
m = re.match(_TASK_NAME_MATCH, request.name)
⋮----
m = re.match(_TASK_NAME_MATCH, request.parent)
⋮----
m = re.match(_TASK_PUSH_CONFIG_NAME_MATCH, config.name)
⋮----
rval: list[dict[str, list[str]]] = []
⋮----
in_=types.In(scheme.api_key_security_scheme.location),  # type: ignore[call-arg]
⋮----
@classmethod
    def oauth2_flows(cls, flows: a2a_pb2.OAuthFlows) -> types.OAuthFlows
⋮----
@classmethod
    def skill(cls, skill: a2a_pb2.AgentSkill) -> types.AgentSkill
⋮----
@classmethod
    def role(cls, role: a2a_pb2.Role) -> types.Role

================
File: src/a2a/utils/task.py
================
"""Utility functions for creating A2A Task objects."""
⋮----
def new_task(request: Message) -> Task
⋮----
"""Creates a new Task object from an initial user message.

    Generates task and context IDs if not provided in the message.

    Args:
        request: The initial `Message` object from the user.

    Returns:
        A new `Task` object initialized with 'submitted' status and the input message in history.

    Raises:
        TypeError: If the message role is None.
        ValueError: If the message parts are empty, if any part has empty content, or if the provided context_id is invalid.
    """
⋮----
context_id_str = request.context_id
⋮----
context_id = context_id_str
⋮----
context_id = str(uuid.uuid4())
⋮----
"""Creates a Task object in the 'completed' state.

    Useful for constructing a final Task representation when the agent
    finishes and produces artifacts.

    Args:
        task_id: The ID of the task.
        context_id: The context ID of the task.
        artifacts: A list of `Artifact` objects produced by the task.
        history: An optional list of `Message` objects representing the task history.

    Returns:
        A `Task` object with status set to 'completed'.
    """
⋮----
history = []

================
File: src/a2a/utils/telemetry.py
================
"""OpenTelemetry Tracing Utilities for A2A Python SDK.

This module provides decorators to simplify the integration of OpenTelemetry
tracing into Python applications. It offers `trace_function` for instrumenting
individual functions (both synchronous and asynchronous) and `trace_class`
for instrumenting multiple methods within a class.

The tracer is initialized with the module name and version defined by
`INSTRUMENTING_MODULE_NAME` ('a2a-python-sdk') and
`INSTRUMENTING_MODULE_VERSION` ('1.0.0').

Features:
- Automatic span creation for decorated functions/methods.
- Support for both synchronous and asynchronous functions.
- Default span naming based on module and function/class/method name.
- Customizable span names, kinds, and static attributes.
- Dynamic attribute setting via an `attribute_extractor` callback.
- Automatic recording of exceptions and setting of span status.
- Selective method tracing in classes using include/exclude lists.

Usage:
    For a single function:
    ```python
    from your_module import trace_function


    @trace_function
    def my_function():
        # ...
        pass


    @trace_function(span_name='custom.op', kind=SpanKind.CLIENT)
    async def my_async_function():
        # ...
        pass
    ```

    For a class:
    ```python
    from your_module import trace_class


    @trace_class(exclude_list=['internal_method'])
    class MyService:
        def public_api(self, user_id):
            # This method will be traced
            pass

        def internal_method(self):
            # This method will not be traced
            pass
    ```
"""
⋮----
SpanKindType = object
⋮----
logger = logging.getLogger(__name__)
⋮----
class _NoOp
⋮----
"""A no-op object that absorbs all tracing calls when OpenTelemetry is not installed."""
⋮----
def __call__(self, *args: Any, **kwargs: Any) -> Any
⋮----
def __enter__(self) -> '_NoOp'
⋮----
def __exit__(self, *args: object, **kwargs: Any) -> None
⋮----
def __getattr__(self, name: str) -> Any
⋮----
trace = _NoOp()  # type: ignore
_SpanKind = _NoOp()  # type: ignore
StatusCode = _NoOp()  # type: ignore
⋮----
SpanKind = _SpanKind
__all__ = ['SpanKind']
⋮----
INSTRUMENTING_MODULE_NAME = 'a2a-python-sdk'
INSTRUMENTING_MODULE_VERSION = '1.0.0'
⋮----
def trace_function(  # noqa: PLR0915
⋮----
"""A decorator to automatically trace a function call with OpenTelemetry.

    This decorator can be used to wrap both sync and async functions.
    When applied, it creates a new span for each call to the decorated function.
    The span will record the execution time, status (OK or ERROR), and any
    exceptions that occur.

    It can be used in two ways:

    1. As a direct decorator: `@trace_function`
    2. As a decorator factory to provide arguments: `@trace_function(span_name="custom.name")`

    Args:
        func (callable, optional): The function to be decorated. If None,
            the decorator returns a partial function, allowing it to be called
            with arguments. Defaults to None.
        span_name (str, optional): Custom name for the span. If None,
            it defaults to ``f'{func.__module__}.{func.__name__}'``.
            Defaults to None.
        kind (SpanKind, optional): The ``opentelemetry.trace.SpanKind`` for the
            created span. Defaults to ``SpanKind.INTERNAL``.
        attributes (dict, optional): A dictionary of static attributes to be
            set on the span. Keys are attribute names (str) and values are
            the corresponding attribute values. Defaults to None.
        attribute_extractor (callable, optional): A function that can be used
            to dynamically extract and set attributes on the span.
            It is called within a ``finally`` block, ensuring it runs even if
            the decorated function raises an exception.
            The function signature should be:
            ``attribute_extractor(span, args, kwargs, result, exception)``
            where:
                - ``span`` : the OpenTelemetry ``Span`` object.
                - ``args`` : a tuple of positional arguments passed
                - ``kwargs`` : a dictionary of keyword arguments passed
                - ``result`` : return value (None if an exception occurred)
                - ``exception`` : exception object if raised (None otherwise).
            Any exception raised by the ``attribute_extractor`` itself will be
            caught and logged. Defaults to None.

    Returns:
        callable: The wrapped function that includes tracing, or a partial
            decorator if ``func`` is None.
    """
⋮----
actual_span_name = span_name or f'{func.__module__}.{func.__name__}'
⋮----
is_async_func = inspect.iscoroutinefunction(func)
⋮----
@functools.wraps(func)
    async def async_wrapper(*args, **kwargs) -> Any
⋮----
"""Async Wrapper for the decorator."""
⋮----
tracer = trace.get_tracer(
⋮----
result = None
exception = None
⋮----
# Async wrapper, await for the function call to complete.
result = await func(*args, **kwargs)
⋮----
# asyncio.CancelledError extends from BaseException
⋮----
exception = e
⋮----
@functools.wraps(func)
    def sync_wrapper(*args, **kwargs) -> Any
⋮----
"""Sync Wrapper for the decorator."""
tracer = trace.get_tracer(INSTRUMENTING_MODULE_NAME)
⋮----
# Sync wrapper, execute the function call.
result = func(*args, **kwargs)
⋮----
"""A class decorator to automatically trace specified methods of a class.

    This decorator iterates over the methods of a class and applies the
    `trace_function` decorator to them, based on the `include_list` and
    `exclude_list` criteria. Methods starting or ending with double underscores
    (dunder methods, e.g., `__init__`, `__call__`) are always excluded by default.

    Args:
        include_list (list[str], optional): A list of method names to
            explicitly include for tracing. If provided, only methods in this
            list (that are not dunder methods) will be traced.
            Defaults to None (trace all non-dunder methods).
        exclude_list (list[str], optional): A list of method names to exclude
            from tracing. This is only considered if `include_list` is not
            provided. Dunder methods are implicitly excluded.
            Defaults to an empty list.
        kind (SpanKind, optional): The `opentelemetry.trace.SpanKind` for the
            created spans on the methods. Defaults to `SpanKind.INTERNAL`.

    Returns:
        callable: A decorator function that, when applied to a class,
                  modifies the class to wrap its specified methods with tracing.

    Example:
        To trace all methods except 'internal_method':
        ```python
        @trace_class(exclude_list=['internal_method'])
        class MyService:
            def public_api(self):
                pass

            def internal_method(self):
                pass
        ```

        To trace only 'method_one' and 'method_two':
        ```python
        @trace_class(include_list=['method_one', 'method_two'])
        class AnotherService:
            def method_one(self):
                pass

            def method_two(self):
                pass

            def not_traced_method(self):
                pass
        ```
    """
⋮----
exclude_list = exclude_list or []
⋮----
def decorator(cls: Any) -> Any
⋮----
span_name = f'{cls.__module__}.{cls.__name__}.{name}'

================
File: src/a2a/__init__.py
================
"""The A2A Python SDK."""

================
File: src/a2a/_base.py
================
def to_camel_custom(snake: str) -> str
⋮----
"""Convert a snake_case string to camelCase.

    Args:
        snake: The string to convert.

    Returns:
        The converted camelCase string.
    """
# First, remove any trailing underscores. This is common for names that
# conflict with Python keywords, like 'in_' or 'from_'.
⋮----
snake = snake.rstrip('_')
⋮----
class A2ABaseModel(BaseModel)
⋮----
"""Base class for shared behavior across A2A data models.

    Provides a common configuration (e.g., alias-based population) and
    serves as the foundation for future extensions or shared utilities.

    This implementation provides backward compatibility for camelCase aliases
    by lazy-loading an alias map upon first use. Accessing or setting
    attributes via their camelCase alias will raise a DeprecationWarning.
    """
⋮----
model_config = ConfigDict(
⋮----
# SEE: https://docs.pydantic.dev/latest/api/config/#pydantic.config.ConfigDict.populate_by_name

================
File: src/a2a/types.py
================
# generated by datamodel-codegen:
#   filename:  https://raw.githubusercontent.com/a2aproject/A2A/refs/heads/main/specification/json/a2a.json
⋮----
class A2A(RootModel[Any])
⋮----
root: Any
⋮----
class In(str, Enum)
⋮----
"""
    The location of the API key.
    """
⋮----
cookie = 'cookie'
header = 'header'
query = 'query'
⋮----
class APIKeySecurityScheme(A2ABaseModel)
⋮----
"""
    Defines a security scheme using an API key.
    """
⋮----
description: str | None = None
"""
    An optional description for the security scheme.
    """
in_: In
⋮----
name: str
"""
    The name of the header, query, or cookie parameter to be used.
    """
type: Literal['apiKey'] = 'apiKey'
"""
    The type of the security scheme. Must be 'apiKey'.
    """
⋮----
class AgentCardSignature(A2ABaseModel)
⋮----
"""
    AgentCardSignature represents a JWS signature of an AgentCard.
    This follows the JSON format of an RFC 7515 JSON Web Signature (JWS).
    """
⋮----
header: dict[str, Any] | None = None
"""
    The unprotected JWS header values.
    """
protected: str
"""
    The protected JWS header for the signature. This is a Base64url-encoded
    JSON object, as per RFC 7515.
    """
signature: str
"""
    The computed signature, Base64url-encoded.
    """
⋮----
class AgentExtension(A2ABaseModel)
⋮----
"""
    A declaration of a protocol extension supported by an Agent.
    """
⋮----
"""
    A human-readable description of how this agent uses the extension.
    """
params: dict[str, Any] | None = None
"""
    Optional, extension-specific configuration parameters.
    """
required: bool | None = None
"""
    If true, the client must understand and comply with the extension's requirements
    to interact with the agent.
    """
uri: str
"""
    The unique URI identifying the extension.
    """
⋮----
class AgentInterface(A2ABaseModel)
⋮----
"""
    Declares a combination of a target URL and a transport protocol for interacting with the agent.
    This allows agents to expose the same functionality over multiple transport mechanisms.
    """
⋮----
transport: str = Field(..., examples=['JSONRPC', 'GRPC', 'HTTP+JSON'])
"""
    The transport protocol supported at this URL.
    """
url: str = Field(
"""
    The URL where this interface is available. Must be a valid absolute HTTPS URL in production.
    """
⋮----
class AgentProvider(A2ABaseModel)
⋮----
"""
    Represents the service provider of an agent.
    """
⋮----
organization: str
"""
    The name of the agent provider's organization.
    """
url: str
"""
    A URL for the agent provider's website or relevant documentation.
    """
⋮----
class AgentSkill(A2ABaseModel)
⋮----
"""
    Represents a distinct capability or function that an agent can perform.
    """
⋮----
description: str
"""
    A detailed description of the skill, intended to help clients or users
    understand its purpose and functionality.
    """
examples: list[str] | None = Field(
"""
    Example prompts or scenarios that this skill can handle. Provides a hint to
    the client on how to use the skill.
    """
id: str
"""
    A unique identifier for the agent's skill.
    """
input_modes: list[str] | None = None
"""
    The set of supported input MIME types for this skill, overriding the agent's defaults.
    """
⋮----
"""
    A human-readable name for the skill.
    """
output_modes: list[str] | None = None
"""
    The set of supported output MIME types for this skill, overriding the agent's defaults.
    """
security: list[dict[str, list[str]]] | None = Field(
"""
    Security schemes necessary for the agent to leverage this skill.
    As in the overall AgentCard.security, this list represents a logical OR of security
    requirement objects. Each object is a set of security schemes that must be used together
    (a logical AND).
    """
tags: list[str] = Field(
"""
    A set of keywords describing the skill's capabilities.
    """
⋮----
class AuthenticatedExtendedCardNotConfiguredError(A2ABaseModel)
⋮----
"""
    An A2A-specific error indicating that the agent does not have an Authenticated Extended Card configured
    """
⋮----
code: Literal[-32007] = -32007
"""
    The error code for when an authenticated extended card is not configured.
    """
data: Any | None = None
"""
    A primitive or structured value containing additional information about the error.
    This may be omitted.
    """
message: str | None = 'Authenticated Extended Card is not configured'
"""
    The error message.
    """
⋮----
class AuthorizationCodeOAuthFlow(A2ABaseModel)
⋮----
"""
    Defines configuration details for the OAuth 2.0 Authorization Code flow.
    """
⋮----
authorization_url: str
"""
    The authorization URL to be used for this flow.
    This MUST be a URL and use TLS.
    """
refresh_url: str | None = None
"""
    The URL to be used for obtaining refresh tokens.
    This MUST be a URL and use TLS.
    """
scopes: dict[str, str]
"""
    The available scopes for the OAuth2 security scheme. A map between the scope
    name and a short description for it.
    """
token_url: str
"""
    The token URL to be used for this flow.
    This MUST be a URL and use TLS.
    """
⋮----
class ClientCredentialsOAuthFlow(A2ABaseModel)
⋮----
"""
    Defines configuration details for the OAuth 2.0 Client Credentials flow.
    """
⋮----
"""
    The URL to be used for obtaining refresh tokens. This MUST be a URL.
    """
⋮----
"""
    The token URL to be used for this flow. This MUST be a URL.
    """
⋮----
class ContentTypeNotSupportedError(A2ABaseModel)
⋮----
"""
    An A2A-specific error indicating an incompatibility between the requested
    content types and the agent's capabilities.
    """
⋮----
code: Literal[-32005] = -32005
"""
    The error code for an unsupported content type.
    """
⋮----
message: str | None = 'Incompatible content types'
⋮----
class DataPart(A2ABaseModel)
⋮----
"""
    Represents a structured data segment (e.g., JSON) within a message or artifact.
    """
⋮----
data: dict[str, Any]
"""
    The structured data content.
    """
kind: Literal['data'] = 'data'
"""
    The type of this part, used as a discriminator. Always 'data'.
    """
metadata: dict[str, Any] | None = None
"""
    Optional metadata associated with this part.
    """
⋮----
class DeleteTaskPushNotificationConfigParams(A2ABaseModel)
⋮----
"""
    Defines parameters for deleting a specific push notification configuration for a task.
    """
⋮----
"""
    The unique identifier of the task.
    """
⋮----
"""
    Optional metadata associated with the request.
    """
push_notification_config_id: str
"""
    The ID of the push notification configuration to delete.
    """
⋮----
class DeleteTaskPushNotificationConfigRequest(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC request for the `tasks/pushNotificationConfig/delete` method.
    """
⋮----
id: str | int
"""
    The identifier for this request.
    """
jsonrpc: Literal['2.0'] = '2.0'
"""
    The version of the JSON-RPC protocol. MUST be exactly "2.0".
    """
method: Literal['tasks/pushNotificationConfig/delete'] = (
"""
    The method name. Must be 'tasks/pushNotificationConfig/delete'.
    """
params: DeleteTaskPushNotificationConfigParams
"""
    The parameters identifying the push notification configuration to delete.
    """
⋮----
class DeleteTaskPushNotificationConfigSuccessResponse(A2ABaseModel)
⋮----
"""
    Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/delete` method.
    """
⋮----
id: str | int | None = None
"""
    The identifier established by the client.
    """
⋮----
result: None
"""
    The result is null on successful deletion.
    """
⋮----
class FileBase(A2ABaseModel)
⋮----
"""
    Defines base properties for a file.
    """
⋮----
mime_type: str | None = None
"""
    The MIME type of the file (e.g., "application/pdf").
    """
name: str | None = None
"""
    An optional name for the file (e.g., "document.pdf").
    """
⋮----
class FileWithBytes(A2ABaseModel)
⋮----
"""
    Represents a file with its content provided directly as a base64-encoded string.
    """
⋮----
bytes: str
"""
    The base64-encoded content of the file.
    """
⋮----
class FileWithUri(A2ABaseModel)
⋮----
"""
    Represents a file with its content located at a specific URI.
    """
⋮----
"""
    A URL pointing to the file's content.
    """
⋮----
class GetAuthenticatedExtendedCardRequest(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC request for the `agent/getAuthenticatedExtendedCard` method.
    """
⋮----
method: Literal['agent/getAuthenticatedExtendedCard'] = (
"""
    The method name. Must be 'agent/getAuthenticatedExtendedCard'.
    """
⋮----
class GetTaskPushNotificationConfigParams(A2ABaseModel)
⋮----
"""
    Defines parameters for fetching a specific push notification configuration for a task.
    """
⋮----
push_notification_config_id: str | None = None
"""
    The ID of the push notification configuration to retrieve.
    """
⋮----
class HTTPAuthSecurityScheme(A2ABaseModel)
⋮----
"""
    Defines a security scheme using HTTP authentication.
    """
⋮----
bearer_format: str | None = None
"""
    A hint to the client to identify how the bearer token is formatted (e.g., "JWT").
    This is primarily for documentation purposes.
    """
⋮----
scheme: str
"""
    The name of the HTTP Authentication scheme to be used in the Authorization header,
    as defined in RFC7235 (e.g., "Bearer").
    This value should be registered in the IANA Authentication Scheme registry.
    """
type: Literal['http'] = 'http'
"""
    The type of the security scheme. Must be 'http'.
    """
⋮----
class ImplicitOAuthFlow(A2ABaseModel)
⋮----
"""
    Defines configuration details for the OAuth 2.0 Implicit flow.
    """
⋮----
"""
    The authorization URL to be used for this flow. This MUST be a URL.
    """
⋮----
class InternalError(A2ABaseModel)
⋮----
"""
    An error indicating an internal error on the server.
    """
⋮----
code: Literal[-32603] = -32603
"""
    The error code for an internal server error.
    """
⋮----
message: str | None = 'Internal error'
⋮----
class InvalidAgentResponseError(A2ABaseModel)
⋮----
"""
    An A2A-specific error indicating that the agent returned a response that
    does not conform to the specification for the current method.
    """
⋮----
code: Literal[-32006] = -32006
"""
    The error code for an invalid agent response.
    """
⋮----
message: str | None = 'Invalid agent response'
⋮----
class InvalidParamsError(A2ABaseModel)
⋮----
"""
    An error indicating that the method parameters are invalid.
    """
⋮----
code: Literal[-32602] = -32602
"""
    The error code for an invalid parameters error.
    """
⋮----
message: str | None = 'Invalid parameters'
⋮----
class InvalidRequestError(A2ABaseModel)
⋮----
"""
    An error indicating that the JSON sent is not a valid Request object.
    """
⋮----
code: Literal[-32600] = -32600
"""
    The error code for an invalid request.
    """
⋮----
message: str | None = 'Request payload validation error'
⋮----
class JSONParseError(A2ABaseModel)
⋮----
"""
    An error indicating that the server received invalid JSON.
    """
⋮----
code: Literal[-32700] = -32700
"""
    The error code for a JSON parse error.
    """
⋮----
message: str | None = 'Invalid JSON payload'
⋮----
class JSONRPCError(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC 2.0 Error object, included in an error response.
    """
⋮----
code: int
"""
    A number that indicates the error type that occurred.
    """
⋮----
message: str
"""
    A string providing a short description of the error.
    """
⋮----
class JSONRPCMessage(A2ABaseModel)
⋮----
"""
    Defines the base structure for any JSON-RPC 2.0 request, response, or notification.
    """
⋮----
"""
    A unique identifier established by the client. It must be a String, a Number, or null.
    The server must reply with the same value in the response. This property is omitted for notifications.
    """
⋮----
class JSONRPCRequest(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC 2.0 Request object.
    """
⋮----
method: str
"""
    A string containing the name of the method to be invoked.
    """
⋮----
"""
    A structured value holding the parameter values to be used during the method invocation.
    """
⋮----
class JSONRPCSuccessResponse(A2ABaseModel)
⋮----
"""
    Represents a successful JSON-RPC 2.0 Response object.
    """
⋮----
result: Any
"""
    The value of this member is determined by the method invoked on the Server.
    """
⋮----
class ListTaskPushNotificationConfigParams(A2ABaseModel)
⋮----
"""
    Defines parameters for listing all push notification configurations associated with a task.
    """
⋮----
class ListTaskPushNotificationConfigRequest(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC request for the `tasks/pushNotificationConfig/list` method.
    """
⋮----
method: Literal['tasks/pushNotificationConfig/list'] = (
"""
    The method name. Must be 'tasks/pushNotificationConfig/list'.
    """
params: ListTaskPushNotificationConfigParams
"""
    The parameters identifying the task whose configurations are to be listed.
    """
⋮----
class Role(str, Enum)
⋮----
"""
    Identifies the sender of the message. `user` for the client, `agent` for the service.
    """
⋮----
agent = 'agent'
user = 'user'
⋮----
class MethodNotFoundError(A2ABaseModel)
⋮----
"""
    An error indicating that the requested method does not exist or is not available.
    """
⋮----
code: Literal[-32601] = -32601
"""
    The error code for a method not found error.
    """
⋮----
message: str | None = 'Method not found'
⋮----
class MutualTLSSecurityScheme(A2ABaseModel)
⋮----
"""
    Defines a security scheme using mTLS authentication.
    """
⋮----
type: Literal['mutualTLS'] = 'mutualTLS'
"""
    The type of the security scheme. Must be 'mutualTLS'.
    """
⋮----
class OpenIdConnectSecurityScheme(A2ABaseModel)
⋮----
"""
    Defines a security scheme using OpenID Connect.
    """
⋮----
open_id_connect_url: str
"""
    The OpenID Connect Discovery URL for the OIDC provider's metadata.
    """
type: Literal['openIdConnect'] = 'openIdConnect'
"""
    The type of the security scheme. Must be 'openIdConnect'.
    """
⋮----
class PartBase(A2ABaseModel)
⋮----
"""
    Defines base properties common to all message or artifact parts.
    """
⋮----
class PasswordOAuthFlow(A2ABaseModel)
⋮----
"""
    Defines configuration details for the OAuth 2.0 Resource Owner Password flow.
    """
⋮----
class PushNotificationAuthenticationInfo(A2ABaseModel)
⋮----
"""
    Defines authentication details for a push notification endpoint.
    """
⋮----
credentials: str | None = None
"""
    Optional credentials required by the push notification endpoint.
    """
schemes: list[str]
"""
    A list of supported authentication schemes (e.g., 'Basic', 'Bearer').
    """
⋮----
class PushNotificationConfig(A2ABaseModel)
⋮----
"""
    Defines the configuration for setting up push notifications for task updates.
    """
⋮----
authentication: PushNotificationAuthenticationInfo | None = None
"""
    Optional authentication details for the agent to use when calling the notification URL.
    """
id: str | None = None
"""
    A unique ID for the push notification configuration, set by the client
    to support multiple notification callbacks.
    """
token: str | None = None
"""
    A unique token for this task or session to validate incoming push notifications.
    """
⋮----
"""
    The callback URL where the agent should send push notifications.
    """
⋮----
class PushNotificationNotSupportedError(A2ABaseModel)
⋮----
"""
    An A2A-specific error indicating that the agent does not support push notifications.
    """
⋮----
code: Literal[-32003] = -32003
"""
    The error code for when push notifications are not supported.
    """
⋮----
message: str | None = 'Push Notification is not supported'
⋮----
class SecuritySchemeBase(A2ABaseModel)
⋮----
"""
    Defines base properties shared by all security scheme objects.
    """
⋮----
class TaskIdParams(A2ABaseModel)
⋮----
"""
    Defines parameters containing a task ID, used for simple task operations.
    """
⋮----
class TaskNotCancelableError(A2ABaseModel)
⋮----
"""
    An A2A-specific error indicating that the task is in a state where it cannot be canceled.
    """
⋮----
code: Literal[-32002] = -32002
"""
    The error code for a task that cannot be canceled.
    """
⋮----
message: str | None = 'Task cannot be canceled'
⋮----
class TaskNotFoundError(A2ABaseModel)
⋮----
"""
    An A2A-specific error indicating that the requested task ID was not found.
    """
⋮----
code: Literal[-32001] = -32001
"""
    The error code for a task not found error.
    """
⋮----
message: str | None = 'Task not found'
⋮----
class TaskPushNotificationConfig(A2ABaseModel)
⋮----
"""
    A container associating a push notification configuration with a specific task.
    """
⋮----
push_notification_config: PushNotificationConfig
"""
    The push notification configuration for this task.
    """
task_id: str
"""
    The ID of the task.
    """
⋮----
class TaskQueryParams(A2ABaseModel)
⋮----
"""
    Defines parameters for querying a task, with an option to limit history length.
    """
⋮----
history_length: int | None = None
"""
    The number of most recent messages from the task's history to retrieve.
    """
⋮----
class TaskResubscriptionRequest(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC request for the `tasks/resubscribe` method, used to resume a streaming connection.
    """
⋮----
method: Literal['tasks/resubscribe'] = 'tasks/resubscribe'
"""
    The method name. Must be 'tasks/resubscribe'.
    """
params: TaskIdParams
"""
    The parameters identifying the task to resubscribe to.
    """
⋮----
class TaskState(str, Enum)
⋮----
"""
    Defines the lifecycle states of a Task.
    """
⋮----
submitted = 'submitted'
working = 'working'
input_required = 'input-required'
completed = 'completed'
canceled = 'canceled'
failed = 'failed'
rejected = 'rejected'
auth_required = 'auth-required'
unknown = 'unknown'
⋮----
class TextPart(A2ABaseModel)
⋮----
"""
    Represents a text segment within a message or artifact.
    """
⋮----
kind: Literal['text'] = 'text'
"""
    The type of this part, used as a discriminator. Always 'text'.
    """
⋮----
text: str
"""
    The string content of the text part.
    """
⋮----
class TransportProtocol(str, Enum)
⋮----
"""
    Supported A2A transport protocols.
    """
⋮----
jsonrpc = 'JSONRPC'
grpc = 'GRPC'
http_json = 'HTTP+JSON'
⋮----
class UnsupportedOperationError(A2ABaseModel)
⋮----
"""
    An A2A-specific error indicating that the requested operation is not supported by the agent.
    """
⋮----
code: Literal[-32004] = -32004
"""
    The error code for an unsupported operation.
    """
⋮----
message: str | None = 'This operation is not supported'
⋮----
class A2AError(
⋮----
root: (
"""
    A discriminated union of all standard JSON-RPC and A2A-specific error types.
    """
⋮----
class AgentCapabilities(A2ABaseModel)
⋮----
"""
    Defines optional capabilities supported by an agent.
    """
⋮----
extensions: list[AgentExtension] | None = None
"""
    A list of protocol extensions supported by the agent.
    """
push_notifications: bool | None = None
"""
    Indicates if the agent supports sending push notifications for asynchronous task updates.
    """
state_transition_history: bool | None = None
"""
    Indicates if the agent provides a history of state transitions for a task.
    """
streaming: bool | None = None
"""
    Indicates if the agent supports Server-Sent Events (SSE) for streaming responses.
    """
⋮----
class CancelTaskRequest(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC request for the `tasks/cancel` method.
    """
⋮----
method: Literal['tasks/cancel'] = 'tasks/cancel'
"""
    The method name. Must be 'tasks/cancel'.
    """
⋮----
"""
    The parameters identifying the task to cancel.
    """
⋮----
class FilePart(A2ABaseModel)
⋮----
"""
    Represents a file segment within a message or artifact. The file content can be
    provided either directly as bytes or as a URI.
    """
⋮----
file: FileWithBytes | FileWithUri
"""
    The file content, represented as either a URI or as base64-encoded bytes.
    """
kind: Literal['file'] = 'file'
"""
    The type of this part, used as a discriminator. Always 'file'.
    """
⋮----
class GetTaskPushNotificationConfigRequest(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC request for the `tasks/pushNotificationConfig/get` method.
    """
⋮----
method: Literal['tasks/pushNotificationConfig/get'] = (
"""
    The method name. Must be 'tasks/pushNotificationConfig/get'.
    """
params: TaskIdParams | GetTaskPushNotificationConfigParams
"""
    The parameters for getting a push notification configuration.
    """
⋮----
class GetTaskPushNotificationConfigSuccessResponse(A2ABaseModel)
⋮----
"""
    Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/get` method.
    """
⋮----
result: TaskPushNotificationConfig
"""
    The result, containing the requested push notification configuration.
    """
⋮----
class GetTaskRequest(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC request for the `tasks/get` method.
    """
⋮----
method: Literal['tasks/get'] = 'tasks/get'
"""
    The method name. Must be 'tasks/get'.
    """
params: TaskQueryParams
"""
    The parameters for querying a task.
    """
⋮----
class JSONRPCErrorResponse(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC 2.0 Error Response object.
    """
⋮----
error: (
"""
    An object describing the error that occurred.
    """
⋮----
class ListTaskPushNotificationConfigSuccessResponse(A2ABaseModel)
⋮----
"""
    Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/list` method.
    """
⋮----
result: list[TaskPushNotificationConfig]
"""
    The result, containing an array of all push notification configurations for the task.
    """
⋮----
class MessageSendConfiguration(A2ABaseModel)
⋮----
"""
    Defines configuration options for a `message/send` or `message/stream` request.
    """
⋮----
accepted_output_modes: list[str] | None = None
"""
    A list of output MIME types the client is prepared to accept in the response.
    """
blocking: bool | None = None
"""
    If true, the client will wait for the task to complete. The server may reject this if the task is long-running.
    """
⋮----
"""
    The number of most recent messages from the task's history to retrieve in the response.
    """
push_notification_config: PushNotificationConfig | None = None
"""
    Configuration for the agent to send push notifications for updates after the initial response.
    """
⋮----
class OAuthFlows(A2ABaseModel)
⋮----
"""
    Defines the configuration for the supported OAuth 2.0 flows.
    """
⋮----
authorization_code: AuthorizationCodeOAuthFlow | None = None
"""
    Configuration for the OAuth Authorization Code flow. Previously called accessCode in OpenAPI 2.0.
    """
client_credentials: ClientCredentialsOAuthFlow | None = None
"""
    Configuration for the OAuth Client Credentials flow. Previously called application in OpenAPI 2.0.
    """
implicit: ImplicitOAuthFlow | None = None
"""
    Configuration for the OAuth Implicit flow.
    """
password: PasswordOAuthFlow | None = None
"""
    Configuration for the OAuth Resource Owner Password flow.
    """
⋮----
class Part(RootModel[TextPart | FilePart | DataPart])
⋮----
root: TextPart | FilePart | DataPart
"""
    A discriminated union representing a part of a message or artifact, which can
    be text, a file, or structured data.
    """
⋮----
class SetTaskPushNotificationConfigRequest(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC request for the `tasks/pushNotificationConfig/set` method.
    """
⋮----
method: Literal['tasks/pushNotificationConfig/set'] = (
"""
    The method name. Must be 'tasks/pushNotificationConfig/set'.
    """
params: TaskPushNotificationConfig
"""
    The parameters for setting the push notification configuration.
    """
⋮----
class SetTaskPushNotificationConfigSuccessResponse(A2ABaseModel)
⋮----
"""
    Represents a successful JSON-RPC response for the `tasks/pushNotificationConfig/set` method.
    """
⋮----
"""
    The result, containing the configured push notification settings.
    """
⋮----
class Artifact(A2ABaseModel)
⋮----
"""
    Represents a file, data structure, or other resource generated by an agent during a task.
    """
⋮----
artifact_id: str
"""
    A unique identifier for the artifact within the scope of the task.
    """
⋮----
"""
    An optional, human-readable description of the artifact.
    """
extensions: list[str] | None = None
"""
    The URIs of extensions that are relevant to this artifact.
    """
⋮----
"""
    Optional metadata for extensions. The key is an extension-specific identifier.
    """
⋮----
"""
    An optional, human-readable name for the artifact.
    """
parts: list[Part]
"""
    An array of content parts that make up the artifact.
    """
⋮----
class DeleteTaskPushNotificationConfigResponse(
⋮----
root: JSONRPCErrorResponse | DeleteTaskPushNotificationConfigSuccessResponse
"""
    Represents a JSON-RPC response for the `tasks/pushNotificationConfig/delete` method.
    """
⋮----
class GetTaskPushNotificationConfigResponse(
⋮----
root: JSONRPCErrorResponse | GetTaskPushNotificationConfigSuccessResponse
"""
    Represents a JSON-RPC response for the `tasks/pushNotificationConfig/get` method.
    """
⋮----
class ListTaskPushNotificationConfigResponse(
⋮----
root: JSONRPCErrorResponse | ListTaskPushNotificationConfigSuccessResponse
"""
    Represents a JSON-RPC response for the `tasks/pushNotificationConfig/list` method.
    """
⋮----
class Message(A2ABaseModel)
⋮----
"""
    Represents a single message in the conversation between a user and an agent.
    """
⋮----
context_id: str | None = None
"""
    The context identifier for this message, used to group related interactions.
    """
⋮----
"""
    The URIs of extensions that are relevant to this message.
    """
kind: Literal['message'] = 'message'
"""
    The type of this object, used as a discriminator. Always 'message' for a Message.
    """
message_id: str
"""
    A unique identifier for the message, typically a UUID, generated by the sender.
    """
⋮----
"""
    An array of content parts that form the message body. A message can be
    composed of multiple parts of different types (e.g., text and files).
    """
reference_task_ids: list[str] | None = None
"""
    A list of other task IDs that this message references for additional context.
    """
role: Role
⋮----
task_id: str | None = None
"""
    The identifier of the task this message is part of. Can be omitted for the first message of a new task.
    """
⋮----
class MessageSendParams(A2ABaseModel)
⋮----
"""
    Defines the parameters for a request to send a message to an agent. This can be used
    to create a new task, continue an existing one, or restart a task.
    """
⋮----
configuration: MessageSendConfiguration | None = None
"""
    Optional configuration for the send request.
    """
message: Message
"""
    The message object being sent to the agent.
    """
⋮----
"""
    Optional metadata for extensions.
    """
⋮----
class OAuth2SecurityScheme(A2ABaseModel)
⋮----
"""
    Defines a security scheme using OAuth 2.0.
    """
⋮----
flows: OAuthFlows
"""
    An object containing configuration information for the supported OAuth 2.0 flows.
    """
oauth2_metadata_url: str | None = None
"""
    URL to the oauth2 authorization server metadata
    [RFC8414](https://datatracker.ietf.org/doc/html/rfc8414). TLS is required.
    """
type: Literal['oauth2'] = 'oauth2'
"""
    The type of the security scheme. Must be 'oauth2'.
    """
⋮----
class SecurityScheme(
⋮----
"""
    Defines a security scheme that can be used to secure an agent's endpoints.
    This is a discriminated union type based on the OpenAPI 3.0 Security Scheme Object.
    """
⋮----
class SendMessageRequest(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC request for the `message/send` method.
    """
⋮----
method: Literal['message/send'] = 'message/send'
"""
    The method name. Must be 'message/send'.
    """
params: MessageSendParams
"""
    The parameters for sending a message.
    """
⋮----
class SendStreamingMessageRequest(A2ABaseModel)
⋮----
"""
    Represents a JSON-RPC request for the `message/stream` method.
    """
⋮----
method: Literal['message/stream'] = 'message/stream'
"""
    The method name. Must be 'message/stream'.
    """
⋮----
class SetTaskPushNotificationConfigResponse(
⋮----
root: JSONRPCErrorResponse | SetTaskPushNotificationConfigSuccessResponse
"""
    Represents a JSON-RPC response for the `tasks/pushNotificationConfig/set` method.
    """
⋮----
class TaskArtifactUpdateEvent(A2ABaseModel)
⋮----
"""
    An event sent by the agent to notify the client that an artifact has been
    generated or updated. This is typically used in streaming models.
    """
⋮----
append: bool | None = None
"""
    If true, the content of this artifact should be appended to a previously sent artifact with the same ID.
    """
artifact: Artifact
"""
    The artifact that was generated or updated.
    """
context_id: str
"""
    The context ID associated with the task.
    """
kind: Literal['artifact-update'] = 'artifact-update'
"""
    The type of this event, used as a discriminator. Always 'artifact-update'.
    """
last_chunk: bool | None = None
"""
    If true, this is the final chunk of the artifact.
    """
⋮----
"""
    The ID of the task this artifact belongs to.
    """
⋮----
class TaskStatus(A2ABaseModel)
⋮----
"""
    Represents the status of a task at a specific point in time.
    """
⋮----
message: Message | None = None
"""
    An optional, human-readable message providing more details about the current status.
    """
state: TaskState
"""
    The current state of the task's lifecycle.
    """
timestamp: str | None = Field(
"""
    An ISO 8601 datetime string indicating when this status was recorded.
    """
⋮----
class TaskStatusUpdateEvent(A2ABaseModel)
⋮----
"""
    An event sent by the agent to notify the client of a change in a task's status.
    This is typically used in streaming or subscription models.
    """
⋮----
final: bool
"""
    If true, this is the final event in the stream for this interaction.
    """
kind: Literal['status-update'] = 'status-update'
"""
    The type of this event, used as a discriminator. Always 'status-update'.
    """
⋮----
status: TaskStatus
"""
    The new status of the task.
    """
⋮----
"""
    The ID of the task that was updated.
    """
⋮----
class A2ARequest(
⋮----
"""
    A discriminated union representing all possible JSON-RPC 2.0 requests supported by the A2A specification.
    """
⋮----
class AgentCard(A2ABaseModel)
⋮----
"""
    The AgentCard is a self-describing manifest for an agent. It provides essential
    metadata including the agent's identity, capabilities, skills, supported
    communication methods, and security requirements.
    """
⋮----
additional_interfaces: list[AgentInterface] | None = None
"""
    A list of additional supported interfaces (transport and URL combinations).
    This allows agents to expose multiple transports, potentially at different URLs.

    Best practices:
    - SHOULD include all supported transports for completeness
    - SHOULD include an entry matching the main 'url' and 'preferredTransport'
    - MAY reuse URLs if multiple transports are available at the same endpoint
    - MUST accurately declare the transport available at each URL

    Clients can select any interface from this list based on their transport capabilities
    and preferences. This enables transport negotiation and fallback scenarios.
    """
capabilities: AgentCapabilities
"""
    A declaration of optional capabilities supported by the agent.
    """
default_input_modes: list[str]
"""
    Default set of supported input MIME types for all skills, which can be
    overridden on a per-skill basis.
    """
default_output_modes: list[str]
"""
    Default set of supported output MIME types for all skills, which can be
    overridden on a per-skill basis.
    """
description: str = Field(
"""
    A human-readable description of the agent, assisting users and other agents
    in understanding its purpose.
    """
documentation_url: str | None = None
"""
    An optional URL to the agent's documentation.
    """
icon_url: str | None = None
"""
    An optional URL to an icon for the agent.
    """
name: str = Field(..., examples=['Recipe Agent'])
"""
    A human-readable name for the agent.
    """
preferred_transport: str | None = Field(
"""
    The transport protocol for the preferred endpoint (the main 'url' field).
    If not specified, defaults to 'JSONRPC'.

    IMPORTANT: The transport specified here MUST be available at the main 'url'.
    This creates a binding between the main URL and its supported transport protocol.
    Clients should prefer this transport and URL combination when both are supported.
    """
protocol_version: str | None = '0.3.0'
"""
    The version of the A2A protocol this agent supports.
    """
provider: AgentProvider | None = None
"""
    Information about the agent's service provider.
    """
⋮----
"""
    A list of security requirement objects that apply to all agent interactions. Each object
    lists security schemes that can be used. Follows the OpenAPI 3.0 Security Requirement Object.
    This list can be seen as an OR of ANDs. Each object in the list describes one possible
    set of security requirements that must be present on a request. This allows specifying,
    for example, "callers must either use OAuth OR an API Key AND mTLS."
    """
security_schemes: dict[str, SecurityScheme] | None = None
"""
    A declaration of the security schemes available to authorize requests. The key is the
    scheme name. Follows the OpenAPI 3.0 Security Scheme Object.
    """
signatures: list[AgentCardSignature] | None = None
"""
    JSON Web Signatures computed for this AgentCard.
    """
skills: list[AgentSkill]
"""
    The set of skills, or distinct capabilities, that the agent can perform.
    """
supports_authenticated_extended_card: bool | None = None
"""
    If true, the agent can provide an extended agent card with additional details
    to authenticated users. Defaults to false.
    """
url: str = Field(..., examples=['https://api.example.com/a2a/v1'])
"""
    The preferred endpoint URL for interacting with the agent.
    This URL MUST support the transport specified by 'preferredTransport'.
    """
version: str = Field(..., examples=['1.0.0'])
"""
    The agent's own version number. The format is defined by the provider.
    """
⋮----
class GetAuthenticatedExtendedCardSuccessResponse(A2ABaseModel)
⋮----
"""
    Represents a successful JSON-RPC response for the `agent/getAuthenticatedExtendedCard` method.
    """
⋮----
result: AgentCard
"""
    The result is an Agent Card object.
    """
⋮----
class Task(A2ABaseModel)
⋮----
"""
    Represents a single, stateful operation or conversation between a client and an agent.
    """
⋮----
artifacts: list[Artifact] | None = None
"""
    A collection of artifacts generated by the agent during the execution of the task.
    """
⋮----
"""
    A server-generated identifier for maintaining context across multiple related tasks or interactions.
    """
history: list[Message] | None = None
"""
    An array of messages exchanged during the task, representing the conversation history.
    """
⋮----
"""
    A unique identifier for the task, generated by the server for a new task.
    """
kind: Literal['task'] = 'task'
"""
    The type of this object, used as a discriminator. Always 'task' for a Task.
    """
⋮----
"""
    The current status of the task, including its state and a descriptive message.
    """
⋮----
class CancelTaskSuccessResponse(A2ABaseModel)
⋮----
"""
    Represents a successful JSON-RPC response for the `tasks/cancel` method.
    """
⋮----
result: Task
"""
    The result, containing the final state of the canceled Task object.
    """
⋮----
class GetAuthenticatedExtendedCardResponse(
⋮----
root: JSONRPCErrorResponse | GetAuthenticatedExtendedCardSuccessResponse
"""
    Represents a JSON-RPC response for the `agent/getAuthenticatedExtendedCard` method.
    """
⋮----
class GetTaskSuccessResponse(A2ABaseModel)
⋮----
"""
    Represents a successful JSON-RPC response for the `tasks/get` method.
    """
⋮----
"""
    The result, containing the requested Task object.
    """
⋮----
class SendMessageSuccessResponse(A2ABaseModel)
⋮----
"""
    Represents a successful JSON-RPC response for the `message/send` method.
    """
⋮----
result: Task | Message
"""
    The result, which can be a direct reply Message or the initial Task object.
    """
⋮----
class SendStreamingMessageSuccessResponse(A2ABaseModel)
⋮----
"""
    Represents a successful JSON-RPC response for the `message/stream` method.
    The server may send multiple response objects for a single request.
    """
⋮----
result: Task | Message | TaskStatusUpdateEvent | TaskArtifactUpdateEvent
"""
    The result, which can be a Message, Task, or a streaming update event.
    """
⋮----
class CancelTaskResponse(
⋮----
root: JSONRPCErrorResponse | CancelTaskSuccessResponse
"""
    Represents a JSON-RPC response for the `tasks/cancel` method.
    """
⋮----
class GetTaskResponse(RootModel[JSONRPCErrorResponse | GetTaskSuccessResponse])
⋮----
root: JSONRPCErrorResponse | GetTaskSuccessResponse
"""
    Represents a JSON-RPC response for the `tasks/get` method.
    """
⋮----
class JSONRPCResponse(
⋮----
"""
    A discriminated union representing all possible JSON-RPC 2.0 responses
    for the A2A specification methods.
    """
⋮----
class SendMessageResponse(
⋮----
root: JSONRPCErrorResponse | SendMessageSuccessResponse
"""
    Represents a JSON-RPC response for the `message/send` method.
    """
⋮----
class SendStreamingMessageResponse(
⋮----
root: JSONRPCErrorResponse | SendStreamingMessageSuccessResponse
"""
    Represents a JSON-RPC response for the `message/stream` method.
    """

================
File: .coveragerc
================
[run]
branch = True
omit = 
    */tests/*
    */site-packages/*
    */__init__.py
    src/a2a/grpc/*

[report]
exclude_lines =
    pragma: no cover
    import
    def __repr__
    raise NotImplementedError
    if TYPE_CHECKING
    @abstractmethod
    pass
    raise ImportError

================
File: .git-blame-ignore-revs
================
# Template taken from https://github.com/v8/v8/blob/master/.git-blame-ignore-revs.
#
# This file contains a list of git hashes of revisions to be ignored by git blame. These
# revisions are considered "unimportant" in that they are unlikely to be what you are
# interested in when blaming. Most of these will probably be commits related to linting
# and code formatting.
#
# Instructions:
# - Only large (generally automated) reformatting or renaming CLs should be
#   added to this list. Do not put things here just because you feel they are
#   trivial or unimportant. If in doubt, do not put it on this list.
# - Precede each revision with a comment containing the PR title and number.
#   For bulk work over many commits, place all commits in a block with a single
#   comment at the top describing the work done in those commits.
# - Only put full 40-character hashes on this list (not short hashes or any
#   other revision reference).
# - Append to the bottom of the file (revisions should be in chronological order
#   from oldest to newest).
# - Because you must use a hash, you need to append to this list in a follow-up
#   PR to the actual reformatting PR that you are trying to ignore.
193693836e1ed8cd361e139668323d2e267a9eaa

================
File: .gitignore
================
.DS_Store
__pycache__
.env
.coverage
.mypy_cache
.pytest_cache
.ruff_cache
.venv
coverage.xml
.nox
spec.json

================
File: .jscpd.json
================
{
  "ignore": ["**/.github/**", "**/.git/**", "**/tests/**", "**/src/a2a/grpc/**", "**/.nox/**", "**/.venv/**"],
  "threshold": 3,
  "reporters": ["html", "markdown"]
}

================
File: .mypy.ini
================
[mypy]
exclude = src/a2a/grpc/
disable_error_code = import-not-found,annotation-unchecked,import-untyped
plugins = pydantic.mypy

[mypy-examples.*]
follow_imports = skip

================
File: .pre-commit-config.yaml
================
---
repos:
  # ===============================================
  # Pre-commit standard hooks (general file cleanup)
  # ===============================================
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v5.0.0
    hooks:
      - id: trailing-whitespace  # Removes extra whitespace at the end of lines
      - id: end-of-file-fixer  # Ensures files end with a newline
      - id: check-yaml  # Checks YAML file syntax (before formatting)
      - id: check-toml  # Checks TOML file syntax (before formatting)
      - id: check-added-large-files  # Prevents committing large files
        args: [--maxkb=500]  # Example: Limit to 500KB
      - id: check-merge-conflict  # Checks for merge conflict strings
      - id: detect-private-key  # Detects accidental private key commits

  # Formatter and linter for TOML files
  - repo: https://github.com/ComPWA/taplo-pre-commit
    rev: v0.9.3
    hooks:
      - id: taplo-format
      - id: taplo-lint

  # YAML files
  - repo: https://github.com/lyz-code/yamlfix
    rev: 1.17.0
    hooks:
      - id: yamlfix

  # ===============================================
  # Python Hooks
  # ===============================================
  # no_implicit_optional for ensuring explicit Optional types
  - repo: https://github.com/hauntsaninja/no_implicit_optional
    rev: '1.4'
    hooks:
      - id: no_implicit_optional
        args: [--use-union-or]

  # Pyupgrade for upgrading Python syntax to newer versions
  - repo: https://github.com/asottile/pyupgrade
    rev: v3.20.0
    hooks:
      - id: pyupgrade
        args: [--py310-plus]  # Target Python 3.10+ syntax, matching project's target

  # Autoflake for removing unused imports and variables
  - repo: https://github.com/pycqa/autoflake
    rev: v2.3.1
    hooks:
      - id: autoflake
        args: [--in-place, --remove-all-unused-imports]

  # Ruff for linting and formatting
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.12.0
    hooks:
      - id: ruff
        args: [--fix, --exit-zero]  # Apply fixes, and exit with 0 even if files were modified
        exclude: ^src/a2a/grpc/
      - id: ruff-format
        exclude: ^src/a2a/grpc/

  # Keep uv.lock in sync
  - repo: https://github.com/astral-sh/uv-pre-commit
    rev: 0.7.13
    hooks:
      - id: uv-lock

  # Commitzen for conventional commit messages
  - repo: https://github.com/commitizen-tools/commitizen
    rev: v4.8.3
    hooks:
      - id: commitizen
        stages: [commit-msg]

  # Gitleaks
  - repo: https://github.com/gitleaks/gitleaks
    rev: v8.27.2
    hooks:
      - id: gitleaks

================
File: .python-version
================
3.10

================
File: .ruff.toml
================
#################################################################################
#
# Ruff linter and code formatter for A2A
#
# This file follows the standards in Google Python Style Guide
# https://google.github.io/styleguide/pyguide.html
#

line-length = 80 # Google Style Guide §3.2: 80 columns
indent-width = 4 # Google Style Guide §3.4: 4 spaces

target-version = "py310" # Minimum Python version

[lint]
ignore = [
    "COM812", # Trailing comma missing.
    "FBT001", # Boolean positional arg in function definition
    "FBT002", # Boolean default value in function definition
    "D203",   # 1 blank line required before class docstring (Google: 0)
    "D213",   # Multi-line docstring summary should start at the second line (Google: first line)
    "D100",   # Ignore Missing docstring in public module (often desired at top level __init__.py)
    "D104",   # Ignore Missing docstring in public package (often desired at top level __init__.py)
    "D107",   # Ignore Missing docstring in __init__ (use class docstring)
    "TD002",  # Ignore Missing author in TODOs (often not required)
    "TD003",  # Ignore Missing issue link in TODOs (often not required/available)
    "T201",   # Ignore print presence
    "RUF012", # Ignore Mutable class attributes should be annotated with `typing.ClassVar`
    "E501",   # Ignore line length (handled by Ruff's dynamic line length)
    "ANN002",
    "ANN003",
    "ANN401",
]

select = [
    "E",  # pycodestyle errors (PEP 8)
    "W",  # pycodestyle warnings (PEP 8)
    "F",  # Pyflakes (logical errors, unused imports/variables)
    "I",  # isort (import sorting - Google Style §3.1.2)
    "D",  # pydocstyle (docstring conventions - Google Style §3.8)
    "N",  # pep8-naming (naming conventions - Google Style §3.16)
    "UP", # pyupgrade (use modern Python syntax)
    "ANN",# flake8-annotations (type hint usage/style - Google Style §2.22)
    "A",  # flake8-builtins (avoid shadowing builtins)
    "B",  # flake8-bugbear (potential logic errors & style issues - incl. mutable defaults B006, B008)
    "C4", # flake8-comprehensions (unnecessary list/set/dict comprehensions)
    "ISC",# flake8-implicit-str-concat (disallow implicit string concatenation across lines)
    "T20",# flake8-print (discourage `print` - prefer logging)
    "SIM",# flake8-simplify (simplify code, e.g., `if cond: return True else: return False`)
    "PTH",# flake8-use-pathlib (use pathlib instead of os.path where possible)
    "PL", # Pylint rules ported to Ruff (PLC, PLE, PLR, PLW)
    "PIE",# flake8-pie (misc code improvements, e.g., no-unnecessary-pass)
    "RUF",# Ruff-specific rules (e.g., RUF001-003 ambiguous unicode, RUF013 implicit optional)
    "RET",# flake8-return (consistency in return statements)
    "SLF",# flake8-self (check for private member access via `self`)
    "TID",# flake8-tidy-imports (relative imports, banned imports - configure if needed)
    "YTT",# flake8-boolean-trap (checks for boolean positional arguments, truthiness tests - Google Style §3.10)
    "TD", # flake8-todos (check TODO format - Google Style §3.7)
    "TCH",# flake8-type-checking (helps manage TYPE_CHECKING blocks and imports)
    "PYI",# flake8-pyi (best practices for .pyi stub files, some rules are useful for .py too)
]

exclude = [
    ".bzr",
    ".direnv",
    ".eggs",
    ".git",
    ".hg",
    ".mypy_cache",
    ".nox",
    ".pants.d",
    ".pytype",
    ".ruff_cache",
    ".svn",
    ".tox",
    ".venv",
    "__pypackages__",
    "_build",
    "buck-out",
    "build",
    "dist",
    "node_modules",
    "venv",
    "*/migrations/*",
    "src/a2a/grpc/**",
    "tests/**",
]

[lint.isort]
#force-sort-within-sections = true
#combine-as-imports = true
case-sensitive = true
#force-single-line = false
#known-first-party = []
#known-third-party = []
lines-after-imports = 2
lines-between-types = 1
#no-lines-before = ["LOCALFOLDER"]
#required-imports = []
#section-order = ["future", "standard-library", "third-party", "first-party", "local-folder"]

[lint.pydocstyle]
convention = "google"
ignore-decorators = ["typing.overload", "abc.abstractmethod"]

[lint.flake8-annotations]
mypy-init-return = true
allow-star-arg-any = true

[lint.pep8-naming]
ignore-names = ["test_*", "setUp", "tearDown", "mock_*"]
classmethod-decorators = ["classmethod", "pydantic.validator", "pydantic.root_validator"]
staticmethod-decorators = ["staticmethod"]

[lint.flake8-tidy-imports]
ban-relative-imports = "all" # Google generally prefers absolute imports (§3.1.2)

[lint.flake8-quotes]
docstring-quotes = "double"
inline-quotes = "single"

[lint.per-file-ignores]
"__init__.py" = ["F401", "D", "ANN"]  # Ignore unused imports in __init__.py
"*_test.py" = [
    "D",      # All pydocstyle rules
    "ANN",    # Missing type annotation for function argument
    "RUF013", # Implicit optional type in test function signatures
    "S101",   # Use of `assert` detected (expected in tests)
    "PLR2004",
    "SLF001",
]
"test_*.py" = [
    "D",
    "ANN",
    "RUF013",
    "S101",
    "PLR2004",
    "SLF001",
]
"types.py" = ["D", "E501"]  # Ignore docstring and annotation issues in types.py
"proto_utils.py" = ["D102", "PLR0911"]
"helpers.py" = ["ANN001", "ANN201", "ANN202"]

[format]
exclude = [
    "src/a2a/grpc/**",
]
docstring-code-format = true
docstring-code-line-length = "dynamic" # Or set to 80
quote-style = "single"
indent-style = "space"

================
File: buf.gen.yaml
================
---
version: v2
inputs:
  - git_repo: https://github.com/a2aproject/A2A.git
    ref: main
    subdir: specification/grpc
managed:
  enabled: true
# Python Generation
# Using remote plugins. To use local plugins replace remote with local
# pip install protobuf grpcio-tools
# Optionally, install plugin to generate stubs for grpc services
# pip install mypy-protobuf
# Generate python protobuf code
# - local: protoc-gen-python
# - out: src/python
# Generate gRPC stubs
# - local: protoc-gen-grpc-python
# - out: src/python
plugins:
  # Generate python protobuf related code
  # Generates *_pb2.py files, one for each .proto
  - remote: buf.build/protocolbuffers/python:v29.3
    out: src/a2a/grpc
  # Generate python service code.
  # Generates *_pb2_grpc.py
  - remote: buf.build/grpc/python
    out: src/a2a/grpc
  # Generates *_pb2.pyi files.
  - remote: buf.build/protocolbuffers/pyi
    out: src/a2a/grpc

================
File: CHANGELOG.md
================
# Changelog

## [0.3.0](https://github.com/a2aproject/a2a-python/compare/v0.2.16...v0.3.0) (2025-07-31)


### ⚠ BREAKING CHANGES

* **deps:** Make opentelemetry an optional dependency ([#369](https://github.com/a2aproject/a2a-python/issues/369))
* **spec:** Update Agent Card Well-Known Path to `/.well-known/agent-card.json` ([#320](https://github.com/a2aproject/a2a-python/issues/320))
* Remove custom `__getattr__` and `__setattr__` for `camelCase` fields in `types.py` ([#335](https://github.com/a2aproject/a2a-python/issues/335))
  * Use Script [`refactor_camel_to_snake.sh`](https://github.com/a2aproject/a2a-samples/blob/main/samples/python/refactor_camel_to_snake.sh) to convert your codebase to the new field names.
* Add mTLS to SecuritySchemes, add oauth2 metadata url field, allow Skills to specify Security ([#362](https://github.com/a2aproject/a2a-python/issues/362))
* Support for serving agent card at deprecated path ([#352](https://github.com/a2aproject/a2a-python/issues/352))

### Features

* Add `metadata` as parameter to `TaskUpdater.update_status()` ([#371](https://github.com/a2aproject/a2a-python/issues/371)) ([9444ed6](https://github.com/a2aproject/a2a-python/commit/9444ed629b925e285cd08aae3078ccd8b9bda6f2))
* Add mTLS to SecuritySchemes, add oauth2 metadata url field, allow Skills to specify Security ([#362](https://github.com/a2aproject/a2a-python/issues/362)) ([be6c517](https://github.com/a2aproject/a2a-python/commit/be6c517e1f2db50a9217de91a9080810c36a7a1b))
* Add RESTful API Serving ([#348](https://github.com/a2aproject/a2a-python/issues/348)) ([82a6b7c](https://github.com/a2aproject/a2a-python/commit/82a6b7cc9b83484a4ceabc2323e14e2ff0270f87))
* Add server-side support for plumbing requested and activated extensions ([#333](https://github.com/a2aproject/a2a-python/issues/333)) ([4d5b92c](https://github.com/a2aproject/a2a-python/commit/4d5b92c61747edcabcfd825256a5339bb66c3e91))
* Allow agent cards (default and extended) to be dynamic ([#365](https://github.com/a2aproject/a2a-python/issues/365)) ([ee92aab](https://github.com/a2aproject/a2a-python/commit/ee92aabe1f0babbba2fdbdefe21f2dbe7a899077))
* Support for serving agent card at deprecated path ([#352](https://github.com/a2aproject/a2a-python/issues/352)) ([2444034](https://github.com/a2aproject/a2a-python/commit/2444034b7aa1d1af12bedecf40f27dafc4efec95))
* support non-blocking `sendMessage` ([#349](https://github.com/a2aproject/a2a-python/issues/349)) ([70b4999](https://github.com/a2aproject/a2a-python/commit/70b499975f0811c8055ebd674bcb4070805506d4))
* Type update to support fetching extended card ([#361](https://github.com/a2aproject/a2a-python/issues/361)) ([83304bb](https://github.com/a2aproject/a2a-python/commit/83304bb669403b51607973c1a965358d2e8f6ab0))


### Bug Fixes

* Add Input Validation for Task Context IDs in new_task Function ([#340](https://github.com/a2aproject/a2a-python/issues/340)) ([a7ed7ef](https://github.com/a2aproject/a2a-python/commit/a7ed7efed8fcdcc556616a5fc1cb8f968a116733))
* **deps:** Reduce FastAPI library required version to `0.95.0` ([#372](https://github.com/a2aproject/a2a-python/issues/372)) ([a319334](https://github.com/a2aproject/a2a-python/commit/a31933456e08929f665ccec57ac07b8b9118990d))
* Remove `DeprecationWarning` for regular properties ([#345](https://github.com/a2aproject/a2a-python/issues/345)) ([2806f3e](https://github.com/a2aproject/a2a-python/commit/2806f3eb7e1293924bb8637fd9c2cfe855858592))
* **spec:** Add `SendMessageRequest.request` `json_name` mapping to `message` proto ([bc97cba](https://github.com/a2aproject/a2a-python/commit/bc97cba5945a49bea808feb2b1dc9eeb30007599))
* **spec:** Add Transport enum to specification (https://github.com/a2aproject/A2A/pull/909) ([d9e463c](https://github.com/a2aproject/a2a-python/commit/d9e463cf1f8fbe486d37da3dd9009a19fe874ff0))


### Documentation

* Address typos in docstrings and docs. ([#370](https://github.com/a2aproject/a2a-python/issues/370)) ([ee48d68](https://github.com/a2aproject/a2a-python/commit/ee48d68d6c42a2a0c78f8a4666d1aded1a362e78))


### Miscellaneous Chores

* Add support for authenticated extended card method ([#356](https://github.com/a2aproject/a2a-python/issues/356)) ([b567e80](https://github.com/a2aproject/a2a-python/commit/b567e80735ae7e75f0bdb22f025b97895ce3b0dd))


### Code Refactoring

* **deps:** Make opentelemetry an optional dependency ([#369](https://github.com/a2aproject/a2a-python/issues/369)) ([9ad8b96](https://github.com/a2aproject/a2a-python/commit/9ad8b9623ffdc074ec561cbe65cfc2a2ba38bd0b))
* Remove custom `__getattr__` and `__setattr__` for `camelCase` fields in `types.py` ([#335](https://github.com/a2aproject/a2a-python/issues/335)) ([cd94167](https://github.com/a2aproject/a2a-python/commit/cd941675d10868922adf14266901d035516a31cf))
* **spec:** Update Agent Card Well-Known Path to `/.well-known/agent-card.json` ([#320](https://github.com/a2aproject/a2a-python/issues/320)) ([270ea9b](https://github.com/a2aproject/a2a-python/commit/270ea9b0822b689e50ed12f745a24a17e7917e73))

## [0.2.16](https://github.com/a2aproject/a2a-python/compare/v0.2.15...v0.2.16) (2025-07-21)


### Features

* Convert fields in `types.py` to use `snake_case` ([#199](https://github.com/a2aproject/a2a-python/issues/199)) ([0bb5563](https://github.com/a2aproject/a2a-python/commit/0bb55633272605a0404fc14c448a9dcaca7bb693))


### Bug Fixes

* Add deprecation warning for camelCase alias ([#334](https://github.com/a2aproject/a2a-python/issues/334)) ([f22b384](https://github.com/a2aproject/a2a-python/commit/f22b384d919e349be8d275c8f44bd760d627bcb9))
* client should not specify `taskId` if it doesn't exist ([#264](https://github.com/a2aproject/a2a-python/issues/264)) ([97f1093](https://github.com/a2aproject/a2a-python/commit/97f109326c7fe291c96bb51935ac80e0fab4cf66))

## [0.2.15](https://github.com/a2aproject/a2a-python/compare/v0.2.14...v0.2.15) (2025-07-21)


### Bug Fixes

* Add Input Validation for Empty Message Content ([#327](https://github.com/a2aproject/a2a-python/issues/327)) ([5061834](https://github.com/a2aproject/a2a-python/commit/5061834e112a4eb523ac505f9176fc42d86d8178))
* Prevent import grpc issues for Client after making dependencies optional ([#330](https://github.com/a2aproject/a2a-python/issues/330)) ([53ad485](https://github.com/a2aproject/a2a-python/commit/53ad48530b47ef1cbd3f40d0432f9170b663839d)), closes [#326](https://github.com/a2aproject/a2a-python/issues/326)

## [0.2.14](https://github.com/a2aproject/a2a-python/compare/v0.2.13...v0.2.14) (2025-07-18)


### Features

* Set grpc dependencies as optional ([#322](https://github.com/a2aproject/a2a-python/issues/322)) ([365f158](https://github.com/a2aproject/a2a-python/commit/365f158f87166838b55bdadd48778cb313a453e1))
* **spec:** Update A2A types from specification 🤖 ([#325](https://github.com/a2aproject/a2a-python/issues/325)) ([02e7a31](https://github.com/a2aproject/a2a-python/commit/02e7a3100e000e115b4aeec7147cf8fc1948c107))

## [0.2.13](https://github.com/a2aproject/a2a-python/compare/v0.2.12...v0.2.13) (2025-07-17)


### Features

* Add `get_data_parts()` and `get_file_parts()` helper methods ([#312](https://github.com/a2aproject/a2a-python/issues/312)) ([5b98c32](https://github.com/a2aproject/a2a-python/commit/5b98c3240db4ff6007e242742f76822fc6ea380c))
* Support for Database based Push Config Store ([#299](https://github.com/a2aproject/a2a-python/issues/299)) ([e5d99ee](https://github.com/a2aproject/a2a-python/commit/e5d99ee9e478cda5e93355cba2e93f1d28039806))
* Update A2A types from specification 🤖 ([#319](https://github.com/a2aproject/a2a-python/issues/319)) ([18506a4](https://github.com/a2aproject/a2a-python/commit/18506a4fe32c1956725d8f205ec7848f7b86c77d))


### Bug Fixes

* Add Input Validation for Task IDs in TaskManager ([#310](https://github.com/a2aproject/a2a-python/issues/310)) ([a38d438](https://github.com/a2aproject/a2a-python/commit/a38d43881d8476e6fbcb9766b59e3378dbe64306))
* Add validation for empty artifact lists in `completed_task` ([#308](https://github.com/a2aproject/a2a-python/issues/308)) ([c4a324d](https://github.com/a2aproject/a2a-python/commit/c4a324dcb693f19fbbf90cee483f6a912698a921))
* Handle readtimeout errors. ([#305](https://github.com/a2aproject/a2a-python/issues/305)) ([b94b8f5](https://github.com/a2aproject/a2a-python/commit/b94b8f52bf58315f3ef138b6a1ffaf894f35bcef)), closes [#249](https://github.com/a2aproject/a2a-python/issues/249)


### Documentation

* Update Documentation Site Link ([#315](https://github.com/a2aproject/a2a-python/issues/315)) ([edf392c](https://github.com/a2aproject/a2a-python/commit/edf392cfe531d0448659e2f08ab08f0ba05475b3))

## [0.2.12](https://github.com/a2aproject/a2a-python/compare/v0.2.11...v0.2.12) (2025-07-14)


### Features

* add `metadata` property to `RequestContext` ([#302](https://github.com/a2aproject/a2a-python/issues/302)) ([e781ced](https://github.com/a2aproject/a2a-python/commit/e781ced3b082ef085f9aeef02ceebb9b35c68280))
* add A2ABaseModel ([#292](https://github.com/a2aproject/a2a-python/issues/292)) ([24f2eb0](https://github.com/a2aproject/a2a-python/commit/24f2eb0947112539cbd4e493c98d0d9dadc87f05))
* add support for notification tokens in PushNotificationSender ([#266](https://github.com/a2aproject/a2a-python/issues/266)) ([75aa4ed](https://github.com/a2aproject/a2a-python/commit/75aa4ed866a6b4005e59eb000e965fb593e0888f))
* Update A2A types from specification 🤖 ([#289](https://github.com/a2aproject/a2a-python/issues/289)) ([ecb321a](https://github.com/a2aproject/a2a-python/commit/ecb321a354d691ca90b52cc39e0a397a576fd7d7))


### Bug Fixes

* add proper a2a request body documentation to Swagger UI ([#276](https://github.com/a2aproject/a2a-python/issues/276)) ([4343be9](https://github.com/a2aproject/a2a-python/commit/4343be99ad0df5eb6908867b71d55b1f7d0fafc6)), closes [#274](https://github.com/a2aproject/a2a-python/issues/274)
* Handle asyncio.cancellederror and raise to propagate back ([#293](https://github.com/a2aproject/a2a-python/issues/293)) ([9d6cb68](https://github.com/a2aproject/a2a-python/commit/9d6cb68a1619960b9c9fd8e7aa08ffb27047343f))
* Improve error handling in task creation ([#294](https://github.com/a2aproject/a2a-python/issues/294)) ([6412c75](https://github.com/a2aproject/a2a-python/commit/6412c75413e26489bd3d33f59e41b626a71807d3))
* Resolve dependency issue with sql stores ([#303](https://github.com/a2aproject/a2a-python/issues/303)) ([2126828](https://github.com/a2aproject/a2a-python/commit/2126828b5cb6291f47ca15d56c0e870950f17536))
* Send push notifications for message/send ([#298](https://github.com/a2aproject/a2a-python/issues/298)) ([0274112](https://github.com/a2aproject/a2a-python/commit/0274112bb5b077c17b344da3a65277f2ad67d38f))
* **server:** Improve event consumer error handling ([#282](https://github.com/a2aproject/a2a-python/issues/282)) ([a5786a1](https://github.com/a2aproject/a2a-python/commit/a5786a112779a21819d28e4dfee40fa11f1bb49a))

## [0.2.11](https://github.com/a2aproject/a2a-python/compare/v0.2.10...v0.2.11) (2025-07-07)


### ⚠ BREAKING CHANGES

* Removes `push_notifier` interface from the SDK and introduces `push_notification_config_store` and `push_notification_sender` for supporting push notifications.

### Features

* Add constants for Well-Known URIs ([#271](https://github.com/a2aproject/a2a-python/issues/271)) ([1c8e12e](https://github.com/a2aproject/a2a-python/commit/1c8e12e448dc7469e508fccdac06818836f5b520))
* Adds support for List and Delete push notification configurations. ([f1b576e](https://github.com/a2aproject/a2a-python/commit/f1b576e061e7a3ab891d8368ade56c7046684c5e))
* Adds support for more than one `push_notification_config` per task. ([f1b576e](https://github.com/a2aproject/a2a-python/commit/f1b576e061e7a3ab891d8368ade56c7046684c5e))
* **server:** Add lock to TaskUpdater to prevent race conditions ([#279](https://github.com/a2aproject/a2a-python/issues/279)) ([1022093](https://github.com/a2aproject/a2a-python/commit/1022093110100da27f040be4b35831bf8b1fe094))
* Support for database backend Task Store ([#259](https://github.com/a2aproject/a2a-python/issues/259)) ([7c46e70](https://github.com/a2aproject/a2a-python/commit/7c46e70b3142f3ec274c492bacbfd6e8f0204b36))


### Code Refactoring

* Removes `push_notifier` interface from the SDK and introduces `push_notification_config_store` and `push_notification_sender` for supporting push notifications. ([f1b576e](https://github.com/a2aproject/a2a-python/commit/f1b576e061e7a3ab891d8368ade56c7046684c5e))

## [0.2.10](https://github.com/a2aproject/a2a-python/compare/v0.2.9...v0.2.10) (2025-06-30)


### ⚠ BREAKING CHANGES

* Update to A2A Spec Version [0.2.5](https://github.com/a2aproject/A2A/releases/tag/v0.2.5) ([#197](https://github.com/a2aproject/a2a-python/issues/197))

### Features

* Add `append` and `last_chunk` to `add_artifact` method on `TaskUpdater` ([#186](https://github.com/a2aproject/a2a-python/issues/186)) ([8c6560f](https://github.com/a2aproject/a2a-python/commit/8c6560fd403887fab9d774bfcc923a5f6f459364))
* add a2a routes to existing app ([#188](https://github.com/a2aproject/a2a-python/issues/188)) ([32fecc7](https://github.com/a2aproject/a2a-python/commit/32fecc7194a61c2f5be0b8795d5dc17cdbab9040))
* Add middleware to the client SDK ([#171](https://github.com/a2aproject/a2a-python/issues/171)) ([efaabd3](https://github.com/a2aproject/a2a-python/commit/efaabd3b71054142109b553c984da1d6e171db24))
* Add more task state management methods to TaskUpdater ([#208](https://github.com/a2aproject/a2a-python/issues/208)) ([2b3bf6d](https://github.com/a2aproject/a2a-python/commit/2b3bf6d53ac37ed93fc1b1c012d59c19060be000))
* raise error for tasks in terminal states ([#215](https://github.com/a2aproject/a2a-python/issues/215)) ([a0bf13b](https://github.com/a2aproject/a2a-python/commit/a0bf13b208c90b439b4be1952c685e702c4917a0))

### Bug Fixes

* `consume_all` doesn't catch `asyncio.TimeoutError` in python 3.10 ([#216](https://github.com/a2aproject/a2a-python/issues/216)) ([39307f1](https://github.com/a2aproject/a2a-python/commit/39307f15a1bb70eb77aee2211da038f403571242))
* Append metadata and context id when processing TaskStatusUpdateE… ([#238](https://github.com/a2aproject/a2a-python/issues/238)) ([e106020](https://github.com/a2aproject/a2a-python/commit/e10602033fdd4f4e6b61af717ffc242d772545b3))
* Fix reference to `grpc.aio.ServicerContext` ([#237](https://github.com/a2aproject/a2a-python/issues/237)) ([0c1987b](https://github.com/a2aproject/a2a-python/commit/0c1987bb85f3e21089789ee260a0c62ac98b66a5))
* Fixes Short Circuit clause for context ID ([#236](https://github.com/a2aproject/a2a-python/issues/236)) ([a5509e6](https://github.com/a2aproject/a2a-python/commit/a5509e6b37701dfb5c729ccc12531e644a12f8ae))
* Resolve `APIKeySecurityScheme` parsing failed ([#226](https://github.com/a2aproject/a2a-python/issues/226)) ([aa63b98](https://github.com/a2aproject/a2a-python/commit/aa63b982edc2a07fd0df0b01fb9ad18d30b35a79))
* send notifications on message not streaming ([#219](https://github.com/a2aproject/a2a-python/issues/219)) ([91539d6](https://github.com/a2aproject/a2a-python/commit/91539d69e5c757712c73a41ab95f1ec6656ef5cd)), closes [#218](https://github.com/a2aproject/a2a-python/issues/218)

## [0.2.9](https://github.com/a2aproject/a2a-python/compare/v0.2.8...v0.2.9) (2025-06-24)

### Bug Fixes

* Set `protobuf==5.29.5` and `fastapi>=0.115.2` to prevent version conflicts ([#224](https://github.com/a2aproject/a2a-python/issues/224)) ([1412a85](https://github.com/a2aproject/a2a-python/commit/1412a855b4980d8373ed1cea38c326be74069633))

## [0.2.8](https://github.com/a2aproject/a2a-python/compare/v0.2.7...v0.2.8) (2025-06-12)


### Features

* Add HTTP Headers to ServerCallContext for Improved Handler Access ([#182](https://github.com/a2aproject/a2a-python/issues/182)) ([d5e5f5f](https://github.com/a2aproject/a2a-python/commit/d5e5f5f7e7a3cab7de13cff545a874fc58d85e46))
* Update A2A types from specification 🤖 ([#191](https://github.com/a2aproject/a2a-python/issues/191)) ([174230b](https://github.com/a2aproject/a2a-python/commit/174230bf6dfb6bf287d233a101b98cc4c79cad19))


### Bug Fixes

* Add `protobuf==6.31.1` to dependencies ([#189](https://github.com/a2aproject/a2a-python/issues/189)) ([ae1c31c](https://github.com/a2aproject/a2a-python/commit/ae1c31c1da47f6965c02e0564dc7d3791dd03e2c)), closes [#185](https://github.com/a2aproject/a2a-python/issues/185)

## [0.2.7](https://github.com/a2aproject/a2a-python/compare/v0.2.6...v0.2.7) (2025-06-11)


### Features

* Update A2A types from specification 🤖 ([#179](https://github.com/a2aproject/a2a-python/issues/179)) ([3ef4240](https://github.com/a2aproject/a2a-python/commit/3ef42405f6096281fe90b1df399731bd009bde12))

## [0.2.6](https://github.com/a2aproject/a2a-python/compare/v0.2.5...v0.2.6) (2025-06-09)


### ⚠ BREAKING CHANGES

* Add FastAPI JSONRPC Application ([#104](https://github.com/a2aproject/a2a-python/issues/104))

### Features

* Add FastAPI JSONRPC Application ([#104](https://github.com/a2aproject/a2a-python/issues/104)) ([0e66e1f](https://github.com/a2aproject/a2a-python/commit/0e66e1f81f98d7e2cf50b1c100e35d13ad7149dc))
* Add gRPC server and client support ([#162](https://github.com/a2aproject/a2a-python/issues/162)) ([a981605](https://github.com/a2aproject/a2a-python/commit/a981605dbb32e87bd241b64bf2e9bb52831514d1))
* add reject method to task_updater ([#147](https://github.com/a2aproject/a2a-python/issues/147)) ([2a6ef10](https://github.com/a2aproject/a2a-python/commit/2a6ef109f8b743f8eb53d29090cdec7df143b0b4))
* Add timestamp to `TaskStatus` updates on `TaskUpdater` ([#140](https://github.com/a2aproject/a2a-python/issues/140)) ([0c9df12](https://github.com/a2aproject/a2a-python/commit/0c9df125b740b947b0e4001421256491b5f87920))
* **spec:** Add an optional iconUrl field to the AgentCard 🤖 ([a1025f4](https://github.com/a2aproject/a2a-python/commit/a1025f406acd88e7485a5c0f4dd8a42488c41fa2))


### Bug Fixes

* Correctly adapt starlette BaseUser to A2A User ([#133](https://github.com/a2aproject/a2a-python/issues/133)) ([88d45eb](https://github.com/a2aproject/a2a-python/commit/88d45ebd935724e6c3ad614bf503defae4de5d85))
* Event consumer should stop on input_required ([#167](https://github.com/a2aproject/a2a-python/issues/167)) ([51c2d8a](https://github.com/a2aproject/a2a-python/commit/51c2d8addf9e89a86a6834e16deb9f4ac0e05cc3))
* Fix Release Version ([#161](https://github.com/a2aproject/a2a-python/issues/161)) ([011d632](https://github.com/a2aproject/a2a-python/commit/011d632b27b201193813ce24cf25e28d1335d18e))
* generate StrEnum types for enums ([#134](https://github.com/a2aproject/a2a-python/issues/134)) ([0c49dab](https://github.com/a2aproject/a2a-python/commit/0c49dabcdb9d62de49fda53d7ce5c691b8c1591c))
* library should released as 0.2.6 ([d8187e8](https://github.com/a2aproject/a2a-python/commit/d8187e812d6ac01caedf61d4edaca522e583d7da))
* remove error types from enqueable events ([#138](https://github.com/a2aproject/a2a-python/issues/138)) ([511992f](https://github.com/a2aproject/a2a-python/commit/511992fe585bd15e956921daeab4046dc4a50a0a))
* **stream:** don't block event loop in EventQueue ([#151](https://github.com/a2aproject/a2a-python/issues/151)) ([efd9080](https://github.com/a2aproject/a2a-python/commit/efd9080b917c51d6e945572fd123b07f20974a64))
* **task_updater:** fix potential duplicate artifact_id from default v… ([#156](https://github.com/a2aproject/a2a-python/issues/156)) ([1f0a769](https://github.com/a2aproject/a2a-python/commit/1f0a769c1027797b2f252e4c894352f9f78257ca))


### Documentation

* remove final and metadata fields from docstring ([#66](https://github.com/a2aproject/a2a-python/issues/66)) ([3c50ee1](https://github.com/a2aproject/a2a-python/commit/3c50ee1f64c103a543c8afb6d2ac3a11063b0f43))
* Update Links to Documentation Site ([5e7d418](https://github.com/a2aproject/a2a-python/commit/5e7d4180f7ae0ebeb76d976caa5ef68b4277ce54))

## [0.2.5](https://github.com/a2aproject/a2a-python/compare/v0.2.4...v0.2.5) (2025-05-27)


### Features

* Add a User representation to ServerCallContext ([#116](https://github.com/a2aproject/a2a-python/issues/116)) ([2cc2a0d](https://github.com/a2aproject/a2a-python/commit/2cc2a0de93631aa162823d43fe488173ed8754dc))
* Add functionality for extended agent card.  ([#31](https://github.com/a2aproject/a2a-python/issues/31)) ([20f0826](https://github.com/a2aproject/a2a-python/commit/20f0826a2cb9b77b89b85189fd91e7cd62318a30))
* Introduce a ServerCallContext ([#94](https://github.com/a2aproject/a2a-python/issues/94)) ([85b521d](https://github.com/a2aproject/a2a-python/commit/85b521d8a790dacb775ef764a66fbdd57b180da3))


### Bug Fixes

* fix hello world example for python 3.12 ([#98](https://github.com/a2aproject/a2a-python/issues/98)) ([536e4a1](https://github.com/a2aproject/a2a-python/commit/536e4a11f2f32332968a06e7d0bc4615e047a56c))
* Remove unused dependencies and update py version ([#119](https://github.com/a2aproject/a2a-python/issues/119)) ([9f8bc02](https://github.com/a2aproject/a2a-python/commit/9f8bc023b45544942583818968f3d320e5ff1c3b))
* Update hello world test client to match sdk behavior. Also down-level required python version ([#117](https://github.com/a2aproject/a2a-python/issues/117)) ([04c7c45](https://github.com/a2aproject/a2a-python/commit/04c7c452f5001d69524d94095d11971c1e857f75))
* Update the google adk demos to use ADK v1.0 ([#95](https://github.com/a2aproject/a2a-python/issues/95)) ([c351656](https://github.com/a2aproject/a2a-python/commit/c351656a91c37338668b0cd0c4db5fedd152d743))


### Documentation

* Update README for Python 3.10+ support ([#90](https://github.com/a2aproject/a2a-python/issues/90)) ([e0db20f](https://github.com/a2aproject/a2a-python/commit/e0db20ffc20aa09ee68304cc7e2a67c32ecdd6a8))

## [0.2.4](https://github.com/a2aproject/a2a-python/compare/v0.2.3...v0.2.4) (2025-05-22)

### Features

* Update to support python 3.10 ([#85](https://github.com/a2aproject/a2a-python/issues/85)) ([fd9c3b5](https://github.com/a2aproject/a2a-python/commit/fd9c3b5b0bbef509789a701171d95f690c84750b))


### Bug Fixes

* Throw exception for task_id mismatches ([#70](https://github.com/a2aproject/a2a-python/issues/70)) ([a9781b5](https://github.com/a2aproject/a2a-python/commit/a9781b589075280bfaaab5742d8b950916c9de74))

## [0.2.3](https://github.com/a2aproject/a2a-python/compare/v0.2.2...v0.2.3) (2025-05-20)


### Features

* Add request context builder with referenceTasks ([#56](https://github.com/a2aproject/a2a-python/issues/56)) ([f20bfe7](https://github.com/a2aproject/a2a-python/commit/f20bfe74b8cc854c9c29720b2ea3859aff8f509e))

## [0.2.2](https://github.com/a2aproject/a2a-python/compare/v0.2.1...v0.2.2) (2025-05-20)


### Documentation

* Write/Update Docstrings for Classes/Methods ([#59](https://github.com/a2aproject/a2a-python/issues/59)) ([9f773ef](https://github.com/a2aproject/a2a-python/commit/9f773eff4dddc4eec723d519d0050f21b9ccc042))

================
File: CODE_OF_CONDUCT.md
================
# Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to make participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, gender identity and expression, level of
experience, education, socio-economic status, nationality, personal appearance,
race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment
include:

- Using welcoming and inclusive language
- Being respectful of differing viewpoints and experiences
- Gracefully accepting constructive criticism
- Focusing on what is best for the community
- Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

- The use of sexualized language or imagery and unwelcome sexual attention or
  advances
- Trolling, insulting/derogatory comments, and personal or political attacks
- Public or private harassment
- Publishing others' private information, such as a physical or electronic
  address, without explicit permission
- Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, or to ban temporarily or permanently any
contributor for other behaviors that they deem inappropriate, threatening,
offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project email
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.

This Code of Conduct also applies outside the project spaces when the Project
Steward has a reasonable belief that an individual's behavior may have a
negative impact on the project or its community.

## Conflict Resolution

We do not believe that all conflict is bad; healthy debate and disagreement
often yield positive results. However, it is never okay to be disrespectful or
to engage in behavior that violates the project's code of conduct.

If you see someone violating the code of conduct, you are encouraged to address
the behavior directly with those involved. Many issues can be resolved quickly
and easily, and this gives people more control over the outcome of their
dispute. If you are unable to resolve the matter for any reason, or if the
behavior is threatening or harassing, report it. We are dedicated to providing
an environment where participants feel welcome and safe.

Reports should be directed to _[PROJECT STEWARD NAME(s) AND EMAIL(s)]_, the
Project Steward(s) for _[PROJECT NAME]_. It is the Project Steward's duty to
receive and address reported violations of the code of conduct. They will then
work with a committee consisting of representatives from the Open Source
Programs Office and the Google Open Source Strategy team. If for any reason you
are uncomfortable reaching out to the Project Steward, please email
opensource@google.com.

We will investigate every complaint, but you may not receive a direct response.
We will use our discretion in determining when and how to follow up on reported
incidents, which may range from not taking action to permanent expulsion from
the project and project-sponsored spaces. We will notify the accused of the
report and provide them an opportunity to discuss it before any action is taken.
The identity of the reporter will be omitted from the details of the report
supplied to the accused. In potentially harmful situations, such as ongoing
harassment or threats to anyone's safety, we may take action without notice.

## Attribution

This Code of Conduct is adapted from the Contributor Covenant, version 1.4,
available at
https://www.contributor-covenant.org/version/1/4/code-of-conduct.html

Note: A version of this file is also available in the
[New Project repository](https://github.com/google/new-project/blob/master/docs/code-of-conduct.md).

================
File: CONTRIBUTING.md
================
# How to contribute

We'd love to accept your patches and contributions to this project.

## Contribution process

### Code reviews

All submissions, including submissions by project members, require review. We
use GitHub pull requests for this purpose. Consult
[GitHub Help](https://help.github.com/articles/about-pull-requests/) for more
information on using pull requests.

### Contributor Guide

You may follow these steps to contribute:

1. **Fork the official repository.** This will create a copy of the official repository in your own account.
2. **Sync the branches.** This will ensure that your copy of the repository is up-to-date with the latest changes from the official repository.
3. **Work on your forked repository's feature branch.** This is where you will make your changes to the code.
4. **Commit your updates on your forked repository's feature branch.** This will save your changes to your copy of the repository.
5. **Submit a pull request to the official repository's main branch.** This will request that your changes be merged into the official repository.
6. **Resolve any linting errors.** This will ensure that your changes are formatted correctly.

Here are some additional things to keep in mind during the process:

- **Test your changes.** Before you submit a pull request, make sure that your changes work as expected.
- **Be patient.** It may take some time for your pull request to be reviewed and merged.

================
File: Gemini.md
================
**A2A specification:** https://a2a-protocol.org/latest/specification/

## Project frameworks
- uv as package manager

## How to run all tests
1. If dependencies are not installed install them using following command
   ```
   uv sync --all-extras 
   ```

2. Run tests
  ```
  uv run pytest
  ```

## Other instructions
1. Whenever writing python code, write types as well.
2. After making the changes run ruff to check and fix the formatting issues
   ```
   uv run ruff check --fix
   ```
3. Run mypy type checkers to check for type errors
   ```
   uv run mypy
   ```
4. Run the unit tests to make sure that none of the unit tests are broken.

================
File: LICENSE
================
Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

================
File: pyproject.toml
================
[project]
name = "a2a-sdk"
dynamic = ["version"]
description = "A2A Python SDK"
readme = "README.md"
license = "Apache-2.0"
authors = [{ name = "Google LLC", email = "googleapis-packages@google.com" }]
requires-python = ">=3.10"
keywords = ["A2A", "A2A SDK", "A2A Protocol", "Agent2Agent", "Agent 2 Agent"]
dependencies = [
  "httpx>=0.28.1",
  "httpx-sse>=0.4.0",
  "pydantic>=2.11.3",
  "protobuf>=5.29.5",
  "google-api-core>=1.26.0",
]

classifiers = [
  "Intended Audience :: Developers",
  "Programming Language :: Python",
  "Programming Language :: Python :: 3",
  "Programming Language :: Python :: 3.10",
  "Programming Language :: Python :: 3.11",
  "Programming Language :: Python :: 3.12",
  "Programming Language :: Python :: 3.13",
  "Operating System :: OS Independent",
  "Topic :: Software Development :: Libraries :: Python Modules",
  "License :: OSI Approved :: Apache Software License",
]

[project.optional-dependencies]
http-server = ["fastapi>=0.115.2", "sse-starlette", "starlette"]
postgresql = ["sqlalchemy[asyncio,postgresql-asyncpg]>=2.0.0"]
mysql = ["sqlalchemy[asyncio,aiomysql]>=2.0.0"]
sqlite = ["sqlalchemy[asyncio,aiosqlite]>=2.0.0"]
sql = ["sqlalchemy[asyncio,postgresql-asyncpg,aiomysql,aiosqlite]>=2.0.0"]
encryption = ["cryptography>=43.0.0"]
grpc = ["grpcio>=1.60", "grpcio-tools>=1.60", "grpcio_reflection>=1.7.0"]
telemetry = ["opentelemetry-api>=1.33.0", "opentelemetry-sdk>=1.33.0"]

[project.urls]
homepage = "https://a2a-protocol.org/"
repository = "https://github.com/a2aproject/a2a-python"
changelog = "https://github.com/a2aproject/a2a-python/blob/main/CHANGELOG.md"
documentation = "https://a2a-protocol.org/latest/sdk/python/"

[tool.hatch.build.targets.wheel]
packages = ["src/a2a"]

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = "test_*.py"
python_functions = "test_*"
addopts = "-ra --strict-markers"
markers = [
  "asyncio: mark a test as a coroutine that should be run by pytest-asyncio",
]

[tool.pytest-asyncio]
mode = "strict"

[build-system]
requires = ["hatchling", "uv-dynamic-versioning"]
build-backend = "hatchling.build"

[tool.hatch.version]
source = "uv-dynamic-versioning"

[tool.hatch.build.targets.sdist]
exclude = ["tests/"]

[tool.uv-dynamic-versioning]
vcs = "git"
style = "pep440"

[dependency-groups]
dev = [
  "datamodel-code-generator>=0.30.0",
  "mypy>=1.15.0",
  "pytest>=8.3.5",
  "pytest-asyncio>=0.26.0",
  "pytest-cov>=6.1.1",
  "pytest-mock>=3.14.0",
  "respx>=0.20.2",
  "ruff>=0.11.6",
  "uv-dynamic-versioning>=0.8.2",
  "types-protobuf",
  "types-requests",
  "pre-commit",
  "fastapi>=0.115.2",
  "sse-starlette",
  "starlette",
  "pyupgrade",
  "autoflake",
  "no_implicit_optional",
  "trio",
]

[[tool.uv.index]]
name = "testpypi"
url = "https://test.pypi.org/simple/"
publish-url = "https://test.pypi.org/legacy/"
explicit = true

[tool.mypy]
plugins = ['pydantic.mypy']

[tool.pyright]
include = ["src"]
exclude = [
  "**/__pycache__",
  "**/dist",
  "**/build",
  "**/node_modules",
  "**/venv",
  "**/.venv",
  "src/a2a/grpc/",
]
reportMissingImports = "none"
reportMissingModuleSource = "none"

================
File: README.md
================
# A2A Python SDK

[![License](https://img.shields.io/badge/License-Apache_2.0-blue.svg)](LICENSE)
[![PyPI version](https://img.shields.io/pypi/v/a2a-sdk)](https://pypi.org/project/a2a-sdk/)
![PyPI - Python Version](https://img.shields.io/pypi/pyversions/a2a-sdk)
[![PyPI - Downloads](https://img.shields.io/pypi/dw/a2a-sdk)](https://pypistats.org/packages/a2a-sdk)

<!-- markdownlint-disable no-inline-html -->

<html>
   <h2 align="center">
   <img src="https://raw.githubusercontent.com/a2aproject/A2A/refs/heads/main/docs/assets/a2a-logo-black.svg" width="256" alt="A2A Logo"/>
   </h2>
   <h3 align="center">A Python library that helps run agentic applications as A2AServers following the <a href="https://a2a-protocol.org">Agent2Agent (A2A) Protocol</a>.</h3>
</html>

<!-- markdownlint-enable no-inline-html -->

## Installation

You can install the A2A SDK using either `uv` or `pip`.

## Prerequisites

- Python 3.10+
- `uv` (optional, but recommended) or `pip`

### Using `uv`

When you're working within a uv project or a virtual environment managed by uv, the preferred way to add packages is using uv add.

```bash
uv add a2a-sdk
```

To include the optional HTTP server components (FastAPI, Starlette), install the `http-server` extra:

```bash
uv add a2a-sdk[http-server]
```

To install with gRPC support:

```bash
uv add "a2a-sdk[grpc]"
```

To install with OpenTelemetry tracing support:

```bash
uv add "a2a-sdk[telemetry]"
```

To install with database support:

```bash
# PostgreSQL support
uv add "a2a-sdk[postgresql]"

# MySQL support
uv add "a2a-sdk[mysql]"

# SQLite support
uv add "a2a-sdk[sqlite]"

# All database drivers
uv add "a2a-sdk[sql]"
```

### Using `pip`

If you prefer to use pip, the standard Python package installer, you can install `a2a-sdk` as follows

```bash
pip install a2a-sdk
```

To include the optional HTTP server components (FastAPI, Starlette), install the `http-server` extra:

```bash
pip install a2a-sdk[http-server]
```

To install with gRPC support:

```bash
pip install "a2a-sdk[grpc]"
```

To install with OpenTelemetry tracing support:

```bash
pip install "a2a-sdk[telemetry]"
```

To install with database support:

```bash
# PostgreSQL support
pip install "a2a-sdk[postgresql]"

# MySQL support
pip install "a2a-sdk[mysql]"

# SQLite support
pip install "a2a-sdk[sqlite]"

# All database drivers
pip install "a2a-sdk[sql]"
```

## Examples

### [Helloworld Example](https://github.com/a2aproject/a2a-samples/tree/main/samples/python/agents/helloworld)

1. Run Remote Agent

   ```bash
   git clone https://github.com/a2aproject/a2a-samples.git
   cd a2a-samples/samples/python/agents/helloworld
   uv run .
   ```

2. In another terminal, run the client

   ```bash
   cd a2a-samples/samples/python/agents/helloworld
   uv run test_client.py
   ```

3. You can validate your agent using the agent inspector. Follow the instructions at the [a2a-inspector](https://github.com/a2aproject/a2a-inspector) repo.

You can also find more Python samples [here](https://github.com/a2aproject/a2a-samples/tree/main/samples/python) and JavaScript samples [here](https://github.com/a2aproject/a2a-samples/tree/main/samples/js).

## License

This project is licensed under the terms of the [Apache 2.0 License](https://raw.githubusercontent.com/a2aproject/a2a-python/refs/heads/main/LICENSE).

## Contributing

See [CONTRIBUTING.md](https://github.com/a2aproject/a2a-python/blob/main/CONTRIBUTING.md) for contribution guidelines.

================
File: SECURITY.md
================
# Security Policy

To report a security issue, please use [g.co/vulnz](https://g.co/vulnz).

The Google Security Team will respond within 5 working days of your report on g.co/vulnz.

We use g.co/vulnz for our intake, and do coordination and disclosure here using GitHub Security Advisory to privately discuss and fix the issue.




================================================================
End of Codebase
================================================================
